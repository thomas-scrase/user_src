//LIC// ====================================================================
//LIC// 
//LIC//====================================================================


//Header file for CellInterface elements
#ifndef OOMPH_FULLY_PARTITIONED_CELL_SOLVER_ELEMENTS_HEADER
#define OOMPH_FULLY_PARTITIONED_CELL_SOLVER_ELEMENTS_HEADER

// #define OOMPH_FORCE_SERIAL_SINGLE_CELL_SOLVE
// #define CHECK_SERIAL_AND_PARALLEL_CELL_SOLVE_DIFFERENCE

// Config header generated by autoconfig
#ifdef HAVE_CONFIG_H
	#include <oomph-lib-config.h>
#endif

//For the custom integration schemes
#include "../toms_utilities/toms_integral.h"


//OOMPH-LIB headers
#include "../generic/nodes.h"
#include "../generic/oomph_utilities.h"
#include "../generic/Qelements.h"
#include "../generic/Telements.h"
#include "../generic/error_estimator.h"
#include "../generic/problem.h"
#include "../generic/assembly_handler.h"
#include "../generic/refineable_mesh.h"
#include "../generic/triangle_mesh.h"


#include "../cell_models/cell_model_base.h"

#include "../cell_membrane_potential/cell_membrane_potential_elements.h"

#include "empty_place_holder_cell.h"

#include <boost/tokenizer.hpp>

namespace oomph
{

//A wrapper class for the membrane potential equations defined in CONDUCTANCE_MODEL. Essentially provides suitably overriden version of the
// functions which get data from the cell model as well as lookup schemes for the cells associated with the nodes of the element.
template <class CONDUCTANCE_MODEL>
class FullyPartitionedCellEquations : public virtual FiniteElement,
									public virtual CONDUCTANCE_MODEL,
									public virtual ConductingCellFunctionsBase
{
public:

	////General class functions

	//Constructor
	FullyPartitionedCellEquations() : CONDUCTANCE_MODEL()
	{
		//Provide storage for the pointer to each cell associated with each node in the element,
		// By default they are nullptrs because there is no cell associated by default
		Cell_associated_with_each_node_pt.resize(this->nnode(), nullptr);
	}

	//Destructor
	~FullyPartitionedCellEquations()
	{

	}


	//Sometimes when generating a mesh from a list of elements and nodes the elements are inverted
	//To solve this we simply swap the first and second nodes of the element, however this requires also
	//swapping the cell associated with the nodes as well so we provide a function to do it all for us
	void check_for_and_deal_with_inverted_jacobian()
	{
		//Check if it is negative
		bool jacobian_passed_test;
		this->check_J_eulerian_at_knots(jacobian_passed_test);
		//If it is, swap the first two node pointers
		if(!jacobian_passed_test)
		{
			//Save a pointer to the first node
			Node* nod_pt = this->node_pt(0);


			//Swap the first and second nodes
			this->node_pt(0) = this->node_pt(1);
			this->node_pt(1) = nod_pt;


			//Now we need to swap the pointers to the cells for the nodes,
			// we do this and reapply the initial conditions - essentially we are
			// calling the build cell function again but without actually re-building
			// the cell

			//Swap the cells associated with the nodes since we have swapped the nodes
			CellModelBaseFullyPartitioned* cell_pt = Cell_associated_with_each_node_pt[0];
			Cell_associated_with_each_node_pt[0] = Cell_associated_with_each_node_pt[1];
			Cell_associated_with_each_node_pt[1] = cell_pt;

			//Reinform the cells what the local node and coordinates are in the element

			//First the first cell

			//Get the integral point and local and global coordinates of the node in the element
			//Integral point
			unsigned ipt = this->ipt_at_node(0);
			//Local coordinate
			Vector<double> s;
			this->local_coordinate_of_node(0, s);
			//Global coordinate
			Vector<double> x(this->dim());
			this->get_x(s, x);
			//add the element and local and global coordinates to the cell
			Cell_associated_with_each_node_pt[0]->set_my_element_and_coordinate(dynamic_cast<DimensionlessMembranePotentialEquationsBase*>(this),
																this->node_pt(0),
																ipt, s, x, 0);

			//Then the second cell

			//Get the integral point and local and global coordinates of the node in the element
			//Integral point
			ipt = this->ipt_at_node(1);
			//Local coordinate
			this->local_coordinate_of_node(1, s);
			//Global coordinate
			this->get_x(s, x);
			//add the element and local and global coordinates to the cell
			Cell_associated_with_each_node_pt[1]->set_my_element_and_coordinate(dynamic_cast<DimensionlessMembranePotentialEquationsBase*>(this),
																this->node_pt(1),
																ipt, s, x, 1);
		}
		this->check_J_eulerian_at_knots(jacobian_passed_test);
		if(!jacobian_passed_test)
		{
			throw OomphLibError(
		        "Element is stil inverted after fix has been applied",
		        OOMPH_CURRENT_FUNCTION,
		        OOMPH_EXCEPTION_LOCATION);
		}

	}



	//get the integration point associated with node n
	inline unsigned ipt_at_node(const unsigned &n) const
			{return ipt_not_at_nodes + n;}

	//The required amount of storage per node, this is just what is required
	// by the CONDUCTANCE_MODEL parent class
	inline unsigned required_nvalue(const unsigned &n) const
	{
		return (CONDUCTANCE_MODEL::required_nvalue(n));
	}

	//Add a cell to the l-th node, this just sets the corresponding pointer
	inline void add_cell_to_node(const unsigned &l, CellModelBaseFullyPartitioned* cell_pt)
	{
		Cell_associated_with_each_node_pt[l] = cell_pt;
	}

	//Get a pointer to the cell associated with the node
	CellModelBaseFullyPartitioned* get_cell_at_node_pt(const unsigned& l) const
	{
		return Cell_associated_with_each_node_pt[l];
	}



	/////Get variables from cell model

	//Override the underling CONDUCTANCE_ELEMENT get_nodal_cell_vm_BaseCellMembranePotential
	// to get the predicted membrane potential from the cell associated with the l-th node
	double get_nodal_cell_vm_BaseCellMembranePotential(const unsigned &l) const override
	{
		//If the node has an associated cell then use that given by the cell model,
		//else just return the value at the node
		if(get_cell_at_node_pt(l)!=nullptr)
		{
			return get_cell_at_node_pt(l)->get_membrane_potential();
		}
		else
		{
			throw OomphLibError(
		        "No cell assigned to node",
		        OOMPH_CURRENT_FUNCTION,
		        OOMPH_EXCEPTION_LOCATION);
		}
	}

	
	
	

	// //Get the local predicted vm and dprecicted vm dx from the cells at the nodes of this element
	// // Called by external elements when they want our predicted vm
	// inline void get_interpolated_cell_vm_and_dcell_vm_dx(double &interpolated_pred_vm, Vector<double> &interpolated_dpred_vm_dx, const Vector<double>& s) const
	// {
	// 	//Zero the data
	// 	interpolated_pred_vm = 0;
	// 	for(unsigned j=0;j<this->dim();j++)
	// 	{
	// 		interpolated_dpred_vm_dx[j] = 0.0;
	// 	}

	// 	const unsigned n_node = this->nnode();

	// 	//Set up memory for the shape functions
	// 	Shape psi(n_node);
	// 	DShape dpsidx(n_node,this->dim());

	// 	//Compute the shape functions
	// 	this->dshape_eulerian(s,psi,dpsidx);

	// 	//Loop over the nodes
	// 	for(unsigned l=0; l<n_node; l++)
	// 	{
	// 		const double val = this->get_nodal_cell_vm_BaseCellMembranePotential(l);
	// 		//Add to interpolation
	// 		interpolated_pred_vm += psi[l]*val;

	// 		//Calculate interpolated spatial derivatives
	// 		for(unsigned j=0;j<this->dim();j++)
	// 		{
	// 			interpolated_dpred_vm_dx[j] += val*dpsidx(l,j);
	// 		}
	// 	}
	// }

	//Get the local interpolated Vm predicted from cell model (same as above but returns a value instead and does not compute derivatives)
	double get_interpolated_cell_vm_from_cell_model(const Vector<double>& s) const
	{
		//The thing we are outputting
		double out = 0.0;
		//The shape function
		const unsigned n_node = this->nnode();
		Shape psi(n_node);
		this->shape(s,psi);
		//Loop over the nodes
		for(unsigned l=0; l<n_node; l++)
		{
			out += psi[l]*this->get_nodal_cell_vm_BaseCellMembranePotential(l);
		}
		return out;
	}



	//Get the interpolated diffusion matrix at the local coordinate s
	void get_interpolated_diffusion_tensor(const Vector<double>& s, DenseMatrix<double>& D) const
	{
		const unsigned n_node = this->nnode();
		Shape psi(n_node);
		this->shape(s,psi);
		const unsigned dim = this->dim();

		D.resize(dim, dim, 0.0);

		for(unsigned l=0; l<n_node; l++)
		{
			for(unsigned i=0; i<dim; i++)
			{
				for(unsigned j=0; j<dim; j++)
				{
					D(i,j) += (get_cell_at_node_pt(l)->get_diffusion_tensor(i,j))*psi[l];
				}
			}
		}
	}

	//Override the get diffusion tensor of the underlying conductance element to get it from the method defined above
	inline void get_diff_BaseCellMembranePotential(const unsigned& ipt,
													const Vector<double> &s,
													const Vector<double>& x,
													DenseMatrix<double>& D) const override
	{
		//If no diff function has been set, return the tensor given by the storage
		if(this->diff_fct_pt()==0)
		{	
			// oomph_info << "Getting interpolated diffusion tensor from cells" << std::endl;
			get_interpolated_diffusion_tensor(s, D);
		}
		else
		{
			// Get diffusivity tensor from function
			(*this->diff_fct_pt())(x,D);
		}
	}

	//For external solid elements to get the alingment vectors
	void get_interpolated_cell_alignment(const Vector<double>& s,  Vector<Vector<double>>& A) const
	{
		//The shape function
		const unsigned n_node = this->nnode();
		Shape psi(n_node);
		this->shape(s,psi);

		// oomph_info << "Resizing preferential vects for solid elem " << this->dim() << std::endl;
		A.resize(this->dim());

		for(unsigned vect=0; vect<this->dim(); vect++)
		{
			double norm = 0.0;
			A[vect].resize(this->dim());
			for(unsigned dim=0; dim<this->dim(); dim++)
			{
				(A[vect])[dim] = 0.0;
				for(unsigned l=0; l<n_node; l++)
				{
					(A[vect])[dim] += psi[l]*(get_cell_at_node_pt(l)->get_cell_alignment(vect, dim));
				}

				norm += (A[vect])[dim]*(A[vect])[dim];
			}

			for(unsigned dim=0; dim<this->dim(); dim++)
			{
				(A[vect])[dim] /= sqrt(norm);
			}
		}
	}


	//Get active strain from cell model
	inline double get_nodal_active_strain(const unsigned &l, const double& time) const
	{
		//If the node has an associated cell then use that given by the cell model,
		//else just return the value zero
		if(get_cell_at_node_pt(l)!=nullptr)
		{
			//Calculate optional output of the cell
			// get_cell_at_node_pt(l)->calculate_optional_output(time);
			return get_cell_at_node_pt(l)->get_active_strain();
		}
		else
		{
			//If there is no cell just return no active strain
			return 0.0;
		}
	}


	//Get interpolated active strain from cell model
	double get_interpolated_active_strain_from_cell_model(const Vector<double>& s) const
	{
		const double time = this->node_pt(0)->time_stepper_pt()->time_pt()->time();
		// oomph_info << "time for strain " << time << std::endl;
		//The thing we are outputting
		double out = 0.0;
		//The shape function
		const unsigned n_node = this->nnode();
		Shape psi(n_node);
		this->shape(s,psi);
		//Loop over the nodes
		for(unsigned l=0; l<n_node; l++)
		{
			out += psi[l]*get_nodal_active_strain(l, time);
		}

		return out;
	}

	//Fill in residuals and jacobian functions, just call those of the underlying CONDUCTANCE_MODEL class
	// since that is the only one which does oomph-lib stuff
	void fill_in_contribution_to_residuals(Vector<double> &residuals)
	{
		CONDUCTANCE_MODEL::fill_in_generic_residual_contribution_BaseCellMembranePotential(residuals, GeneralisedElement::Dummy_matrix,
																				GeneralisedElement::Dummy_matrix, 0);
	}

	void fill_in_contribution_to_jacobian(Vector<double> &residuals,
		                                   DenseMatrix<double> &jacobian)
	{	
		CONDUCTANCE_MODEL::fill_in_contribution_to_jacobian(residuals, jacobian);
		// fill_in_contribution_to_jacobian(residuals, jacobian);
	}

	void fill_in_contribution_to_jacobian_and_mass_matrix(Vector<double> &residuals, DenseMatrix<double> &jacobian,
															DenseMatrix<double> &mass_matrix)
	{
		//Broken - how can this be filled in for the cell variables? - Not obvious
		FiniteElement::fill_in_contribution_to_jacobian_and_mass_matrix(residuals, jacobian, mass_matrix);
	}



	//Interpolate the i-th cell variable, this function is only used in paraview output
	//We need to check that we are only interpolating from one cell model, since an element
	// can contain many cell models. There is a variable "paraview_output_type" which
	// informs the function which cell model type to choose. It checks which nodes are of that
	// type and interpolates only from them...This could be a bit dodgy...but it sets interpolation
	// weights from the wrong cell model to zero and then normalizes the remaining ones.
	double get_interpolated_paraview_output_from_cell_model(const unsigned& i, const Vector<double>& s) const
	{
		//The thing we are outputting
		double out = 0.0;

		//Get the interpolation weights at the point s
		const unsigned n_node = this->nnode();
		Shape psi(n_node);
		this->shape(s,psi);

		Vector<double> interp_weights(n_node, 0.0);
		double interp_weights_magnitude = 0.0;
		bool all_are_zero = true;
		Vector<unsigned> interpolated_nodes;
		//Determine which nodes are associated with cells of the correct model type
		for(unsigned l=0; l<n_node; l++)
		{
			//If the cell associated with the node is the same type as what we are outputting
			if(get_cell_at_node_pt(l)->get_cell_model_name() == paraview_output_type)
			{
				//Set that weight
				interp_weights[l] = psi[l];
				all_are_zero = false;
				interpolated_nodes.push_back(l);
				interp_weights_magnitude += psi[l]*psi[l];
			}
		}
		//If all are zero then return nan, none of the cells contain the data we want
		if(all_are_zero){return std::nanf("");}

		//Normalise the vector
		interp_weights_magnitude = std::sqrt(interp_weights_magnitude);
		for(unsigned l=0; l<n_node; l++)
		{
			interp_weights[l] /= interp_weights_magnitude;
		}

		//Finally, interpolate the cell variable
		for(const unsigned l : interpolated_nodes)
		{
			// out += get_cell_at_node_pt(l)->get_cell_variable(i)*interp_weights[l];
			out += get_cell_at_node_pt(l)->get_paraview_output(i)*interp_weights[l];
		}

		return out;
	}


	unsigned nscalar_paraview() const
	{
		return this->paraview_nscalar;
	}

	void scalar_value_paraview(std::ofstream& file_out,
								const unsigned& i,
								const unsigned& nplot) const
	{
		//Vector of local coordinates
		Vector<double> s(this->dim());

		// const unsigned n_node = this->nnode();
		// const unsigned vm_index = this->vm_index_BaseCellMembranePotential();
		// Shape psi(n_node);
		// DShape dpsidx(n_node,this->dim());

		// Loop over plot points
		unsigned num_plot_points=this->nplot_points_paraview(nplot);
		for(unsigned iplot=0;iplot<num_plot_points;iplot++){
			// Get local coordinates of plot point
			this->get_s_plot(iplot,nplot,s);

			file_out << this->get_interpolated_paraview_output_from_cell_model(i, s) << std::endl;
		}
	}

	void scalar_value_fct_paraview(std::ofstream& file_out,
									const unsigned& i,
									const unsigned& nplot,
									FiniteElement::SteadyExactSolutionFctPt exact_soln_pt) const
	{
		scalar_value_paraview(file_out, i, nplot);
	}

	std::string scalar_name_paraview(const unsigned& i) const
	{
		return this->Variable_Names_BroadCast_From_Cell_Mesh[i];
	}



protected:
	//The number of integral points which are not additional ones placed at the nodes
	unsigned ipt_not_at_nodes;

private:
	//Pointer to the cell corresponding to each node in the element
	Vector<CellModelBaseFullyPartitioned*> Cell_associated_with_each_node_pt;
};













//Q Element
template<unsigned DIM, unsigned NNODE_1D, template<unsigned> class CONDUCTANCE_MODEL>
class QFullyPartitionedCellElement : public virtual QElement<DIM, NNODE_1D>,
									public virtual FullyPartitionedCellEquations<CONDUCTANCE_MODEL<DIM>>
{
private:

	inline static GaussWithNodes<DIM, NNODE_1D> NewIntegralScheme;

public:

	QFullyPartitionedCellElement() : QElement<DIM, NNODE_1D>(),
									FullyPartitionedCellEquations<CONDUCTANCE_MODEL<DIM>>()
	{
		//set the integration scheme to one with integral points aligned with the nodes
		// GaussWithNodes<DIM, NNODE_1D>* new_integral_pt = new GaussWithNodes<DIM, NNODE_1D>;
		// this->set_integration_scheme(new GaussWithNodes<DIM, NNODE_1D>);
		this->set_integration_scheme(&NewIntegralScheme);
		//set the number of integral points which are not aligned with nodes
		this->ipt_not_at_nodes = this->integral_pt()->nweight() - this->nnode();
	}

	QFullyPartitionedCellElement(const QFullyPartitionedCellElement<DIM, NNODE_1D, CONDUCTANCE_MODEL>& dummy){BrokenCopy::broken_copy("QFullyPartitionedCellElement");}

	void operator=(const QFullyPartitionedCellElement<DIM, NNODE_1D, CONDUCTANCE_MODEL>&){BrokenCopy::broken_assign("QFullyPartitionedCellElement");}


	//====================================================================
	//Output functions
	//====================================================================
	/// Output with default number of plot points
	void output(std::ostream &outfile)
	{
		FullyPartitionedCellEquations<CONDUCTANCE_MODEL<DIM>>::output(outfile);
	}
	/// \short Output FE representation of soln: x,y,V_fct,[vars] or x,y,z,V_fct,[vars] at 
	/// nplot^DIM plot points
	void output(std::ostream &outfile, const unsigned &nplot)
	{
		FullyPartitionedCellEquations<CONDUCTANCE_MODEL<DIM>>::output(outfile, nplot);
	}
	/// C_style output with default number of plot points
	void output(FILE* file_pt)
	{
		FullyPartitionedCellEquations<CONDUCTANCE_MODEL<DIM>>::output(file_pt);
	}
	/// \short C-style output FE representation of soln: x,y,V_fct,[vars] or x,y,z,V_fct,[vars] at 
	/// n_plot^DIM plot points
	void output(FILE* file_pt, const unsigned &n_plot)
	{
	 	FullyPartitionedCellEquations<CONDUCTANCE_MODEL<DIM>>::output(file_pt, n_plot);
	}


	void output_fct(std::ostream &outfile, const unsigned &n_plot,
	                 FiniteElement::SteadyExactSolutionFctPt 
	                 exact_soln_pt)
	{
		FullyPartitionedCellEquations<CONDUCTANCE_MODEL<DIM>>::output_fct(outfile, n_plot, exact_soln_pt);
	}
	void output_fct(std::ostream &outfile, const unsigned &n_plot,
	                 const double& time,
	                 FiniteElement::UnsteadyExactSolutionFctPt 
	                 exact_soln_pt)
	{
		FullyPartitionedCellEquations<CONDUCTANCE_MODEL<DIM>>::output_fct(outfile, n_plot, time, exact_soln_pt);
	}

	//======================================================================
	/// \short Define the shape functions and test functions and derivatives
	/// w.r.t. global coordinates and return Jacobian of mapping.
	///
	/// Galerkin: Test functions = shape functions
	//======================================================================
	double dshape_and_dtest_eulerian_BaseCellMembranePotential(const Vector<double> &s,
														Shape &psi, 
														DShape &dpsidx,
														Shape &test, 
														DShape &dtestdx) const
	{
		//Call the geometrical shape functions and derivatives  
		double J = this->dshape_eulerian(s,psi,dpsidx);
		//Loop over the test functions and derivatives and set them equal to the
		//shape functions
		for(unsigned i=0;i<NNODE_1D;i++)
		{
			test[i] = psi[i]; 
			for(unsigned j=0;j<DIM;j++)
			{
				dtestdx(i,j) = dpsidx(i,j);
			}
		}
		//Return the jacobian
		return J;
	}

	//======================================================================
	/// Define the shape functions and test functions and derivatives
	/// w.r.t. global coordinates and return Jacobian of mapping.
	///
	/// Galerkin: Test functions = shape functions
	//======================================================================
	double dshape_and_dtest_eulerian_at_knot_BaseCellMembranePotential(const unsigned &ipt,
																Shape &psi, 
																DShape &dpsidx,
																Shape &test, 
																DShape &dtestdx) const
	{
		//Call the geometrical shape functions and derivatives  
		double J = this->dshape_eulerian_at_knot(ipt,psi,dpsidx);
		//Set the test functions equal to the shape functions (pointer copy)
		test = psi;
		dtestdx = dpsidx;
		//Return the jacobian
		return J;
	}

	double d2shape_and_d2test_eulerian_at_knot_BaseCellMembranePotential(const unsigned &ipt, 
																		Shape &psi, 
																		DShape &dpsidx, 
																		DShape &d2psidx,
																		Shape &test, 
																		DShape &dtestdx, 
																		DShape &d2testdx) const
	{
		const double J = this->d2shape_eulerian_at_knot(ipt, psi, dpsidx, d2psidx);
		test = psi;
		dtestdx = dpsidx;
		d2testdx = d2psidx;

		return J;
	}

};


template<unsigned NNODE_1D, unsigned DIM, template<unsigned> class CONDUCTANCE_MODEL>
class FaceGeometry<QFullyPartitionedCellElement<DIM, NNODE_1D, CONDUCTANCE_MODEL> >:
	public virtual QElement<DIM-1, NNODE_1D>
{
public:
	FaceGeometry()	:	QElement<DIM-1, NNODE_1D>()	{}
};	

template<unsigned NNODE_1D, template<unsigned> class CONDUCTANCE_MODEL>
class FaceGeometry<QFullyPartitionedCellElement<1, NNODE_1D, CONDUCTANCE_MODEL> >:
	public virtual PointElement
{
public:
	FaceGeometry()	:	PointElement()	{}
};






//T Element
template<unsigned DIM, unsigned NNODE_1D, template<unsigned> class CONDUCTANCE_MODEL>
class TFullyPartitionedCellElement : public virtual TElement<DIM, NNODE_1D>,
									public virtual FullyPartitionedCellEquations<CONDUCTANCE_MODEL<DIM>>
{
private:
	inline static TGaussWithNodes<DIM, NNODE_1D> NewIntegralScheme;
	
public:
	TFullyPartitionedCellElement() : TElement<DIM, NNODE_1D>(),
									FullyPartitionedCellEquations<CONDUCTANCE_MODEL<DIM>>()
	{
		//set the integration scheme to one with integral points aligned with the nodes
		// TGaussWithNodes<DIM, NNODE_1D>* new_integral_pt = new TGaussWithNodes<DIM, NNODE_1D>;
		// this->set_integration_scheme(new TGaussWithNodes<DIM, NNODE_1D>);
		this->set_integration_scheme(&NewIntegralScheme);
		//set the number of integral points which are not aligned with nodes
		this->ipt_not_at_nodes = this->integral_pt()->nweight() - this->nnode();
	}

	TFullyPartitionedCellElement(const TFullyPartitionedCellElement<DIM, NNODE_1D, CONDUCTANCE_MODEL>& dummy){BrokenCopy::broken_copy("TFullyPartitionedCellElement");}

	void operator=(const TFullyPartitionedCellElement<DIM, NNODE_1D, CONDUCTANCE_MODEL>&){BrokenCopy::broken_assign("TFullyPartitionedCellElement");}


	//====================================================================
	//Output functions
	//====================================================================
	/// Output with default number of plot points
	void output(std::ostream &outfile){
		FullyPartitionedCellEquations<CONDUCTANCE_MODEL<DIM>>::output(outfile);
	}
	/// \short Output FE representation of soln: x,y,V_fct,[vars] or x,y,z,V_fct,[vars] at 
	/// nplot^DIM plot points
	void output(std::ostream &outfile, const unsigned &nplot){
		FullyPartitionedCellEquations<CONDUCTANCE_MODEL<DIM>>::output(outfile, nplot);
	}
	/// C_style output with default number of plot points
	void output(FILE* file_pt){
		FullyPartitionedCellEquations<CONDUCTANCE_MODEL<DIM>>::output(file_pt);
	}
	 /// \short C-style output FE representation of soln: x,y,V_fct,[vars] or x,y,z,V_fct,[vars] at 
	 /// n_plot^DIM plot points
	 void output(FILE* file_pt, const unsigned &n_plot){
	 	FullyPartitionedCellEquations<CONDUCTANCE_MODEL<DIM>>::output(file_pt, n_plot);
	}

	//======================================================================
	/// \short Define the shape functions and test functions and derivatives
	/// w.r.t. global coordinates and return Jacobian of mapping.
	///
	/// Galerkin: Test functions = shape functions
	//======================================================================
	double dshape_and_dtest_eulerian_BaseCellMembranePotential(const Vector<double> &s,
														Shape &psi, 
														DShape &dpsidx,
														Shape &test, 
														DShape &dtestdx) const
	{
		//Call the geometrical shape functions and derivatives  
		double J = this->dshape_eulerian(s,psi,dpsidx);
		//Loop over the test functions and derivatives and set them equal to the
		//shape functions
		for(unsigned i=0;i<NNODE_1D;i++)
		{
			test[i] = psi[i]; 
			for(unsigned j=0;j<DIM;j++)
			{
				dtestdx(i,j) = dpsidx(i,j);
			}
		}
		//Return the jacobian
		return J;
	}

	//======================================================================
	/// Define the shape functions and test functions and derivatives
	/// w.r.t. global coordinates and return Jacobian of mapping.
	///
	/// Galerkin: Test functions = shape functions
	//======================================================================
	double dshape_and_dtest_eulerian_at_knot_BaseCellMembranePotential(const unsigned &ipt,
																Shape &psi, 
																DShape &dpsidx,
																Shape &test, 
																DShape &dtestdx) const
	{
		//Call the geometrical shape functions and derivatives  
		double J = this->dshape_eulerian_at_knot(ipt,psi,dpsidx);
		//Set the test functions equal to the shape functions (pointer copy)
		test = psi;
		dtestdx = dpsidx;
		//Return the jacobian
		return J;
	}

	double 	d2shape_and_d2test_eulerian_at_knot_BaseCellMembranePotential(const unsigned &ipt, 
																		Shape &psi, 
																		DShape &dpsidx, 
																		DShape &d2psidx,
																		Shape &test, 
																		DShape &dtestdx, 
																		DShape &d2testdx) const
	{
		const double J = this->d2shape_eulerian_at_knot(ipt, psi, dpsidx, d2psidx);
		test = psi;
		dtestdx = dpsidx;
		d2testdx = d2psidx;

		return J;
	}

};


template<unsigned NNODE_1D, unsigned DIM, template<unsigned> class CONDUCTANCE_MODEL>
class FaceGeometry<TFullyPartitionedCellElement<DIM, NNODE_1D, CONDUCTANCE_MODEL> >:
	public virtual TElement<DIM-1, NNODE_1D>
{
public:
	FaceGeometry()	:	TElement<DIM-1, NNODE_1D>()	{}
};	

template<unsigned NNODE_1D, template<unsigned> class CONDUCTANCE_MODEL>
class FaceGeometry<TFullyPartitionedCellElement<1, NNODE_1D, CONDUCTANCE_MODEL> >:
	public virtual PointElement
{
public:
	FaceGeometry()	:	PointElement()	{}
};





















//Mesh base class which handles cell objects and provides suitable pointers to the cells to each element in the mesh
//NOTE this class requires the elements and nodes to already be constructed hence you MUST inherit from this class
// AFTER the mesh class
template<class CONDUCTANCE_MODEL>
class CellMeshBase : public virtual Mesh
{
public:
	//The constructor
	CellMeshBase() : NumCells(0)
	{
		CONDUCTANCE_MODEL* test_elem = new CONDUCTANCE_MODEL;

		DimensionlessMembranePotentialEquationsBase* test_elem_pt = dynamic_cast<DimensionlessMembranePotentialEquationsBase*>(test_elem);

		if(test_elem_pt==nullptr)
		{
			throw OomphLibError("CONDUCTANCE_MODEL must inherit from DimensionlessMembranePotentialEquationsBase",
								OOMPH_CURRENT_FUNCTION,
								OOMPH_EXCEPTION_LOCATION);
		}
	}

	//Destructor, delete the cells
	~CellMeshBase()
	{
		//Kill all the cells
		for(unsigned c=0; c<NumCells; c++)
		{
			delete Cells_pt[c];
			Cells_pt[c] = 0;
		}
	}

	//Access to the ith cell in the mesh
	CellModelBaseFullyPartitioned* cell_pt(const unsigned& i)
	{
		#ifdef PARANOID
		if(Cells_pt[i]!=nullptr)
		{
		#endif
			return Cells_pt[i];
		#ifdef PARANOID
		}
		else
		{
			throw OomphLibError("Cell ptr is null",
								OOMPH_CURRENT_FUNCTION,
								OOMPH_EXCEPTION_LOCATION);
		}
		#endif
	}

	//Access the cell associated with the l-th node in the mesh
	CellModelBaseFullyPartitioned* cell_at_node_pt(const unsigned& l)
	{
		#ifdef PARANOID
		if(Node_Number_To_Cell_Number[l]>=0)
		{
		#endif
			return Cells_pt[Node_Number_To_Cell_Number[l]];
		#ifdef PARANOID
		}
		else
		{
			throw OomphLibError("Node has no cell",
								OOMPH_CURRENT_FUNCTION,
								OOMPH_EXCEPTION_LOCATION);
		}
		#endif
	}	

	//Get the number of cells in the mesh
	inline unsigned num_cells() const {return NumCells;}


private:

	//Work out what elements contain each global node number and which local node indexes within these element corresponds to those nodes.
	void BuildNodeElementTables()
	{
		//Original slow brute force method

		// //First we allocate suitable storage in the vectors
		// Elements_containing_node.resize(this->nnode());

		// //Next we loop over all the nodes
		// for(unsigned l=0; l<this->nnode(); l++){
		// 	//Get a pointer to the l-th node
		// 	Node* mesh_nod_pt = this->node_pt(l);

		// 	//Next loop over all the elements in the mesh
		// 	for(unsigned e=0; e<this->nelement(); e++){
		// 		//Get a pointer to the element
		// 		FiniteElement* elem_pt = this->finite_element_pt(e);

		// 		//Now we loop over the nodes in that element
		// 		for(unsigned l1=0; l1<elem_pt->nnode(); l1++){
		// 			//get a pointer to that element
		// 			Node* elem_nod_pt = elem_pt->node_pt(l1);

		// 			if(mesh_nod_pt==elem_nod_pt){
		// 				//If the pointers point to the same object then add the element and the local node number to the table
		// 				Elements_containing_node[l].push_back(std::pair<unsigned long, unsigned>(e, l1));
		// 			}
		// 		}
		// 	}
		// }


		//Much faster method

		oomph_info << "Building node-element/local node table" << std::endl;
		double t_start = TimingHelpers::timer();

		// oomph_info << this->nnode() << " " << this->nelement() << std::endl;

		//First we allocate suitable storage in the vectors
		Elements_containing_node.clear();
		Elements_containing_node.resize(this->nnode());

		//Resize storage of cell numbers assigned to each node.
		Node_Number_To_Cell_Number.clear();
		Node_Number_To_Cell_Number.resize(this->nnode(), -1);

		//Map of node pointers to global node number
		std::map<Node*, unsigned> Node_pt_to_global_number;
		//Build the map of node pointers to global node numbers
		for(unsigned l=0; l<this->nnode(); l++){
			//Get a pointer to the l-th node
			Node* nod_pt = this->node_pt(l);
			//Fill in the entry
			Node_pt_to_global_number[nod_pt] = l;
		}

		//Loop over all the elements in the mesh
		for(unsigned e=0; e<this->nelement(); e++){
			//get a pointer to the element
			FiniteElement* elem_pt = this->finite_element_pt(e);
			//Now we loop over the nodes in that element
			for(unsigned l1=0; l1<elem_pt->nnode(); l1++){
				//get a pointer to that element
				Node* elem_nod_pt = elem_pt->node_pt(l1);
				//Use the map setup earlier to determine what the global node number of the local node l1 is and fill in its entry of the table
				Elements_containing_node[Node_pt_to_global_number[elem_nod_pt]].push_back(std::pair<unsigned long, unsigned>(e, l1));
			}
		}


		// for(unsigned l=0; l<this->nnode(); l++){
		// 	oomph_info << "Node " << l << ": " << std::endl;
		// 	for(unsigned e=0; e<Elements_containing_node[l].size(); e++){
		// 		oomph_info << "\t" << Elements_containing_node[l][e].first << " " << Elements_containing_node[l][e].second << std::endl;
		// 	}
		// 	oomph_info << std::endl;
		// }


		double t_end = TimingHelpers::timer();
		oomph_info << "Done. It took me " << (t_end - t_start) << " seconds." << std::endl;

	}

protected:

	//Should you wish to change the way the mesh calculates the elements containing each node then use this function
	void Set_Elements_containing_node(const Vector<Vector<std::pair<unsigned long, unsigned>>> &new_vect)
	{
		Elements_containing_node = new_vect;
	}

	//This function is left virtual since the way in which cells are built on the mesh is entirely problem-dependent.
	// the helper function build_cell_at_node(...) is provided to handle all of the tricky communications, I strongly
	// recommend you use it, if you for any reason do not need to use it please let me know so I can change the functionality
	virtual void BuildCells()
	{
		throw OomphLibError(
			"BuildCells, this function has not been implemented yet.\nOverride this function in your implementation of the mesh so that I know how to build the cells in the mesh",
			OOMPH_CURRENT_FUNCTION,
			OOMPH_EXCEPTION_LOCATION);
	}

	//Fill in place-holder cells at nodes without a cell assigned. This is required since operator splitting solves
	// use the membrane potential values stored at the cells for the previous time-step. If no cell is assigned
	// then iterations of newton method converge very slowly since it will always take the value stored at the node
	// whereas we want the value to be the constant, previously accepted value
	virtual void FillInPlaceHolderCells()
	{
		const unsigned n_node = this->nnode();
		for(unsigned l=0; l<n_node; l++)
		{
			//If no cell has been assigned to it, give it an empty place-holder cell
			if(Node_Number_To_Cell_Number[l]<0)
			{
				build_cell_at_node<Empty_Cell>(l, 1);
			}
		}
	}

	//Build a cell at the location of the l-th node in the mesh. We need to pass the cell by pointer to all elements which contain
	// the l-th node in the mesh and also pass one of these elements and the local coordinate of the node within that element
	// to the cell.
	template<class CELL_MODEL>
	CELL_MODEL* build_cell_at_node(const unsigned long& l, const unsigned& r)
	{
		//Build the cell
		Cells_pt.push_back(new CELL_MODEL(r));

		//Add the cell to the node, setup all lookup schemes required by element, node, and cell.
		add_cell_to_node(l, NumCells);

		//Why would I put this here? The cells have no cell type
		//Call the cell to assign initial conditions
		// Cells_pt[NumCells]->assign_initial_conditions(true);

		//Increment the number of cells
		NumCells++;

		return dynamic_cast<CELL_MODEL*>(Cells_pt[NumCells-1]);
	}


	//Add cell to node
	void add_cell_to_node(const unsigned long& l, const unsigned long& cell_ind)
	{
		bool passed_to_cell = false;
		//Pass the cell by pointer to all of the elements containing the node
		for(unsigned i=0; i<Elements_containing_node[l].size(); i++)
		{
			//Get a pointer to the i-th element containing the node
			CONDUCTANCE_MODEL* elem_pt = dynamic_cast<CONDUCTANCE_MODEL*>(this->element_pt(Elements_containing_node[l][i].first));
			
			#ifdef OOMPH_HAS_MPI
			//Check if the element exists if we are in parallel since it may have been deleted in a distribute
			if(elem_pt!=nullptr)
			{
				if(dynamic_cast<CONDUCTANCE_MODEL*>(elem_pt)!=nullptr)
				{
					if(dynamic_cast<DimensionlessMembranePotentialEquationsBase*>(elem_pt)!=nullptr)
					{
			#endif
						const unsigned node_ind = Elements_containing_node[l][i].second;

						//Add the pointer to the suitable entry in the vector of cell pointers in the element
						elem_pt->add_cell_to_node(node_ind, Cells_pt[cell_ind]);

						//If we haven't yet, pass the element and node to the cell
						if(!passed_to_cell)
						{
							//Get the integral point and local and global coordinates of the node in the element
							//Integral point
							const unsigned ipt = elem_pt->ipt_at_node(node_ind);
							//Local coordinate
							Vector<double> s;
							elem_pt->local_coordinate_of_node(node_ind, s);
							//Global coordinate
							Vector<double> x(elem_pt->dim());
							elem_pt->get_x(s, x);

							//add the element and local and global coordinates to the cell
							Cells_pt[cell_ind]->set_my_element_and_coordinate(dynamic_cast<DimensionlessMembranePotentialEquationsBase*>(elem_pt),
																				elem_pt->node_pt(node_ind),
																				// Cells_pt[cell_ind],
																				// elem_pt->vm_index_BaseCellMembranePotential(),
																				ipt, s, x, node_ind);

							//It was successfully passed to a node, so we (as a mesh) need to check if it is a new cell model type we need to keep track of
							bool cell_model_type_is_new = true;
							if(Identified_Cell_Model_Types_And_Data.size()==0) //if this is the first cell added then it will always be a new type
							{

							}
							else
							{
								for(auto data : Identified_Cell_Model_Types_And_Data)
								{
									if(Cells_pt[cell_ind]->get_cell_model_name() == std::get<0>(data))
									{
										cell_model_type_is_new = false;
									}
								}
							}
							if(cell_model_type_is_new)//add it as a new cell model type
							{
								std::string model_name = Cells_pt[cell_ind]->get_cell_model_name();
								std::vector<std::string> vars_names = Cells_pt[cell_ind]->names_of_cell_variables();
								std::vector<std::string> vars_names_1 = Cells_pt[cell_ind]->names_of_output_data();
								vars_names.insert(vars_names.end(), vars_names_1.begin(), vars_names_1.end());

								unsigned num_vars = vars_names.size(); //+1 to account for membrane potential
								Identified_Cell_Model_Types_And_Data.push_back(std::make_tuple(model_name, vars_names, num_vars));
							}

							passed_to_cell = true;
						}
			#ifdef OOMPH_HAS_MPI
					}
				}
			}
			#endif

		}

		if(!passed_to_cell)
		{
			throw OomphLibError("There is no element left which contains this node",
								OOMPH_CURRENT_FUNCTION,
								OOMPH_EXCEPTION_LOCATION);
		}

		//Record for the node what cell is assigned to it
		Node_Number_To_Cell_Number[l] = cell_ind;
	}


	//Set alignment vector of node
	void set_alignment_vector_of_cell(const unsigned long& cell_ind, const unsigned& vect, const unsigned& dim, const double& val)
	{
		Cells_pt[cell_ind]->set_cell_alignment(vect, dim, val);
	}

	//Set set_nodal_cell_conductance
	void set_conductance_of_cell(const unsigned long& cell_ind, const unsigned& vect, const double& val)
	{
		Cells_pt[cell_ind]->set_cell_conductance(vect, val);
	}	

	//Setup the indexes of where in the vector of cell data each cells data begins
	// Needed for communicating the accepted value at the end of mpi solve back to the cells
	// Data is packaged as Vm_0, w_0, Vm_1, w_1, ... , Vm_n, w_n
	#ifdef OOMPH_HAS_MPI
	void SetupDataIndices()
	{
		//provide suitable storage
		Starting_Index_For_Data_Of_Cell.resize(NumCells, 0);

		//iterate through the cells other than the first, that one starts at 0
		for(unsigned c=1; c<NumCells; c++)
		{
			Starting_Index_For_Data_Of_Cell[c] = (Starting_Index_For_Data_Of_Cell[c-1]) + (Cells_pt[c-1]->get_Num_Cell_Vars() + Cells_pt[c-1]->get_Num_Output_Data()) + 1;
		}

		//The total number of data associated with the cells
		Total_cell_data = (Starting_Index_For_Data_Of_Cell[NumCells-1]) + (Cells_pt[NumCells-1]->get_Num_Cell_Vars() + Cells_pt[NumCells-1]->get_Num_Output_Data()) + 1;
	}
	#endif


	//Called by the mesh constructor:
	// sets up node-element lookup
	// builds cells
	// fills in any required placeholder cells
	// sets up data indices for mpi communicate stage if required
	virtual void FinalizeMeshSetup()
	{
		//Setup node and element tables
		BuildNodeElementTables();

		//Build the cells in the mesh, this is a user overloaded function
		BuildCells();

		//Complete the cell build by adding place-holder empty cells to nodes without a cell
		// FillInPlaceHolderCells();

		#ifdef OOMPH_HAS_MPI
		SetupDataIndices();
		#endif
	}


	//Vector of pointers to cells in the mesh
	Vector<CellModelBaseFullyPartitioned*> Cells_pt;
	
private:

	//The number of cells in the mesh
	unsigned long NumCells;

	//Vector containing vectors of element numbers containing each node in the mesh and the local node number of the node within that element
	// Global_Node_index[Element_Counter[Global_Element_Index, Local_Node_Index_Within_Element]]
	Vector<Vector<std::pair<unsigned long, unsigned>>> Elements_containing_node;

	Vector<int long> Node_Number_To_Cell_Number;

	#ifdef OOMPH_HAS_MPI
	//Indices in a vector containing all variables for the cells in the mesh of where each cells data begins
	Vector<unsigned long> Starting_Index_For_Data_Of_Cell;
	unsigned long Total_cell_data;
	#endif


	//Data of cell model types in this mesh, model name, variable names, num variables
	Vector<std::tuple<std::string, std::vector<std::string>, unsigned>> Identified_Cell_Model_Types_And_Data;




public:

	// #ifdef OOMPH_HAS_MPI
	// //Delete all cells associated with obsolete nodes after a distribute
	// void DeleteCellsAfterDistribute()
	// {
	// 	oomph_info << "Deleting cells after distribute " << this->nnode() << " " << this->nelement() << " " << NumCells << std::endl;

	// 	Vector<CellModelBaseFullyPartitioned*> new_cell_pt;
	// 	std::vector<bool> cell_saved(NumCells, false);
	// 	//Loop over the cells
	// 	for(unsigned i=0; i<NumCells; i++)
	// 	{
	// 		//If the cell is one we should save, save it
	// 		if(Cells_pt[i]->base_node_pt()!=nullptr)
	// 		{
	// 			new_cell_pt.push_back(Cells_pt[i]);
	// 			cell_saved[i] = true;

	// 			Cells_pt[i] = nullptr;
	// 		}
	// 		else //Otherwise delete it
	// 		{
	// 			delete (Cells_pt[i]);
	// 			Cells_pt[i] = nullptr;
	// 		}
	// 	}

	// 	//Get the number of saved cells
	// 	const unsigned n_cell_post_cull = new_cell_pt.size();

	// 	oomph_info << "N cells post cull " << n_cell_post_cull << std::endl;

	// 	//Re-generate the lookup tables for nodes and elements
	// 	BuildNodeElementTables();

	// 	//Clear the vector of cells
	// 	Cells_pt.clear();
	// 	NumCells=0;

	// 	//loop over them and reassign them to the correct nodes
	// 	for(unsigned i=0; i<n_cell_post_cull; i++)
	// 	{
	// 		//If the cell is not saved then skip it
	// 		if(!cell_saved[i]){continue;}

	// 		//Get a pointer to the cell
	// 		CellModelBaseFullyPartitioned* cell_pt = new_cell_pt[i];

	// 		//Add it back to the vector of cells
	// 		Cells_pt.push_back(cell_pt);

	// 		//loop over the nodes and get the one which matches the pointer in the cell
	// 		for(unsigned l=0; l<this->nnode(); l++)
	// 		{
	// 			//Get a pointer to the test node
	// 			Node* nod_pt = this->node_pt(l);

	// 			//If it is the node attached to the cell
	// 			if(nod_pt == cell_pt->base_node_pt())
	// 			{
	// 				//Re attach the cell to the correct node
	// 				add_cell_to_node(l, NumCells);
	// 				//Stop checking nodes
	// 				break;
	// 			}

	// 			//If we've reached the end we have been unable to find the node
	// 			if(l==this->nnode())
	// 			{
	// 				throw OomphLibError("I can't locate the node attached to this cell for some reason",
	// 									OOMPH_CURRENT_FUNCTION,
	// 									OOMPH_EXCEPTION_LOCATION);
	// 			}
	// 		}

	// 		NumCells++;
	// 	}

	// 	oomph_info << "Num cells post rebuild " << NumCells << std::endl;

	// 	SetupDataIndices();
	// }
	// #endif


	//Generate paraview output files. We have an issue in that a mesh could contain a number of different cell models and those models may have different variables or different variable orderings
	// and interpolating those variables without thought will generate meaningless data. Instead, a paraview file is generated for each cell model in the mesh. The names of these output files is
	// then returned along with the cell model name it corresponds to so that the user can decide how to put them into the .pvd files in the driver code (although I don't know what they could do
	// except add the file-name to the end of the .pvd file)
	Vector<std::pair<std::string, std::string>> output_paraview_per_cell_model(const std::string& output_dir, const std::string& outfile_root_name, const unsigned& num_output, const unsigned& nplot) const
	{
		Vector<std::pair<std::string, std::string>> cell_model_vtk_name_pairs;
		//Loop over the cell models identified in the mesh and output a file for each, we skip Empty_Cell because it is empty
		for(std::tuple<std::string, std::vector<std::string>, unsigned> cell_model_data : Identified_Cell_Model_Types_And_Data)
		{
			//Inform the elements in the mesh what cell model we are saving to file, this determines nscalar_paraview and scalar_name_paraview
			//Loop over the elements
			const unsigned n_elements = this->nelement();
			for(unsigned e=0; e<n_elements; e++)
			{
				ConductingCellFunctionsBase* elem_pt = dynamic_cast<ConductingCellFunctionsBase*>(this->element_pt(e));
				elem_pt->set_paraview_output_type(std::get<0>(cell_model_data));
				elem_pt->set_variable_names_broadcast_from_cell_mesh(std::get<1>(cell_model_data));
				elem_pt->set_paraview_nscalar(std::get<2>(cell_model_data));
			}
			//Create an output file with the correct name and directory: output_dir/outfile_root_name_(cell_model)_num_output.vtk
			std::string out_file_name = outfile_root_name + "_" + std::get<0>(cell_model_data) + "_" + std::to_string(num_output) + ".vtu";
			std::string out_file_full_path = output_dir + "/" + out_file_name;
			std::ofstream out_file;
			out_file.open(out_file_full_path);

			//Perform the usual paraview output
			this->output_paraview(out_file, nplot);
			out_file.close();
			
			cell_model_vtk_name_pairs.push_back(std::make_pair(std::get<0>(cell_model_data), out_file_name));
		}

		//return pairs of (cell_model, output_file_name) so that pvd files can be suitably updated
		return cell_model_vtk_name_pairs;
	}
	




	//Save the cell data to file, blank line means no cell is associated with that node
	void save_cells_to_file(std::ofstream& out_file)
	{
		//Loop over the cells in the mesh

		//The cell number is the same as the node number.

		for(unsigned c=0; c<NumCells; c++)
		{
			CellModelBaseFullyPartitioned* cell_pt = Cells_pt[c];

			if(cell_pt != nullptr)
			{
				cell_pt->output_cell_variables(out_file);
			}
			out_file << std::endl;
		}
	}


	// //Load the cell data from file and restore the cells from it
	// void load_cells_from_file(std::ifstream& in_file)
	// {
	// 	oomph_info << "Loading cell data from file" << std::endl;
	// 	//Read in the file line by line
	// 	unsigned c=0;
	// 	std::string line;
	// 	while(std::getline(in_file, line))
	// 	{
	// 		//If the line is zero, skip it
	// 		if(line.size()==0)
	// 		{
	// 			oomph_info << "line " << c << " is zero, skipping." << std::endl;
	// 		}
	// 		else
	// 		{
	// 			// oomph_info << "Line is non-zero" << std::endl;
	// 			//read in the line to a big vector
	// 			Vector<double> BigVector;

	// 			std::istringstream iss(line);
	// 			std::string str;
	// 			while(iss >> str)
	// 			{
	// 				BigVector.push_back(std::atof(str.c_str()));
	// 			}
	// 			// oomph_info << BigVector.size() << " tokens in line" << std::endl;

	// 			//Get up to the last one and put into a vector of variables
	// 			Vector<double> vars_vect(BigVector.size()-1, 0.0);
	// 			for(unsigned i=0; i<vars_vect.size(); i++)
	// 			{
	// 				vars_vect[i] = BigVector[i];
	// 			}

	// 			//The last one is the cell type
	// 			const unsigned cell_type = (unsigned)BigVector[vars_vect.size()];

	// 			Cells_pt[c]->restore_state_from_vector(vars_vect, true);
	// 			Cells_pt[c]->set_cell_type(cell_type);

	// 			Cells_pt[c]->accept_copy_variables_as_IC_values();
	// 		}

	// 		c++;
	// 	}
	// }


	// //Store all the cell data from the mesh in a vector,
	// // boolean determines whether or not the membrane potential comes from the cells or the underlying nodes
	// void store_all_cell_data_from_mesh_in_vector(Vector<double> &Cell_Data, const bool &use_node_vm)
	// {
	// 	// oomph_info << "getting cell data"<< std::endl;
	// 	//Resize the storage vector
	// 	Cell_Data.resize(Total_cell_data, 0.0);

	// 	//Loop over the cells
	// 	for(unsigned c=0; c<NumCells; c++)
	// 	{
	// 		//Save the single cell data to a vector
	// 		Vector<double> single_cell_data;
	// 		Cells_pt[c]->save_state_to_vector(single_cell_data, use_node_vm);

	// 		//Loop over the data from the cell and put it into the big vector
	// 		for(unsigned i=Starting_Index_For_Data_Of_Cell[c]; i<((c<NumCells-1) ? Starting_Index_For_Data_Of_Cell[c+1] : Total_cell_data); i++)
	// 		{
	// 			Cell_Data[i] = single_cell_data[i-Starting_Index_For_Data_Of_Cell[c]];
	// 			// oomph_info << Cell_Data[i] << std::endl;
	// 		}
	// 	}
	// }

	// //Restore all the cell data inthe mesh from a big vector
	// void restore_all_cell_data_from_mesh_from_vector(Vector<double> &Cell_Data)
	// {
	// 	// oomph_info << "set cell data" << std::endl;
	// 	//Loop over the cells
	// 	for(unsigned c=0; c<NumCells; c++)
	// 	{
	// 		// std::cout << c << std::endl;
	// 		//Update the cell from the combined data vector
	// 		std::vector<double>::const_iterator first = Cell_Data.begin() + Starting_Index_For_Data_Of_Cell[c];
	// 		std::vector<double>::const_iterator last = Cell_Data.begin() + ((c<NumCells-1) ? Starting_Index_For_Data_Of_Cell[c+1] : Total_cell_data);
	// 		std::vector<double> projected_cell_data(first, last);
	// 		Cells_pt[c]->restore_state_from_vector(projected_cell_data, true);

	// 		// for(unsigned i=0; i<projected_cell_data.size(); i++)
	// 		// {
	// 		// 	oomph_info << projected_cell_data[i] << std::endl;
	// 		// }
	// 	}
	// }



	//Loop over the cells and output them to file
	// not sure why this exists as well as the above output
	void output_cells(const double &t, std::ostream &outfile)
	{
		for(unsigned c=0; c<NumCells; c++){
			// Cells_pt[c]->calculate_optional_output(t);

			Cells_pt[c]->output_global_coord(outfile);
			Cells_pt[c]->output_cell_variables(outfile);
			Cells_pt[c]->output_additional_data(outfile);

			outfile << std::endl;
		}
	}

	//Loop over all the elements in the mesh and handle any inverted elements,
	// this is required sometimes when building meshes from anatomical data
	// It then rebuilds the node element lookup tables since dealing with
	// inverted elements requires swapping nodes.
	void check_for_and_deal_with_inverted_elements()
	{
		//We check all of the elements
		for(unsigned e=0; e<this->nelement(); e++){
			dynamic_cast<CONDUCTANCE_MODEL*>(this->element_pt(e))->check_for_and_deal_with_inverted_jacobian();
		}

		//We have reordered some nodes so we need to regenerate the local and global node elements tables
		BuildNodeElementTables();
	}

	// //Loop over all the cells in the mesh and reset the running values to the current IC values
	// void reset_copy_variables_to_IC_values_for_all_cells_in_mesh()
	// {
	// 	//Loop over all of the cells in the mesh
	// 	for(unsigned c=0; c<NumCells; c++)
	// 	{
	// 		Cells_pt[c]->reset_copy_variables_to_IC_values();
	// 	}
	// }

	// //Loop over the cells in the mesh and set the current IC values to the current running values
	// void accept_copy_variables_as_IC_values_for_all_cells_in_mesh()
	// {
	// 	//Loop over all of the cells in the mesh
	// 	for(unsigned c=0; c<NumCells; c++)
	// 	{
	// 		Cells_pt[c]->accept_copy_variables_as_IC_values();
	// 	}
	// }

	//Loop over the cells in the mesh and take a time-step of length dt
	//Handles mpi/serial computation and communication of the solution back to the cells.
	//problem_pt is used to access the mpi communicator and to access the current time.
	// first bool determines if the underlying node vm is used as the initial condition
	// second bool determines if the underling node vm is updated post mpi solve.
	void Take_time_step_with_all_cells_in_mesh(const double& dt, Problem* problem_pt)
	{
		#ifndef OOMPH_FORCE_SERIAL_SINGLE_CELL_SOLVE
		#ifdef OOMPH_HAS_MPI
		// If we only have one processor or the problem is distributed then we always do the cell solves in serial
		if(problem_pt->communicator_pt()->nproc() == 1 || this->is_mesh_distributed())
		{
		#endif
		#endif
			//If there is only one processor or we are running in serial then do it serially

			oomph_info << "Performing a serial timestep for all cells in a mesh with time-step " << dt << std::endl;
			double t_start = TimingHelpers::timer();

			//Loop over all of the cells in the mesh
			for(unsigned c=0; c<NumCells; c++){
				// oomph_info << "Cell " << c << std::endl;
				//Take a timestep
				// oomph_info << "Solving cell " << c << std::endl;
				Cells_pt[c]->Take_Time_Step(dt);
				// if(update_underlying_node_value_post_solve)
				// {
				// 	Cells_pt[c]->update_underlying_node_membrane_potential();
				// }
			}
			double t_end = TimingHelpers::timer();
			oomph_info << "Done. It took me " << (t_end-t_start) << " seconds to complete." << std::endl;
		#ifndef OOMPH_FORCE_SERIAL_SINGLE_CELL_SOLVE
		#ifdef OOMPH_HAS_MPI
		}
		else
		{
		// #ifdef PARANOID
		// #ifdef CHECK_SERIAL_AND_PARALLEL_CELL_SOLVE_DIFFERENCE
		// 	//Solve in serial first to check against the mpi version
		// 	Vector<double> Serial_Cell_Data(Total_cell_data, 0.0);

		// 	Vector<double> restore_single_cell_data;
		// 	//Loop over all of the cells in the mesh
		// 	for(unsigned c=0; c<NumCells; c++)
		// 	{
		// 		const double last_dt = Cells_pt[c]->get_last_used_dt();
		// 		Cells_pt[c]->save_state_to_vector(restore_single_cell_data);
		// 		//Take a timestep
		// 		Cells_pt[c]->Take_Time_Step(dt);

		// 		Vector<double> single_cell_data;
		// 		Cells_pt[c]->save_state_to_vector(single_cell_data);
		// 		for(unsigned i=Starting_Index_For_Data_Of_Cell[c]; i<((c<NumCells-1) ? Starting_Index_For_Data_Of_Cell[c+1] : Total_cell_data); i++)
		// 		{
		// 			Serial_Cell_Data[i] = single_cell_data[i-Starting_Index_For_Data_Of_Cell[c]];
		// 		}

		// 		Cells_pt[c]->restore_state_from_vector(restore_single_cell_data);
		// 		Cells_pt[c]->set_last_used_dt(last_dt);
		// 	}
		// #endif
		// #endif


			//If we are compiled with parallel and we have more than one processor then run in parallel
			oomph_info << "Performing a parallel timestep for all cells in a mesh with time-step " << dt << std::endl;
			const double t_start = TimingHelpers::timer();

			//Set up the local vector of new cell variables
			Vector<double> Local_Cell_Data(Total_cell_data, 0.0);
			//Set up the vector of combined data across all processors
			Vector<double> Combined_Cell_Data(Total_cell_data, 0.0);

		// #ifdef PARANOID
		// #ifdef CHECK_SERIAL_AND_PARALLEL_CELL_SOLVE_DIFFERENCE
		// 	Vector<unsigned> Local_cell_is_computed(NumCells, 0);
		// 	Vector<unsigned> Combined_cell_is_computed(NumCells, 0);

		// 	Vector<unsigned> Local_dof_is_computed(Total_cell_data, 0);
		// 	Vector<unsigned> Combined_dof_is_computed(Total_cell_data, 0);

		// #endif
		// #endif

			//Loop over the cells
			for(unsigned c=0; c<NumCells; c++)
			{
				//If it is one we are to compute then compute it
				if(c%problem_pt->communicator_pt()->nproc() != problem_pt->communicator_pt()->my_rank()) continue;
			// #ifdef PARANOID
			// #ifdef CHECK_SERIAL_AND_PARALLEL_CELL_SOLVE_DIFFERENCE
			// 	Local_cell_is_computed[c]++;
			// #endif
			// #endif
				Cells_pt[c]->Take_Time_Step(dt);
				//Save the solution to the local vector
				// Vector<double> single_cell_data;
				// Cells_pt[c]->save_state_to_vector(single_cell_data);
				// for(unsigned i=Starting_Index_For_Data_Of_Cell[c]; i<((c<NumCells-1) ? Starting_Index_For_Data_Of_Cell[c+1] : Total_cell_data); i++)
				// {
				// 	Local_Cell_Data[i] = single_cell_data[i-Starting_Index_For_Data_Of_Cell[c]];
				// // #ifdef PARANOID
				// // #ifdef CHECK_SERIAL_AND_PARALLEL_CELL_SOLVE_DIFFERENCE
				// // 	Local_dof_is_computed[i]++;
				// // #endif
				// // #endif
				// }

				// for(unsigned i=Starting_Index_For_Data_Of_Cell[c]; i<((c<NumCells-1) ? Starting_Index_For_Data_Of_Cell[c+1] : Total_cell_data); i++)
				// {
				// 	Local_Cell_Data[i] = single_cell_data[i-Starting_Index_For_Data_Of_Cell[c]];
				// }

				Cells_pt[c]->record_data_pre_mpi_reduce(Local_Cell_Data, Starting_Index_For_Data_Of_Cell[c]);
			}

			const double t_end_solve = TimingHelpers::timer();
			oomph_info << "Actual solve took " << (t_end_solve-t_start) << " seconds." << std::endl;

			//Mpi All reduce
			MPI_Allreduce(Local_Cell_Data.data(), Combined_Cell_Data.data(), Total_cell_data, MPI_DOUBLE, MPI_SUM, problem_pt->communicator_pt()->mpi_comm());


		// #ifdef PARANOID
		// #ifdef CHECK_SERIAL_AND_PARALLEL_CELL_SOLVE_DIFFERENCE
		// 	MPI_Allreduce(Local_cell_is_computed.data(), Combined_cell_is_computed.data(), NumCells, MPI_UNSIGNED, MPI_SUM, problem_pt->communicator_pt()->mpi_comm());

		// 	MPI_Allreduce(Local_dof_is_computed.data(), Combined_dof_is_computed.data(), Total_cell_data, MPI_UNSIGNED, MPI_SUM, problem_pt->communicator_pt()->mpi_comm());

		// 	double diff = 0.0;
		// 	//Compare the serial solution to the mpi solution
		// 	for(unsigned i=0; i<Total_cell_data; i++)
		// 	{
		// 		diff = std::max(diff, std::fabs(Serial_Cell_Data[i] - Combined_Cell_Data[i])/std::max(Serial_Cell_Data[i], Combined_Cell_Data[i]));
		// 	}
		// 	oomph_info << "Difference in serial and mpi solution: " << diff << std::endl;
		// 	if(diff>1e-12)
		// 	{
		// 		oomph_info << "Serial solution\tMPI solution\tDiff\tN times var computed MPI" << std::endl;
		// 		for(unsigned i=0; i<Total_cell_data; i++)
		// 		{
		// 			if(std::fabs(Serial_Cell_Data[i] - Combined_Cell_Data[i])/std::max(Serial_Cell_Data[i], Combined_Cell_Data[i])>1e-9)
		// 			{
		// 				oomph_info << Serial_Cell_Data[i] << "\t" << Combined_Cell_Data[i] << "\t" << std::fabs(Serial_Cell_Data[i] - Combined_Cell_Data[i])/std::max(Serial_Cell_Data[i], Combined_Cell_Data[i]) << "\t" << Combined_dof_is_computed[i] << std::endl;
		// 			}
		// 		}

		// 		for(unsigned c=0; c<NumCells; c++)
		// 		{
		// 			oomph_info << Combined_cell_is_computed[c] << std::endl;
		// 		}	

		// 		throw OomphLibError("MPI and serial do not match",
		// 						OOMPH_CURRENT_FUNCTION,
		// 						OOMPH_EXCEPTION_LOCATION);
		// 	}
		// #endif
		// #endif


			const double t_end_reduce = TimingHelpers::timer();
			oomph_info << "All reduce took " << (t_end_reduce-t_end_solve) << " seconds." << std::endl;

			//Loop over the cells
			for(unsigned c=0; c<NumCells; c++)
			{
			// #ifdef PARANOID
			// #ifdef CHECK_SERIAL_AND_PARALLEL_CELL_SOLVE_DIFFERENCE
			// 	if(Combined_cell_is_computed[c]!=1)
			// 	{
			// 		std::ostringstream error_message;
			// 		error_message << "Cell " << std::to_string(c) << " is not computed" << std::endl;
			// 		throw OomphLibError(error_message.str(),
			// 							OOMPH_CURRENT_FUNCTION,
			// 							OOMPH_EXCEPTION_LOCATION);
			// 	}
			// #endif
			// #endif
				//Update the cell from the combined data vector
				// std::vector<double>::const_iterator first = Combined_Cell_Data.begin() + Starting_Index_For_Data_Of_Cell[c];
				// std::vector<double>::const_iterator last = Combined_Cell_Data.begin() + ((c<NumCells-1) ? Starting_Index_For_Data_Of_Cell[c+1] : Total_cell_data);
				// std::vector<double> projected_cell_data(first, last);
				// Cells_pt[c]->restore_state_from_vector(projected_cell_data, update_underlying_node_value_post_solve);
				Cells_pt[c]->update_data_post_mpi_reduce(Combined_Cell_Data, Starting_Index_For_Data_Of_Cell[c]);
			}

			const double t_end_communicate = TimingHelpers::timer();
			oomph_info << "Communicate took " << (t_end_communicate-t_end_reduce) << " seconds." << std::endl;

			const double t_end = TimingHelpers::timer();
			oomph_info << "Done. It took me " << (t_end-t_start) << " seconds to complete:" << std::endl;
			oomph_info << "\tSolve " << (t_end_solve-t_start)*100.0/(t_end-t_start) << "%" << std::endl;
			oomph_info << "\tReduce " << (t_end_reduce-t_end_solve)*100.0/(t_end-t_start) << "%" << std::endl;
			oomph_info << "\tCommunicate " << (t_end_communicate-t_end_reduce)*100.0/(t_end-t_start) << "%" << std::endl;
		}
		#endif
		#endif
	}


	//Handle distribution of the problem. Override of the default problem version of the function but handles
	// deleting obselete cells from each processor which occurs when the nodes those cells are associated
	// with are deleted
	void distribute(OomphCommunicator* comm_pt,
                       const Vector<unsigned>& element_domain,
                       Vector<GeneralisedElement*>& deleted_element_pt,
                       DocInfo& doc_info,
                       const bool& report_stats,
                       const bool& overrule_keep_as_halo_element_status) override
	 {

	  // Store communicator
	  Comm_pt=comm_pt;

	  // Storage for number of processors and current processor
	  int n_proc=comm_pt->nproc();
	  int my_rank=comm_pt->my_rank();

	 // Storage for number of elements and number of nodes on this mesh
	 unsigned nelem=this->nelement();
	 unsigned nnod=this->nnode();

	 std::ostringstream filename;
	 
	 // Doc the partitioning (only on processor 0)
	 //-------------------------------------------
	 if (doc_info.is_doc_enabled())
	  {
	   if (my_rank==0)
	    {
	     // Open files for doc of element partitioning
	     Vector<std::ofstream*> domain_file(n_proc);
	     for (int d=0;d<n_proc;d++)
	      {
	       // Note: doc_info.number() was set in Problem::distribute(...) to
	       // reflect the submesh number
	       //Clear the filename
	       filename.str("");
	       filename << doc_info.directory() << "/domain"
	                << d << "-" << doc_info.number() << ".dat";
	       domain_file[d]=new std::ofstream(filename.str().c_str());
	      }

	     // Doc
	     for (unsigned e=0;e<nelem;e++)
	      {
	       //If we can't cast to a finite element, we can't output because
	       //there is no output function
	       FiniteElement* f_el_pt =
	        dynamic_cast<FiniteElement*>(this->element_pt(e));
	       if(f_el_pt!=0)
	        {
	         f_el_pt->output(*domain_file[element_domain[e]],5);
	        }
	      }

	     for (int d=0;d<n_proc;d++)
	      {
	       domain_file[d]->close();
	       delete domain_file[d];
	       domain_file[d]=0;
	      }
	    }
	  }

	 // Loop over all elements, associate all
	 //--------------------------------------
	 // nodes with the highest-numbered processor and record all
	 //---------------------------------------------------------
	 // processors the node is associated with
	 //---------------------------------------

	 // Storage for processors in charge and processors associated with data
	 std::map<Data*,std::set<unsigned> > processors_associated_with_data;
	 std::map<Data*,unsigned> processor_in_charge;

	 // For all nodes set the processor in charge to zero
	 for (unsigned j=0;j<nnod;j++)
	  {
	   Node* nod_pt=this->node_pt(j);
	   processor_in_charge[nod_pt]=0;
	  }

	 // Loop over elements
	 for (unsigned e=0;e<nelem;e++)
	  {
	   // Get an element and its domain
	   FiniteElement* el_pt = dynamic_cast<FiniteElement*>(this->element_pt(e));
	   //Element will only have nodes if it is a finite element
	   if(el_pt!=0)
	    {
	     unsigned el_domain=element_domain[e];

	     // Associate nodes with highest numbered processor
	     unsigned nnod=el_pt->nnode();
	     for (unsigned j=0;j<nnod;j++)
	      {
	       Node* nod_pt=el_pt->node_pt(j);

	       // processor in charge was initialised to 0 above
	       if (el_domain>processor_in_charge[nod_pt])
	        {
	         processor_in_charge[nod_pt]=el_domain;
	        }
	       processors_associated_with_data[nod_pt].insert(el_domain);
	      }
	    }
	  }

	 // Doc the partitioning (only on processor 0)
	 //-------------------------------------------
	 if (doc_info.is_doc_enabled())
	  {
	   if (my_rank==0)
	    {
	     // Open files for doc of node partitioning
	     Vector<std::ofstream*> node_file(n_proc);
	     for (int d=0;d<n_proc;d++)
	      {
	       // Note: doc_info.number() was set in Problem::distribute(...) to
	       // reflect the submesh number...
	       //Clear the filename
	       filename.str("");
	       filename << doc_info.directory() << "/node"
	                << d << "-" << doc_info.number() << ".dat";
	       node_file[d]=new std::ofstream(filename.str().c_str());
	      }

	     // Doc
	     for (unsigned j=0;j<nnod;j++)
	      {
	       Node* nod_pt=this->node_pt(j);
	       const unsigned n_dim = nod_pt->ndim();
	       for(unsigned i=0;i<n_dim;i++)
	        {
	         *node_file[processor_in_charge[nod_pt]] << nod_pt->x(i) << " ";
	        }
	       *node_file[processor_in_charge[nod_pt]] << "\n";
	      }
	     for (int d=0;d<n_proc;d++)
	      {
	       node_file[d]->close();
	       delete node_file[d];
	       node_file[d]=0;
	      }
	    }
	  }

	 // Declare all nodes as obsolete. We'll
	 // change this setting for all nodes that must be retained
	 // further down
	 for (unsigned j=0;j<nnod;j++)
	  {
	   this->node_pt(j)->set_obsolete();
	  }


	 // Backup old mesh data and flush mesh
	 //-------------------------------------

	 // Backup pointers to elements in this mesh
	 Vector<GeneralisedElement*> backed_up_el_pt(nelem);
	 for (unsigned e=0;e<nelem;e++)
	  {
	   backed_up_el_pt[e]=this->element_pt(e);
	  }
	 
	 // Info. used to re-generate the boundary element scheme after the
	 // deletion of elements not belonging to the current processor)
	 
	 // Get the number of boundary elements before the deletion of non
	 // retained elements
	 const unsigned tmp_nboundary = this->nboundary();
	 Vector<unsigned> ntmp_boundary_elements(tmp_nboundary);
	 // In case that there are regions, also get the number of boundary
	 // elements in each region
	 Vector<Vector<unsigned> > ntmp_boundary_elements_in_region(tmp_nboundary);
	 // Also get the finite element version of the elements and back them
	 // up
	 Vector<FiniteElement*> backed_up_f_el_pt(nelem);
	 
	 // Only do this if the mesh is a TriangleMeshBase
	 TriangleMeshBase* triangle_mesh_pt = dynamic_cast<TriangleMeshBase*>(this);
	 bool is_a_triangle_mesh_base_mesh = false;
	 if (triangle_mesh_pt!=0)
	  {
	   // Set the flag to indicate we are working with a TriangleMeshBase
	   // mesh
	   is_a_triangle_mesh_base_mesh = true;
	   
	   // Are there regions?
	   const unsigned n_regions = triangle_mesh_pt->nregion();
	   
	   // Loop over the boundaries
	   for (unsigned ib = 0; ib < tmp_nboundary; ib++)
	    {
	     // Get the number of boundary elements
	     ntmp_boundary_elements[ib] = this->nboundary_element(ib);
	     
	     // Resize the container
	     ntmp_boundary_elements_in_region[ib].resize(n_regions);
	     
	     // Loop over the regions
	     for (unsigned rr = 0 ; rr < n_regions; rr++)
	      {
	       // Get the region id
	       const unsigned region_id = 
	        static_cast<unsigned>(triangle_mesh_pt->region_attribute(rr));
	       
	       // Store the number of element in the region (notice we are
	       // using the region index not the region id to refer to the
	       // region)
	       ntmp_boundary_elements_in_region[ib][rr] = 
	        triangle_mesh_pt->nboundary_element_in_region(ib, region_id);
	       
	      } // for (rr < n_regions)
	     
	    } // for (ib < tmp_nboundary)
	   
	   for (unsigned e=0;e<nelem;e++)
	    {
	     // Get the finite element version of the elements and back them
	     // up
	     backed_up_f_el_pt[e] = this->finite_element_pt(e);
	    }
	   
	  } // if (triangle_mesh_pt!=0)
	 
	 // Flush the mesh storage
	 this->flush_element_storage();
	 
	 // Delete any storage of external elements and nodes
	 this->delete_all_external_storage();
	 
	 // Boolean to indicate which element is to be retained
	 std::vector<bool> element_retained(nelem,false);
	 
	 // Storage for element numbers of root halo elements that will be
	 // retained on current processor: root_halo_element[p][j]
	 // stores the element number (in the order in which the elements are stored
	 // in backed_up_el_pt) of the j-th root halo element with processor
	 // p.
	 Vector<Vector<int> > root_halo_element(n_proc);
	 
	 // Dummy entry to make sure we always have something to send
	 for (int p=0;p<n_proc;p++)
	  {
	   root_halo_element[p].push_back(-1);
	  }

	 // Determine which elements are going to end up on which processor
	 //----------------------------------------------------------------
	 unsigned number_of_retained_elements=0;
	 
	 // Loop over all backed up elements
	 nelem=backed_up_el_pt.size();
	 for (unsigned e=0;e<nelem;e++)
	  {
	   // Get element and its domain
	   GeneralisedElement* el_pt=backed_up_el_pt[e];
	   unsigned el_domain=element_domain[e];

	   // If element is located on current processor add it back to the mesh
	   if (el_domain==unsigned(my_rank))
	    {
	     // Add element to current processor
	     element_retained[e]=true;
	     number_of_retained_elements++;
	    }
	   // Otherwise we may still need it if it's a halo element:
	   else
	    {
	     // If this current mesh has been told to keep all elements as halos,
	     // OR the element itself knows that it must be kept then
	     // keep it
	     if ((this->Keep_all_elements_as_halos) ||
	         (el_pt->must_be_kept_as_halo()))
	      {
	       if (!overrule_keep_as_halo_element_status)
	        {
	         // Add as root halo element whose non-halo counterpart is
	         // located on processor el_domain
	         if (!element_retained[e])
	          {
	           root_halo_element[el_domain].push_back(e);
	           element_retained[e]=true;
	           number_of_retained_elements++;
	          }
	        }
	      }
	     //Otherwise: Is one of the nodes associated with the current processor?
	     else
	      {
	       //Can only have nodes if this is a finite element
	       FiniteElement* finite_el_pt = dynamic_cast<FiniteElement*>(el_pt);
	       if(finite_el_pt!=0)
	        {
	         unsigned n_node = finite_el_pt->nnode();
	         for (unsigned n=0;n<n_node;n++)
	          {
	           Node* nod_pt=finite_el_pt->node_pt(n);

	           // Keep element? (use stl find?)
	           unsigned keep_it=false;
	           for (std::set<unsigned>::iterator
	                 it=processors_associated_with_data[nod_pt].begin();
	                it!=processors_associated_with_data[nod_pt].end();
	                it++)
	            {
	             if (*it==unsigned(my_rank))
	              {
	               keep_it=true;
	               //Break out of the loop over processors
	               break;
	              }
	            }

	           // Add a root halo element either if keep_it=true
	           if (keep_it)
	            {
	             // Add as root halo element whose non-halo counterpart is
	             // located on processor el_domain
	             if (!element_retained[e])
	              {
	               root_halo_element[el_domain].push_back(e);
	               element_retained[e]=true;
	               number_of_retained_elements++;
	              }
	             //Now break out of loop over nodes
	             break;
	            }
	          }
	        }
	      } //End of testing for halo by virtue of shared nodes
	    }//End of halo element conditions
	  } //end of loop over elements
	 
	 // First check that the number of elements is greater than zero, when
	 // working with submeshes it may be possible that some of them have
	 // no elements (face element meshes) since those may have been
	 // deleted in "Problem::actions_before_distribute()"
	 if (nelem > 0)
	  {
	   // Check that we are working with a TriangleMeshBase mesh, if
	   // that is the case then we need to create shared boundaries
	   if (is_a_triangle_mesh_base_mesh)
	    {
	     // Creation of shared boundaries
	     // ------------------------------
	     // All processors share the same boundary id for the created
	     // shared boundary. We need all the elements on all processors,
	     // that is why this step is performed before the deletion of the
	     // elements not associated to the current processor. 
	     // N.B.: This applies only to unstructured meshes
	     this->create_shared_boundaries(comm_pt, element_domain, 
	                                    backed_up_el_pt,
	                                    backed_up_f_el_pt,
	                                    processors_associated_with_data, 
	                                    overrule_keep_as_halo_element_status);
	    } // if (is_a_triangle_mesh_base_mesh)
	  } // if (nelem > 0)
	 
	 // NOTE: No need to add additional layer of halo elements.
	 //       Procedure for removing "overlooked" halo nodes in 
	 //       deals classify_halo_and_haloed_nodes() deals 
	 //       with the problem addressed here. [code that dealt with this
	 //       problem at distribution stage has been removed]
	 
	 // Store the finite element pointer version of the elements that are
	 // about to be deleted, used to reset the boundary elements info
	 Vector<FiniteElement*> deleted_f_element_pt;
	 
	 // Copy the elements associated with the actual
	 // current processor into its own permanent storage.
	 // Do it in the order in which the elements appeared originally
	 nelem=backed_up_el_pt.size();
	 for (unsigned e=0;e<nelem;e++)
	  {
	   GeneralisedElement* el_pt=backed_up_el_pt[e];
	   if (element_retained[e])
	    {
	     this->add_element_pt(el_pt);
	    }
	   else
	    {
	     // Flush the object attached to the tree for this element?
	     RefineableElement* ref_el_pt=dynamic_cast<RefineableElement*>(el_pt);
	     if (ref_el_pt!=0)
	      {
	       ref_el_pt->tree_pt()->flush_object();
	      }
	     
	     
	     // Store pointer to the element that's about to be deleted.
	     
	     // Only for structured meshes since this "deleted_element_pt"
	     // vector is used in the "problem" class to set null pointer to
	     // the deleted elements in the Base_mesh_element_pt structure
	     if (!is_a_triangle_mesh_base_mesh)
	      {
	       deleted_element_pt.push_back(el_pt);
	      } // if (!is_a_triangle_mesh_base_mesh)
	     
	     if (is_a_triangle_mesh_base_mesh)
	      {
	       // Store pointer to the finite element that's about to be deleted
	       deleted_f_element_pt.push_back(backed_up_f_el_pt[e]);
	      }
	     
	     // Delete the element
	     delete el_pt;
	    }
	  }

	 // Copy the root halo elements associated with the actual
	 // current processor into its own permanent storage; the order
	 // here is somewhat random but we compensate for that by
	 // ensuring that the corresponding haloed elements are
	 // added in the same order below
	#ifdef PARANOID
	 std::map<unsigned,bool> done;
	#endif
	 for (int d=0;d<n_proc;d++)
	  {
	   nelem=root_halo_element[d].size();
	   for (unsigned e=0;e<nelem;e++)
	    {
	     int number=root_halo_element[d][e];
	     if (number>=0)
	      {
	#ifdef PARANOID
	       if (done[number])
	        {
	         std::ostringstream error_message;
	         error_message
	          << "Have already added element " << number
	          << " as root halo element\n"
	          << std::endl;
	         throw OomphLibError(error_message.str(),
	                             OOMPH_CURRENT_FUNCTION,
	                             OOMPH_EXCEPTION_LOCATION);
	        }
	       done[number]=true;
	#endif
	       this->add_root_halo_element_pt(d,backed_up_el_pt[number]);
	      }
	    }
	  }


	 // Now get root haloed elements: root_haloed_element[p][j] stores
	 // the element number (in the order in which the elements are stored
	 // in backedup_el_pt) of the j-th rooted halo element with processor
	 // p. On proc my_proc this the same as root_haloed_element[my_proc][j]
	 // on processor p, so get the information by gatherv operations.
	 Vector<Vector<unsigned> > root_haloed_element(n_proc);

	 // Find out number of root halo elements with each other proc
	 Vector<int> nhalo(n_proc,0);
	 Vector<int> nhaloed(n_proc,0);
	 for (int p=0;p<n_proc;p++)
	  {
	   nhalo[p]=root_halo_element[p].size();
	  }

	 // Each processor sends number of halo elements it has with processor
	 // p to processor p where this information is stored in nhaloed[...]
	 for (int p=0;p<n_proc;p++)
	  {
	   // Gather the p-th entries in nhalo from every processor on
	   // processor p and store them in nhaloed consecutively
	   // starting at beginning
	   MPI_Gather(&nhalo[p], 1, MPI_INT,
	              &nhaloed[0], 1, MPI_INT,
	              p,comm_pt->mpi_comm());
	  }

	 // In the big sequence of concatenated root halo elements (enumerated
	 // individually on the various processors) where do the root halo
	 // elements from a given processor start? Also figure out how many
	 // root haloed elements there are in total by summing up their numbers
	 Vector<int> start_index(n_proc,0);
	 unsigned total_number_of_root_haloed_elements=0;
	 for (int i_proc=0; i_proc<n_proc; i_proc++)
	  {
	   total_number_of_root_haloed_elements+=nhaloed[i_proc];
	   if (i_proc!=0)
	    {
	     start_index[i_proc]=total_number_of_root_haloed_elements-
	      nhaloed[i_proc];
	    }
	   else
	    {
	     start_index[0]=0;
	    }
	  }

	 // Storage for all root haloed elements from the various processors, one
	 // after the other, with some padding from negative entries to avoid
	 // zero length vectors
	 Vector<int> all_root_haloed_element(total_number_of_root_haloed_elements,
	                                     0);

	 // Now send the ids of the relevant elements via gatherv
	 for (int p=0;p<n_proc;p++)
	  {
	   // Gather the p-th entries in nhalo from every processor on
	   // processor p and store them in nhaloed consecutively
	   // starting at beginning
	   MPI_Gatherv(&root_halo_element[p][0], // pointer to first entry in vector
	                                         // to be gathered on processor p
	               nhalo[p], // Number of entries to be sent
	               MPI_INT,
	               &all_root_haloed_element[0], // Target -- this will store
	                                            // the element numbers of
	                                            // all root haloed elements
	                                            // received from other processors
	                                            // in order
	               &nhaloed[0], // Pointer to the vector containing the lengths
	                            // of the vectors received from elsewhere
	               &start_index[0], // "offset" for storage of vector received
	                                // from various processors in the global
	                                // concatenated vector
	               MPI_INT,
	               p, // processor that gathers the information
	               comm_pt->mpi_comm());
	  }


	 // Determine root haloed elements
	 //-------------------------------

	 // Loop over all other processors
	 unsigned count=0;
	 for (int d=0;d<n_proc;d++)
	  {

	#ifdef PARANOID
	 std::map<unsigned,bool> done;
	#endif

	   // Loop over root haloed elements with specified processor
	   unsigned n=nhaloed[d];
	   for (unsigned e=0;e<n;e++)
	    {

	     int number=all_root_haloed_element[count];
	     count++;

	     // Ignore padded -1s that were only inserted to avoid
	     // zero sized vectors
	     if (number>=0)
	      {
	       // Get pointer to element
	       GeneralisedElement* el_pt=backed_up_el_pt[number];

	       // Halo elements can't be haloed themselves
	       if (!el_pt->is_halo())
	        {

	#ifdef PARANOID
	         if (done[number])
	          {
	           std::ostringstream error_message;
	           error_message
	            << "Have already added element " << number
	            << " as root haloed element\n"
	            << std::endl;
	           throw OomphLibError(error_message.str(),
	                               OOMPH_CURRENT_FUNCTION,
	                               OOMPH_EXCEPTION_LOCATION);
	          }
	         done[number]=true;
	#endif

	         // Current element is haloed by other processor
	         this->add_root_haloed_element_pt(d,el_pt);
	        }
	      }
	    }
	  }


	 // Doc stats
	 if (report_stats)
	  {
	   oomph_info << "Processor " << my_rank
	              << " holds " << this->nelement()
	              << " elements of which " << this->nroot_halo_element()
	              << " are root halo elements \n while "
	              << this->nroot_haloed_element()
	              << " are root haloed elements" << std::endl;
	  }


	 // Loop over all retained elements and mark their nodes
	 //-----------------------------------------------------
	 // as to be retained too (some double counting going on here)
	 //-----------------------------------------------------------
	 nelem=this->nelement();
	 for (unsigned e=0;e<nelem;e++)
	  {
	   FiniteElement* f_el_pt= dynamic_cast<FiniteElement*>(this->element_pt(e));

	   //If we have a finite element
	   if(f_el_pt!=0)
	    {
	     // Loop over nodes
	     unsigned nnod=f_el_pt->nnode();
	     for (unsigned j=0;j<nnod;j++)
	      {
	       Node* nod_pt=f_el_pt->node_pt(j);
	       nod_pt->set_non_obsolete();
	      }
	    }
	  }


	 //BEFORE we kill the dead nodes we need to remember which cells have to be saved (all those associated with a live node)
	 unsigned n_save_cell = 0;
	 std::vector<bool> cell_is_saved(NumCells, false);
	 //Loop over the nodes and delete the cells associated with those which are obsolete
	 for(unsigned i=0; i<this->nnode(); i++)
	 {
	 	if(!(this->node_pt(i)->is_obsolete()))
	 	{
	 		cell_is_saved[i] = true;
	 		n_save_cell++;
	 	}
	 }
	 
	 
	 // Now remove the pruned nodes
	 this->prune_dead_nodes();
	 
	 
	#ifdef OOMPH_HAS_TRIANGLE_LIB
	 if (is_a_triangle_mesh_base_mesh)
	  {
	   triangle_mesh_pt->
	    reset_boundary_element_info(ntmp_boundary_elements,
	                                ntmp_boundary_elements_in_region,
	                                deleted_f_element_pt);
	  } // if (tri_mesh_pt!=0)
	 else
	  {
	#endif // #ifdef OOMPH_HAS_TRIANGLE_LIB   
	   
	   // Temporarly set the mesh as distributed
	   this->setup_boundary_element_info();
	   
	#ifdef OOMPH_HAS_TRIANGLE_LIB
	  }
	#endif
	 
	 // Re-setup tree forest. (Call this every time even if
	 // a (distributed) mesh has no elements on this processor.
	 // We still need to participate in communication.)
	 TreeBasedRefineableMeshBase* ref_mesh_pt=
	  dynamic_cast<TreeBasedRefineableMeshBase*>(this);
	 if (ref_mesh_pt!=0)
	  {
	   ref_mesh_pt->setup_tree_forest();
	  }

	 // Classify nodes
	 classify_halo_and_haloed_nodes(doc_info,report_stats);

	  // Doc?
	 //-----
	 if (doc_info.is_doc_enabled())
	  {
	   doc_mesh_distribution(doc_info);
	  }


	 oomph_info << "Deleting cells after distribute " << this->nnode() << " " << this->nelement() << " " << NumCells << std::endl;

	 Vector<CellModelBaseFullyPartitioned*> new_cell_pt;
	 //Loop over the cells
	 for(unsigned i=0; i<NumCells; i++)
	 {
 	  //If the cell is one we should save, save it
 	  if(cell_is_saved[i])
	  {
		new_cell_pt.push_back(Cells_pt[i]);

		Cells_pt[i] = nullptr;
	  } 
	  else //Otherwise delete it
	  {
		delete (Cells_pt[i]);
		Cells_pt[i] = nullptr;
	  } 
	 }

	 oomph_info << "N save cell " << n_save_cell << std::endl;

	 //Re-generate the lookup tables for nodes and elements
	 BuildNodeElementTables();

	 //Clear the vector of cells
	 Cells_pt.clear();
	 NumCells=0;

	 //loop over them and reassign them to the correct nodes
	 for(unsigned i=0; i<n_save_cell; i++)
	 {

		//Get a pointer to the cell
		CellModelBaseFullyPartitioned* cell_pt = new_cell_pt[i];

		//Add it back to the vector of cells
		Cells_pt.push_back(cell_pt);

		//loop over the nodes and get the one which matches the pointer in the cell
		for(unsigned l=0; l<this->nnode(); l++)
		{
			//Get a pointer to the test node
			Node* nod_pt = this->node_pt(l);

			//If it is the node attached to the cell
			if(nod_pt == cell_pt->base_node_pt())
			{
				//Re attach the cell to the correct node
				add_cell_to_node(l, NumCells);
				//Stop checking nodes
				break;
			}

			//If we've reached the end we have been unable to find the node
			if(l==this->nnode())
			{
				throw OomphLibError("I can't locate the node attached to this cell for some reason",
									OOMPH_CURRENT_FUNCTION,
									OOMPH_EXCEPTION_LOCATION);
			}
		}

		NumCells++;
	 }
	 oomph_info << "Num nodes left " << this->nnode() << std::endl;
	 oomph_info << "Num non-halo nodes " << this->nnode() - this->nhalo_node() << std::endl;
	 oomph_info << "Num cells post rebuild " << NumCells << std::endl;

	 SetupDataIndices();
	}



};


}//End namespace

#endif