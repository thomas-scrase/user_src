//LIC// ====================================================================
//LIC// 
//LIC//====================================================================


//Header file for CellInterface elements
#ifndef OOMPH_FULLY_SEGREGATED_CELL_SOLVER_ELEMENTS_HEADER
#define OOMPH_FULLY_SEGREGATED_CELL_SOLVER_ELEMENTS_HEADER

// #define OOMPH_FORCE_SERIAL_SINGLE_CELL_SOLVE

// Config header generated by autoconfig
#ifdef HAVE_CONFIG_H
	#include <oomph-lib-config.h>
#endif

//For the custom integration schemes
#include "../toms_utilities/toms_integral.h"


//OOMPH-LIB headers
#include "../generic/nodes.h"
#include "../generic/oomph_utilities.h"
#include "../generic/Qelements.h"
#include "../generic/Telements.h"
#include "../generic/error_estimator.h"
#include "../generic/problem.h"
#include "../generic/assembly_handler.h"


#include "../cell_models/cell_model_base.h"

#include "../cell_membrane_potential/cell_membrane_potential_elements.h"

#include "empty_place_holder_cell.h"

#include <boost/tokenizer.hpp>

namespace oomph
{

//A wrapper class for the membrane potential equations defined in CONDUCTANCE_MODEL. Essentially provides suitably overriden version of the
// functions which get data from the cell model as well as lookup schemes for the cells associated with the nodes of the element.
template <class CONDUCTANCE_MODEL>
class FullySegregatedCellEquations : public virtual FiniteElement,
									public virtual CONDUCTANCE_MODEL,
									public virtual ConductingCellFunctionsBase
{
public:

	////General class functions

	//Constructor
	FullySegregatedCellEquations() : CONDUCTANCE_MODEL()
	{
		//Provide storage for the pointer to each cell associated with each node in the element
		Cell_associated_with_each_node_pt.resize(this->nnode(), nullptr);
	}

	//Destructor
	~FullySegregatedCellEquations()
	{

	}


	//Sometimes when generating a mesh from a list of elements and nodes the elements are inverted
	//To solve this we simply swap the first and second nodes, however this requires also
	//swapping the cell associated with the nodes as well so we provide a function to do it all for us
	void check_for_and_deal_with_inverted_jacobian()
	{
		//Check if it is negative
		bool jacobian_passed_test;
		this->check_J_eulerian_at_knots(jacobian_passed_test);
		//If it is, swap the first two node pointers
		if(!jacobian_passed_test){
			//Save a pointer to the first node
			Node* nod_pt = this->node_pt(0);


			//Swap the first and second nodes
			this->node_pt(0) = this->node_pt(1);
			this->node_pt(1) = nod_pt;


			//Now we need to swap the pointers to the cells for the nodes,
			// we do this and reapply the initial conditions - essentially we are
			// calling the build cell function again but without actually re-building
			// the cell

			//Swap the cells associated with the nodes since we have swapped the nodes
			CellModelBaseFullySegregated* cell_pt = Cell_associated_with_each_node_pt[0];
			Cell_associated_with_each_node_pt[0] = Cell_associated_with_each_node_pt[1];
			Cell_associated_with_each_node_pt[1] = cell_pt;

			//Reinform the cells what the local node and coordinates are in the element

			//First the first cell

			//Get the integral point and local and global coordinates of the node in the element
			//Integral point
			unsigned ipt = this->ipt_at_node(0);
			//Local coordinate
			Vector<double> s;
			this->local_coordinate_of_node(0, s);
			//Global coordinate
			Vector<double> x(this->dim());
			this->get_x(s, x);
			//add the element and local and global coordinates to the cell
			Cell_associated_with_each_node_pt[0]->set_my_element_and_coordinate(dynamic_cast<ConductingCellFunctionsBase*>(this),
																this->node_pt(0),
																Cell_associated_with_each_node_pt[0],
																this->vm_index_BaseCellMembranePotential(),
																ipt, s, x, 0);
			//Call the cell to assign initial conditions
			Cell_associated_with_each_node_pt[0]->assign_initial_conditions(true);


			//Then the second cell

			//Get the integral point and local and global coordinates of the node in the element
			//Integral point
			ipt = this->ipt_at_node(1);
			//Local coordinate
			this->local_coordinate_of_node(1, s);
			//Global coordinate
			this->get_x(s, x);
			//add the element and local and global coordinates to the cell
			Cell_associated_with_each_node_pt[1]->set_my_element_and_coordinate(dynamic_cast<ConductingCellFunctionsBase*>(this),
																this->node_pt(1),
																Cell_associated_with_each_node_pt[1],
																this->vm_index_BaseCellMembranePotential(),
																ipt, s, x, 1);
			//Call the cell to assign initial conditions
			Cell_associated_with_each_node_pt[1]->assign_initial_conditions(true);


			// oomph_info << "element " << e << " swapped nodes." << std::endl;
		}
	}


	//Get a pointer to the cell associated with the node
	CellModelBaseFullySegregated* get_cell_at_node_pt(const unsigned& l) const
	{
		return Cell_associated_with_each_node_pt[l];
	}


	double interpolated_cell_variable(const unsigned& i, const Vector<double> s) const
	{
		//The thing we are outputting
		double out = 0.0;

		//Get the interpolation weights at the point s
		const unsigned n_node = this->nnode();
		Shape psi(n_node);
		shape(s,psi);

		Vector<double> interp_weights(n_node, 0.0);
		double interp_weights_magnitude = 0.0;
		bool all_are_zero = true;
		Vector<unsigned> interpolated_nodes;
		//Determine which nodes are associated with cells of the correct model type
		for(unsigned l=0; l<n_node; l++)
		{
			//If the cell associated with the node is the same type as what we are outputting
			if(get_cell_at_node_pt(l)->get_cell_model_name() == paraview_output_type)
			{
				//Set that weight
				interp_weights[l] = psi[l];
				all_are_zero = false;
				interpolated_nodes.push_back(l);
				interp_weights_magnitude += psi[l]*psi[l];
			}
		}
		//If all are incorrect then return nan
		if(all_are_zero){return std::nanf("");}

		//Normalise the vector
		interp_weights_magnitude = std::sqrt(interp_weights_magnitude);
		for(unsigned l=0; l<n_node; l++)
		{
			interp_weights[l] /= interp_weights_magnitude;
		}

		//Finally, interpolate the cell variable
		for(const unsigned l : interpolated_nodes)
		{
			out += get_cell_at_node_pt(l)->get_cell_variable(i)*interp_weights[l];
		}

		return out;
	}


	//get the integration point associated with node n
	inline unsigned ipt_at_node(const unsigned &n) const
			{return ipt_not_at_nodes + n;}

	//The required amount of storage per node
	inline unsigned required_nvalue(const unsigned &n) const {
		return (CONDUCTANCE_MODEL::required_nvalue(n));
	}

	inline void add_cell_to_node(const unsigned &l, CellModelBaseFullySegregated* cell_pt){
		Cell_associated_with_each_node_pt[l] = cell_pt;
	}



	/////Get variables from cell model

	//Get Vm predicted from cell model
	inline double get_nodal_predicted_vm(const unsigned &l) const {
		//If the node has an associated cell then use that given by the cell model,
		//else just return the value at the node
		if(get_cell_at_node_pt(l)!=nullptr)
		{
			return get_cell_at_node_pt(l)->get_predicted_vm();
		}
		else
		{
			return this->get_nodal_membrane_potential_BaseCellMembranePotential(l);
		}
	}

	//Get Integral of Iion from cell model
	inline double get_nodal_integral_iion(const unsigned &l) const {
		//If the node has an associated cell then use that given by the cell model,
		//else just return the value zero
		if(get_cell_at_node_pt(l)!=nullptr)
		{
			return get_cell_at_node_pt(l)->get_Integral_Iion();
		}
		else
		{
			return 0.0;
		}
	}



	//Get active strain from cell model
	inline double get_nodal_active_strain(const unsigned &l) const {
		//If the node has an associated cell then use that given by the cell model,
		//else just return the value zero
		if(get_cell_at_node_pt(l)!=nullptr)
		{
			return get_cell_at_node_pt(l)->get_active_strain();
		}
		else
		{
			return 0.0;
		}
	}	

	//Get general data from cell at node - generally used for outputting but can be used for other things, such as communicating ion flux to an external element



	/////Send variables to cell model

	//Set cell type of cell at node
	void set_cell_type(const unsigned &l, const unsigned &cell_type){
		if(get_cell_at_node_pt(l)!=nullptr)
		{
			get_cell_at_node_pt(l)->set_cell_type(cell_type);
		}
	}

	//Send general data to cell at node
	inline void set_other_data_at_node(const unsigned &l, const unsigned &var, const double &value){
		if(get_cell_at_node_pt(l)!=nullptr)
		{
			get_cell_at_node_pt(l)->set_other_data(var, value);
		}
	}

	//Assign initial conditions - the cell model generally does this itself but we can override it by forcing it to use the variables this function sends instead
	inline void assign_initial_conditions(const unsigned&l, const Vector<double>& vals, const double& vm){
		if(get_cell_at_node_pt(l)!=nullptr)
		{
			get_cell_at_node_pt(l)->assign_initial_conditions(vals, vm);
		}
	}



	/////Interpolate data from the cell models

	//Get interpolated Vm predicted from cell model
	double get_interpolated_predicted_vm_from_cell_model(const Vector<double>& s) const {
		//The thing we are outputting
		double out = 0.0;
		//The shape function
		const unsigned n_node = this->nnode();
		Shape psi(n_node);
		shape(s,psi);
		//Loop over the nodes
		for(unsigned l=0; l<n_node; l++){
			out += psi[l]*get_nodal_predicted_vm(l);
		}

		return out;
	}


	//Overload this function of the conduction element in case it needs to do strang splitting
	double get_nodal_predicted_vm_BaseCellMembranePotential(const unsigned &l) const
	{	
		return get_nodal_predicted_vm(l);
	}


	//Overload this function of the conduction element in case it needs to do toms splitting method
	double get_nodal_integral_iion_BaseCellMembranePotential(const unsigned &l) const
	{	
		return get_nodal_integral_iion(l);
	}


	//Get interpolated active strain from cell model
	double get_interpolated_active_strain_from_cell_model(const Vector<double>& s) const {
		//The thing we are outputting
		double out = 0.0;
		//The shape function
		const unsigned n_node = this->nnode();
		Shape psi(n_node);
		shape(s,psi);
		//Loop over the nodes
		for(unsigned l=0; l<n_node; l++){
			out += psi[l]*get_nodal_active_strain(l);
		}

		return out;
	}


	// Get interpolated general data from cell model - this is dangerous, make sure that you are definitely interpolating the same data from all nodes in the element
	//													the issue arrises from that each node could be associated with different cell models, the general output data
	//													of which might not line up if you are not careful. I provide no safety checks for this, you are on your own.
	// void get_interpolated_general_output_from_cell_model(const Vector<double>& s, Vector<double> &Out) const {
	// 	Out.resize(Cell_associated_with_each_node_pt[0]->Num_Output_Data, 0.0);
	// 	#ifdef PARANOID
	// 	for(unsigned l=1; l<n_node; l++){
	// 		if(get_cell_at_node_pt(l)->Num_Output_Data != Cell_associated_with_each_node_pt[0]->Num_Output_Data)
	// 		{
	// 			throw OomphLibError(
	// 				"Number of output variables of nodes does not match",
	// 				OOMPH_CURRENT_FUNCTION,
	// 				OOMPH_EXCEPTION_LOCATION);
	// 		}
	// 	}
	// 	#endif

	// 	const unsigned n_node = this->nnode();
	// 	Shape psi(n_node);
	// 	shape(s,psi);

	// 	for(unsigned l=0; l<n_node; l++){
	// 		Vector<double> node_out(get_cell_at_node_pt(l)->Num_Output_Data, 0.0);
	// 		get_cell_at_node_pt(l)->get_optional_cell_output(l, node_out);
	// 		for(unsigned i=0; i<CELL_MODEL::Num_Output_Data; i++){
	// 			Out[i] += psi[l]*node_out[i];
	// 		}
	// 	}
	// }
	


	/////Set general node-wise data

	//Set general nodal parameters



	/////Fill in residuals and jacobian

	void fill_in_contribution_to_residuals(Vector<double> &residuals)
	{
		CONDUCTANCE_MODEL::fill_in_generic_residual_contribution_BaseCellMembranePotential(residuals, GeneralisedElement::Dummy_matrix,
																				GeneralisedElement::Dummy_matrix, 0);
	}

	void fill_in_contribution_to_jacobian(Vector<double> &residuals,
		                                   DenseMatrix<double> &jacobian)
	{	
		CONDUCTANCE_MODEL::fill_in_contribution_to_jacobian(residuals, jacobian);
		// fill_in_contribution_to_jacobian(residuals, jacobian);
	}

	void fill_in_contribution_to_jacobian_and_mass_matrix(Vector<double> &residuals, DenseMatrix<double> &jacobian,
															DenseMatrix<double> &mass_matrix)
	{
		//Broken - how can this be filled in for the cell variables? - Not obvious
		FiniteElement::fill_in_contribution_to_jacobian_and_mass_matrix(residuals, jacobian, mass_matrix);
	}



public:

	


	unsigned nscalar_paraview() const
	{
		return this->paraview_nscalar;

	}

	void scalar_value_paraview(std::ofstream& file_out,
								const unsigned& i,
								const unsigned& nplot) const
	{
		//Vector of local coordinates
		Vector<double> s(this->dim());

		// const unsigned n_node = this->nnode();
		// const unsigned vm_index = this->vm_index_BaseCellMembranePotential();
		// Shape psi(n_node);
		// DShape dpsidx(n_node,this->dim());

		// Loop over plot points
		unsigned num_plot_points=this->nplot_points_paraview(nplot);
		for (unsigned iplot=0;iplot<num_plot_points;iplot++){
			// Get local coordinates of plot point
			this->get_s_plot(iplot,nplot,s);

			if(i==0)
			{
				file_out << this->interpolated_vm_BaseCellMembranePotential(s) << std::endl;
			}
			else
			{
				file_out << this->interpolated_cell_variable(i-1, s) << std::endl; //we want the i-1th cell variable because i=1 corresponds to the first cell variable
			}
		}
	}

	void scalar_value_fct_paraview(std::ofstream& file_out,
									const unsigned& i,
									const unsigned& nplot,
									FiniteElement::SteadyExactSolutionFctPt
									exact_soln_pt) const
	{
		scalar_value_paraview(file_out, i, nplot);
	}

	std::string scalar_name_paraview(const unsigned& i) const
	{
		if(i==0) //0 is always transmembrane potential
		{
			return "Transmembrane potential";
		}
		else//Otherwise grab it from the vector stored in the cell mesh, we do it this way because elements which do not contain a certain cell model type will not know what name to provide and will cause an error.
		{
			return this->Variable_Names_BroadCast_From_Cell_Mesh[i-1];
		}
	}



protected:
	//The number of integral points which are not additional ones placed at the nodes
	unsigned ipt_not_at_nodes;

private:
	//Pointer to the cell corresponding to each node in the element
	Vector<CellModelBaseFullySegregated*> Cell_associated_with_each_node_pt;
};













//Q Element
template<unsigned DIM, unsigned NNODE_1D, template<unsigned> class CONDUCTANCE_MODEL>
class QFullySegregatedCellElement : public virtual QElement<DIM, NNODE_1D>,
									public virtual FullySegregatedCellEquations<CONDUCTANCE_MODEL<DIM>>
{
private:

	inline static GaussWithNodes<DIM, NNODE_1D> NewIntegralScheme;

public:

	QFullySegregatedCellElement() : QElement<DIM, NNODE_1D>(),
									FullySegregatedCellEquations<CONDUCTANCE_MODEL<DIM>>()
	{
		//set the integration scheme to one with integral points aligned with the nodes
		// GaussWithNodes<DIM, NNODE_1D>* new_integral_pt = new GaussWithNodes<DIM, NNODE_1D>;
		// this->set_integration_scheme(new GaussWithNodes<DIM, NNODE_1D>);
		this->set_integration_scheme(&NewIntegralScheme);
		//set the number of integral points which are not aligned with nodes
		this->ipt_not_at_nodes = this->integral_pt()->nweight() - this->nnode();
	}

	QFullySegregatedCellElement(const QFullySegregatedCellElement<DIM, NNODE_1D, CONDUCTANCE_MODEL>& dummy){BrokenCopy::broken_copy("QFullySegregatedCellElement");}

	void operator=(const QFullySegregatedCellElement<DIM, NNODE_1D, CONDUCTANCE_MODEL>&){BrokenCopy::broken_assign("QFullySegregatedCellElement");}


	//====================================================================
	//Output functions
	//====================================================================
	/// Output with default number of plot points
	void output(std::ostream &outfile){
		FullySegregatedCellEquations<CONDUCTANCE_MODEL<DIM>>::output(outfile);
	}
	/// \short Output FE representation of soln: x,y,V_fct,[vars] or x,y,z,V_fct,[vars] at 
	/// nplot^DIM plot points
	void output(std::ostream &outfile, const unsigned &nplot){
		FullySegregatedCellEquations<CONDUCTANCE_MODEL<DIM>>::output(outfile, nplot);
	}
	/// C_style output with default number of plot points
	void output(FILE* file_pt){
		FullySegregatedCellEquations<CONDUCTANCE_MODEL<DIM>>::output(file_pt);
	}
	 /// \short C-style output FE representation of soln: x,y,V_fct,[vars] or x,y,z,V_fct,[vars] at 
	 /// n_plot^DIM plot points
	 void output(FILE* file_pt, const unsigned &n_plot){
	 	FullySegregatedCellEquations<CONDUCTANCE_MODEL<DIM>>::output(file_pt, n_plot);
	}

	//======================================================================
	/// \short Define the shape functions and test functions and derivatives
	/// w.r.t. global coordinates and return Jacobian of mapping.
	///
	/// Galerkin: Test functions = shape functions
	//======================================================================
	double dshape_and_dtest_eulerian_BaseCellMembranePotential(const Vector<double> &s,
														Shape &psi, 
														DShape &dpsidx,
														Shape &test, 
														DShape &dtestdx) const
	{
		//Call the geometrical shape functions and derivatives  
		double J = this->dshape_eulerian(s,psi,dpsidx);
		//Loop over the test functions and derivatives and set them equal to the
		//shape functions
		for(unsigned i=0;i<NNODE_1D;i++)
		{
			test[i] = psi[i]; 
			for(unsigned j=0;j<DIM;j++)
			{
				dtestdx(i,j) = dpsidx(i,j);
			}
		}
		//Return the jacobian
		return J;
	}

	//======================================================================
	/// Define the shape functions and test functions and derivatives
	/// w.r.t. global coordinates and return Jacobian of mapping.
	///
	/// Galerkin: Test functions = shape functions
	//======================================================================
	double dshape_and_dtest_eulerian_at_knot_BaseCellMembranePotential(const unsigned &ipt,
																Shape &psi, 
																DShape &dpsidx,
																Shape &test, 
																DShape &dtestdx) const
	{
		//Call the geometrical shape functions and derivatives  
		double J = this->dshape_eulerian_at_knot(ipt,psi,dpsidx);
		//Set the test functions equal to the shape functions (pointer copy)
		test = psi;
		dtestdx = dpsidx;
		//Return the jacobian
		return J;
	}

	double 	d2shape_and_d2test_eulerian_at_knot_BaseCellMembranePotential(const unsigned &ipt, 
																		Shape &psi, 
																		DShape &dpsidx, 
																		DShape &d2psidx,
																		Shape &test, 
																		DShape &dtestdx, 
																		DShape &d2testdx) const
	{
		const double J = this->d2shape_eulerian_at_knot(ipt, psi, dpsidx, d2psidx);
		test = psi;
		dtestdx = dpsidx;
		d2testdx = d2psidx;

		return J;
	}

};


template<unsigned NNODE_1D, unsigned DIM, template<unsigned> class CONDUCTANCE_MODEL>
class FaceGeometry<QFullySegregatedCellElement<DIM, NNODE_1D, CONDUCTANCE_MODEL> >:
	public virtual QElement<DIM-1, NNODE_1D>
{
public:
	FaceGeometry()	:	QElement<DIM-1, NNODE_1D>()	{}
};	

template<unsigned NNODE_1D, template<unsigned> class CONDUCTANCE_MODEL>
class FaceGeometry<QFullySegregatedCellElement<1, NNODE_1D, CONDUCTANCE_MODEL> >:
	public virtual PointElement
{
public:
	FaceGeometry()	:	PointElement()	{}
};






//T Element
template<unsigned DIM, unsigned NNODE_1D, template<unsigned> class CONDUCTANCE_MODEL>
class TFullySegregatedCellElement : public virtual TElement<DIM, NNODE_1D>,
									public virtual FullySegregatedCellEquations<CONDUCTANCE_MODEL<DIM>>
{
private:
	inline static TGaussWithNodes<DIM, NNODE_1D> NewIntegralScheme;
public:
	TFullySegregatedCellElement() : TElement<DIM, NNODE_1D>(),
									FullySegregatedCellEquations<CONDUCTANCE_MODEL<DIM>>()
	{
		//set the integration scheme to one with integral points aligned with the nodes
		// TGaussWithNodes<DIM, NNODE_1D>* new_integral_pt = new TGaussWithNodes<DIM, NNODE_1D>;
		// this->set_integration_scheme(new TGaussWithNodes<DIM, NNODE_1D>);
		this->set_integration_scheme(&NewIntegralScheme);
		//set the number of integral points which are not aligned with nodes
		this->ipt_not_at_nodes = this->integral_pt()->nweight() - this->nnode();
	}

	TFullySegregatedCellElement(const TFullySegregatedCellElement<DIM, NNODE_1D, CONDUCTANCE_MODEL>& dummy){BrokenCopy::broken_copy("TFullySegregatedCellElement");}

	void operator=(const TFullySegregatedCellElement<DIM, NNODE_1D, CONDUCTANCE_MODEL>&){BrokenCopy::broken_assign("TFullySegregatedCellElement");}


	//====================================================================
	//Output functions
	//====================================================================
	/// Output with default number of plot points
	void output(std::ostream &outfile){
		FullySegregatedCellEquations<CONDUCTANCE_MODEL<DIM>>::output(outfile);
	}
	/// \short Output FE representation of soln: x,y,V_fct,[vars] or x,y,z,V_fct,[vars] at 
	/// nplot^DIM plot points
	void output(std::ostream &outfile, const unsigned &nplot){
		FullySegregatedCellEquations<CONDUCTANCE_MODEL<DIM>>::output(outfile, nplot);
	}
	/// C_style output with default number of plot points
	void output(FILE* file_pt){
		FullySegregatedCellEquations<CONDUCTANCE_MODEL<DIM>>::output(file_pt);
	}
	 /// \short C-style output FE representation of soln: x,y,V_fct,[vars] or x,y,z,V_fct,[vars] at 
	 /// n_plot^DIM plot points
	 void output(FILE* file_pt, const unsigned &n_plot){
	 	FullySegregatedCellEquations<CONDUCTANCE_MODEL<DIM>>::output(file_pt, n_plot);
	}

	//======================================================================
	/// \short Define the shape functions and test functions and derivatives
	/// w.r.t. global coordinates and return Jacobian of mapping.
	///
	/// Galerkin: Test functions = shape functions
	//======================================================================
	double dshape_and_dtest_eulerian_BaseCellMembranePotential(const Vector<double> &s,
														Shape &psi, 
														DShape &dpsidx,
														Shape &test, 
														DShape &dtestdx) const
	{
		//Call the geometrical shape functions and derivatives  
		double J = this->dshape_eulerian(s,psi,dpsidx);
		//Loop over the test functions and derivatives and set them equal to the
		//shape functions
		for(unsigned i=0;i<NNODE_1D;i++)
		{
			test[i] = psi[i]; 
			for(unsigned j=0;j<DIM;j++)
			{
				dtestdx(i,j) = dpsidx(i,j);
			}
		}
		//Return the jacobian
		return J;
	}

	//======================================================================
	/// Define the shape functions and test functions and derivatives
	/// w.r.t. global coordinates and return Jacobian of mapping.
	///
	/// Galerkin: Test functions = shape functions
	//======================================================================
	double dshape_and_dtest_eulerian_at_knot_BaseCellMembranePotential(const unsigned &ipt,
																Shape &psi, 
																DShape &dpsidx,
																Shape &test, 
																DShape &dtestdx) const
	{
		//Call the geometrical shape functions and derivatives  
		double J = this->dshape_eulerian_at_knot(ipt,psi,dpsidx);
		//Set the test functions equal to the shape functions (pointer copy)
		test = psi;
		dtestdx = dpsidx;
		//Return the jacobian
		return J;
	}

	double 	d2shape_and_d2test_eulerian_at_knot_BaseCellMembranePotential(const unsigned &ipt, 
																		Shape &psi, 
																		DShape &dpsidx, 
																		DShape &d2psidx,
																		Shape &test, 
																		DShape &dtestdx, 
																		DShape &d2testdx) const
	{
		const double J = this->d2shape_eulerian_at_knot(ipt, psi, dpsidx, d2psidx);
		test = psi;
		dtestdx = dpsidx;
		d2testdx = d2psidx;

		return J;
	}

};


template<unsigned NNODE_1D, unsigned DIM, template<unsigned> class CONDUCTANCE_MODEL>
class FaceGeometry<TFullySegregatedCellElement<DIM, NNODE_1D, CONDUCTANCE_MODEL> >:
	public virtual TElement<DIM-1, NNODE_1D>
{
public:
	FaceGeometry()	:	TElement<DIM-1, NNODE_1D>()	{}
};	

template<unsigned NNODE_1D, template<unsigned> class CONDUCTANCE_MODEL>
class FaceGeometry<TFullySegregatedCellElement<1, NNODE_1D, CONDUCTANCE_MODEL> >:
	public virtual PointElement
{
public:
	FaceGeometry()	:	PointElement()	{}
};


















//Mesh base class which handles cell objects and provides suitable pointers to the cells to each element in the mesh
//NOTE this class requires the elements and nodes to already be constructed hence you MUST inherit from this class
// AFTER the mesh class
template<class CONDUCTANCE_MODEL>
class CellMeshBase : public virtual Mesh
{
private:
	//Work out what elements contain each 'global' node and which local node indexes correspond to these nodes.
	void BuildNodeElementTables()
	{
		//Original slow brute force method

		// //First we allocate suitable storage in the vectors
		// Elements_containing_node.resize(this->nnode());

		// //Next we loop over all the nodes
		// for(unsigned l=0; l<this->nnode(); l++){
		// 	//Get a pointer to the l-th node
		// 	Node* mesh_nod_pt = this->node_pt(l);

		// 	//Next loop over all the elements in the mesh
		// 	for(unsigned e=0; e<this->nelement(); e++){
		// 		//Get a pointer to the element
		// 		FiniteElement* elem_pt = this->finite_element_pt(e);

		// 		//Now we loop over the nodes in that element
		// 		for(unsigned l1=0; l1<elem_pt->nnode(); l1++){
		// 			//get a pointer to that element
		// 			Node* elem_nod_pt = elem_pt->node_pt(l1);

		// 			if(mesh_nod_pt==elem_nod_pt){
		// 				//If the pointers point to the same object then add the element and the local node number to the table
		// 				Elements_containing_node[l].push_back(std::pair<unsigned long, unsigned>(e, l1));
		// 			}
		// 		}
		// 	}
		// }


		//Much faster method

		oomph_info << "Building node-element/local node table" << std::endl;
		double t_start = TimingHelpers::timer();

		oomph_info << this->nnode() << " " << this->nelement() << std::endl;

		//First we allocate suitable storage in the vectors
		Elements_containing_node.clear();
		Elements_containing_node.resize(this->nnode());

		//Resize storage of cell numbers assigned to each node.
		Node_Number_To_Cell_Number.clear();
		Node_Number_To_Cell_Number.resize(this->nnode(), -1);

		//Map of node pointers to global node number
		std::map<Node*, unsigned> Node_pt_to_global_number;
		//Build the map of node pointers to global node numbers
		for(unsigned l=0; l<this->nnode(); l++){
			//Get a pointer to the l-th node
			Node* nod_pt = this->node_pt(l);
			//Fill in the entry
			Node_pt_to_global_number[nod_pt] = l;
		}

		//Loop over all the elements in the mesh
		for(unsigned e=0; e<this->nelement(); e++){
			//get a pointer to the element
			FiniteElement* elem_pt = this->finite_element_pt(e);
			//Now we loop over the nodes in that element
			for(unsigned l1=0; l1<elem_pt->nnode(); l1++){
				//get a pointer to that element
				Node* elem_nod_pt = elem_pt->node_pt(l1);
				//Use the map setup earlier to determine what the global node number of the local node l1 is and fill in its entry of the table
				Elements_containing_node[Node_pt_to_global_number[elem_nod_pt]].push_back(std::pair<unsigned long, unsigned>(e, l1));
			}
		}


		// for(unsigned l=0; l<this->nnode(); l++){
		// 	oomph_info << "Node " << l << ": " << std::endl;
		// 	for(unsigned e=0; e<Elements_containing_node[l].size(); e++){
		// 		oomph_info << "\t" << Elements_containing_node[l][e].first << " " << Elements_containing_node[l][e].second << std::endl;
		// 	}
		// 	oomph_info << std::endl;
		// }


		double t_end = TimingHelpers::timer();
		oomph_info << "Done. It took me " << (t_end - t_start) << " seconds." << std::endl;

	}

protected:

	//Should you wish to change the way the mesh calculates the elements containing each node then use this function
	void Set_Elements_containing_node(const Vector<Vector<std::pair<unsigned long, unsigned>>> &new_vect)
	{
		Elements_containing_node = new_vect;
	}

	//This function is left virtual since the way in which cells are built on the mesh is entirely problem-dependent.
	// the helper function build_cell_at_node(...) is provided to handle all of the tricky communications, I strongly
	// recommend you use it, if you for any reason do not need to use it please let me know so I can change the functionality
	virtual void BuildCells()
	{
		throw OomphLibError(
			"I am attempting to build the cells in the mesh but you haven't overloaded the appropriate function",
			OOMPH_CURRENT_FUNCTION,
			OOMPH_EXCEPTION_LOCATION);
	}

	//Fill in place-holder cells at nodes without a cell assigned. This is required since operator splitting solves
	// use the membrane potential values stored at the cells for the previous time-step. If no cell is assigned
	// then iterations of newton method converge very slowly.
	virtual void FillInPlaceHolderCells()
	{
		const unsigned n_node = this->nnode();
		for(unsigned l=0; l<n_node; l++)
		{
			//If no cell has been assigned to it, give it an empty place-holder cell
			if(Node_Number_To_Cell_Number[l]<0)
			{
				build_cell_at_node<Empty_Cell>(l);
			}
		}
	}

	//Build a cell at the location of the l-th node in the mesh. We need to pass the cell by pointer to all elements which contain
	// the l-th node in the mesh and also pass one of these elements and the local coordinate of the node within that element
	// to the cell.
	template<class CELL_MODEL>
	void build_cell_at_node(const unsigned long& l)
	{
		//Build the cell
		Cells_pt.push_back(new CELL_MODEL);

		//Add the cell to the node, setup all lookup schemes required by element, node, and cell.
		add_cell_to_node(l, NumCells);

		//Call the cell to assign initial conditions
		Cells_pt[NumCells]->assign_initial_conditions(true);

		//Increment the number of cells
		NumCells++;
	}


	//Add cell to node
	void add_cell_to_node(const unsigned long& l, const unsigned long& cell_ind)
	{
		bool passed_to_cell = false;
		//Pass the cell by pointer to all of the elements containing the node
		for(unsigned i=0; i<Elements_containing_node[l].size(); i++)
		{
			//Get a pointer to the i-th element containing the node
			CONDUCTANCE_MODEL* elem_pt = dynamic_cast<CONDUCTANCE_MODEL*>(this->element_pt(Elements_containing_node[l][i].first));
			
			#ifdef OOMPH_HAS_MPI
			//Check if the element exists if we are in parallel since it may have been deleted in a distribute
			if(elem_pt!=nullptr)
			{
				if(dynamic_cast<CONDUCTANCE_MODEL*>(elem_pt)!=nullptr)
				{
					if(dynamic_cast<ConductingCellFunctionsBase*>(elem_pt)!=nullptr)
					{
			#endif
						const unsigned node_ind = Elements_containing_node[l][i].second;

						//Add the pointer to the suitable entry in the vector of cell pointers in the element
						elem_pt->add_cell_to_node(node_ind, Cells_pt[cell_ind]);

						//If we haven't yet, pass the element and node to the cell
						if(!passed_to_cell)
						{
							//Get the integral point and local and global coordinates of the node in the element
							//Integral point
							const unsigned ipt = elem_pt->ipt_at_node(node_ind);
							//Local coordinate
							Vector<double> s;
							elem_pt->local_coordinate_of_node(node_ind, s);
							//Global coordinate
							Vector<double> x(elem_pt->dim());
							elem_pt->get_x(s, x);

							//add the element and local and global coordinates to the cell
							Cells_pt[cell_ind]->set_my_element_and_coordinate(dynamic_cast<ConductingCellFunctionsBase*>(elem_pt),
																				elem_pt->node_pt(node_ind),
																				Cells_pt[cell_ind],
																				elem_pt->vm_index_BaseCellMembranePotential(),
																				ipt, s, x, node_ind);

							//It was successfully passed to a node, so we (as a mesh) need to check if it is a new cell model type we need to keep track of
							bool cell_model_type_is_new = true;
							if(Identified_Cell_Model_Types_And_Data.size()==0) //if this is the first cell added then it will always be a new type
							{

							}
							else
							{
								for(auto data : Identified_Cell_Model_Types_And_Data)
								{
									if(Cells_pt[cell_ind]->get_cell_model_name() == std::get<0>(data))
									{
										cell_model_type_is_new = false;
									}
								}
							}
							if(cell_model_type_is_new)//add it as a new cell model type
							{
								std::string model_name = Cells_pt[cell_ind]->get_cell_model_name();
								std::vector<std::string> vars_names = Cells_pt[cell_ind]->names_of_cell_variables();
								unsigned num_vars = (vars_names.size()+1); //+1 to account for membrane potential

								Identified_Cell_Model_Types_And_Data.push_back(std::make_tuple(model_name, vars_names, num_vars));
							}

							passed_to_cell = true;
						}
			#ifdef OOMPH_HAS_MPI
					}
				}
			}
			#endif

		}

		if(!passed_to_cell)
		{
			throw OomphLibError("There is no element left which contains this node",
								OOMPH_CURRENT_FUNCTION,
								OOMPH_EXCEPTION_LOCATION);
		}

		//Record for the node what cell is assigned to it
		Node_Number_To_Cell_Number[l] = cell_ind;
	}


	//Setup the indexes of where in the vector of cell data each cells data starts
	// Data is packaged as Vm_0, w_0, Vm_1, w_1, ... , Vm_n, w_n
	#ifdef OOMPH_HAS_MPI
	void SetupDataIndices()
	{
		//provide suitable storage
		Starting_Index_For_Data_Of_Cell.resize(NumCells, 0);

		//iterate through the cells other than the first, that one starts at 0
		for(unsigned c=1; c<NumCells; c++){
			//The index at which this cells data is stored
			// Starting_Index_For_Data_Of_Cell[c] = ( Starting_Index_For_Data_Of_Cell[c-1] + (Cells_pt[c-1]->get_Num_Cell_Vars() + 1 + 1 + 1 + 1) );
			Starting_Index_For_Data_Of_Cell[c] = ( Starting_Index_For_Data_Of_Cell[c-1] + (Cells_pt[c-1]->get_Num_Cell_Vars() + 1 + 1) );
		}

		//The total number of data associated with the cells
		// Total_cell_data = ( Starting_Index_For_Data_Of_Cell[NumCells-1] + (Cells_pt[NumCells-1]->get_Num_Cell_Vars() + 1 + 1 + 1 + 1) );
		Total_cell_data = ( Starting_Index_For_Data_Of_Cell[NumCells-1] + (Cells_pt[NumCells-1]->get_Num_Cell_Vars() + 1 + 1) );
	}
	#endif


	virtual void FinalizeMeshSetup()
	{
		//Setup node and element tables
		BuildNodeElementTables();

		//Build the cells in the mesh, this is a user overloaded function
		BuildCells();


		//Complete the cell build by adding place-holder empty cells to nodes without a cell
		FillInPlaceHolderCells();

		oomph_info << this->nnode() << " " << Cells_pt.size() << " " << NumCells << std::endl;

		#ifdef OOMPH_HAS_MPI
		SetupDataIndices();
		#endif
	}


	//Vector of cells in the mesh
	Vector<CellModelBaseFullySegregated*> Cells_pt;
	
private:

	//The number of cells in the mesh
	unsigned long NumCells;

	//Vector containing vectors of element numbers containing each node in the mesh and the local node number of the node within that element
	// Global_Node_index[Element_Counter[Global_Element_Index, Local_Node_Index_Within_Element]]
	Vector<Vector<std::pair<unsigned long, unsigned>>> Elements_containing_node;

	Vector<int long> Node_Number_To_Cell_Number;

	#ifdef OOMPH_HAS_MPI
	//Indices in a vector containing all variables for the cells in the mesh of where each cells data begins
	Vector<unsigned long> Starting_Index_For_Data_Of_Cell;
	unsigned long Total_cell_data;
	#endif


	//Data of cell model types in this mesh, model name, variable names, num variables
	Vector<std::tuple<std::string, std::vector<std::string>, unsigned>> Identified_Cell_Model_Types_And_Data;




public:

	// #ifdef OOMPH_HAS_MPI
	// //Delete all cells associated with obsolete nodes after a distribute
	// void DeleteCellsAfterDistribute()
	// {
	// 	oomph_info << "Deleting cells after distribute " << this->nnode() << " " << this->nelement() << " " << NumCells << std::endl;

	// 	Vector<CellModelBaseFullySegregated*> new_cell_pt;
	// 	std::vector<bool> cell_saved(NumCells, false);
	// 	//Loop over the cells
	// 	for(unsigned i=0; i<NumCells; i++)
	// 	{
	// 		//If the cell is one we should save, save it
	// 		if(Cells_pt[i]->base_node_pt()!=nullptr)
	// 		{
	// 			new_cell_pt.push_back(Cells_pt[i]);
	// 			cell_saved[i] = true;

	// 			Cells_pt[i] = nullptr;
	// 		}
	// 		else //Otherwise delete it
	// 		{
	// 			delete (Cells_pt[i]);
	// 			Cells_pt[i] = nullptr;
	// 		}
	// 	}

	// 	//Get the number of saved cells
	// 	const unsigned n_cell_post_cull = new_cell_pt.size();

	// 	oomph_info << "N cells post cull " << n_cell_post_cull << std::endl;

	// 	//Re-generate the lookup tables for nodes and elements
	// 	BuildNodeElementTables();

	// 	//Clear the vector of cells
	// 	Cells_pt.clear();
	// 	NumCells=0;

	// 	//loop over them and reassign them to the correct nodes
	// 	for(unsigned i=0; i<n_cell_post_cull; i++)
	// 	{
	// 		//If the cell is not saved then skip it
	// 		if(!cell_saved[i]){continue;}

	// 		//Get a pointer to the cell
	// 		CellModelBaseFullySegregated* cell_pt = new_cell_pt[i];

	// 		//Add it back to the vector of cells
	// 		Cells_pt.push_back(cell_pt);

	// 		//loop over the nodes and get the one which matches the pointer in the cell
	// 		for(unsigned l=0; l<this->nnode(); l++)
	// 		{
	// 			//Get a pointer to the test node
	// 			Node* nod_pt = this->node_pt(l);

	// 			//If it is the node attached to the cell
	// 			if(nod_pt == cell_pt->base_node_pt())
	// 			{
	// 				//Re attach the cell to the correct node
	// 				add_cell_to_node(l, NumCells);
	// 				//Stop checking nodes
	// 				break;
	// 			}

	// 			//If we've reached the end we have been unable to find the node
	// 			if(l==this->nnode())
	// 			{
	// 				throw OomphLibError("I can't locate the node attached to this cell for some reason",
	// 									OOMPH_CURRENT_FUNCTION,
	// 									OOMPH_EXCEPTION_LOCATION);
	// 			}
	// 		}

	// 		NumCells++;
	// 	}

	// 	oomph_info << "Num cells post rebuild " << NumCells << std::endl;

	// 	SetupDataIndices();
	// }
	// #endif


	Vector<std::pair<std::string, std::string>> output_paraview_per_cell_type(const std::string& output_dir, const std::string& outfile_root_name, const unsigned& num_output, const unsigned& nplot) const
	{
		Vector<std::pair<std::string, std::string>> cell_model_vtk_name_pairs;
		//Loop over the cell models identified in the mesh and output a file for each, we skip Empty_Cell because it is empty
		for(std::tuple<std::string, std::vector<std::string>, unsigned> cell_model_data : Identified_Cell_Model_Types_And_Data)
		{
			//Inform the elements in the mesh what cell model we are saving to file, this determines nscalar_paraview and scalar_name_paraview
			//Loop over the elements
			const unsigned n_elements = this->nelement();
			for(unsigned e=0; e<n_elements; e++)
			{
				ConductingCellFunctionsBase* elem_pt = dynamic_cast<ConductingCellFunctionsBase*>(this->element_pt(e));
				elem_pt->set_paraview_output_type(std::get<0>(cell_model_data));
				elem_pt->set_variable_names_broadcast_from_cell_mesh(std::get<1>(cell_model_data));
				elem_pt->set_paraview_nscalar(std::get<2>(cell_model_data));
			}
			//Create an output file with the correct name and directory: output_dir/outfile_root_name_(cell_model)_num_output.vtk
			std::string out_file_name = outfile_root_name + "_" + std::get<0>(cell_model_data) + "_" + std::to_string(num_output) + ".vtu";
			std::string out_file_full_path = output_dir + "/" + out_file_name;
			std::ofstream out_file;
			out_file.open(out_file_full_path);

			//Perform the usual paraview output
			this->output_paraview(out_file, nplot);
			out_file.close();
			
			cell_model_vtk_name_pairs.push_back(std::make_pair(std::get<0>(cell_model_data), out_file_name));
		}

		//return pairs of (cell_model, output_file_name) so that pvd files can be suitably updated
		return cell_model_vtk_name_pairs;
	}
	

	//Access to the ith cell
	CellModelBaseFullySegregated* cell_pt(const unsigned& i){
		#ifdef PARANOID
		if(Cells_pt[i]!=nullptr)
		{
		#endif
			return Cells_pt[i];
		#ifdef PARANOID
		}
		else
		{
			throw OomphLibError("Cell ptr is null",
								OOMPH_CURRENT_FUNCTION,
								OOMPH_EXCEPTION_LOCATION);
		}
		#endif
	}

	CellModelBaseFullySegregated* cell_at_node_pt(const unsigned& l)
	{
		#ifdef PARANOID
		if(Node_Number_To_Cell_Number[l]>=0)
		{
		#endif
			return Cells_pt[Node_Number_To_Cell_Number[l]];
		#ifdef PARANOID
		}
		else
		{
			throw OomphLibError("Node has no cell",
								OOMPH_CURRENT_FUNCTION,
								OOMPH_EXCEPTION_LOCATION);
		}
		#endif
	}	

	inline unsigned num_cells() const {return NumCells;}

	CellMeshBase() : NumCells(0)
	{

	}

	~CellMeshBase()
	{
		//Kill all the cells
		for(unsigned c=0; c<NumCells; c++)
		{
			delete Cells_pt[c];
			Cells_pt[c] = 0;
		}
	}


	//Save the cell data to file, blank line means no node is associated with that node
	void save_cells_to_file(std::ofstream& out_file)
	{
		//Loop over the cells in the mesh

		//The cell number is the same as the node number.

		for(unsigned c=0; c<NumCells; c++)
		{
			CellModelBaseFullySegregated* cell_pt = Cells_pt[c];

			if(cell_pt != nullptr)
			{
				Vector<double> vect;
				cell_pt->save_state_to_vector(vect, true);

				for(unsigned i=0; i<vect.size(); i++)
				{
					out_file << vect[i] << " ";
				}

				//Also output the cell type
				cell_pt->output_cell_type(out_file);
			}

			out_file << std::endl;
		}
	}

	//Load the cell data from file and restore the cells from it
	void load_cells_from_file(std::ifstream& in_file)
	{
		oomph_info << "Loading cell data from file" << std::endl;
		//Read in the file line by line
		unsigned c=0;
		std::string line;
		while(std::getline(in_file, line))
		{
			//If the line is zero, skip it
			if(line.size()==0)
			{
				oomph_info << "line " << c << " is zero, skipping." << std::endl;
			}
			else
			{
				// oomph_info << "Line is non-zero" << std::endl;
				//read in the line to a big vector
				Vector<double> BigVector;

				std::istringstream iss(line);
				std::string str;
				while(iss >> str)
				{
					BigVector.push_back(std::atof(str.c_str()));
				}
				// oomph_info << BigVector.size() << " tokens in line" << std::endl;

				//Get up to the last one and put into a vector of variables
				Vector<double> vars_vect(BigVector.size()-1, 0.0);
				for(unsigned i=0; i<vars_vect.size(); i++)
				{
					vars_vect[i] = BigVector[i];
				}

				//The last one is the cell type
				const unsigned cell_type = (unsigned)BigVector[vars_vect.size()];

				Cells_pt[c]->restore_state_from_vector(vars_vect, true);
				Cells_pt[c]->set_cell_type(cell_type);

				Cells_pt[c]->accept_copy_variables_as_IC_values();
			}

			c++;
		}
	}


	void output_cells(const double &t, std::ostream &outfile)
	{
		for(unsigned c=0; c<NumCells; c++){
			// Cells_pt[c]->calculate_optional_output(t);

			Cells_pt[c]->output_global_coord(outfile);
			Cells_pt[c]->output_cell_type(outfile);
			Cells_pt[c]->output_cell_variables(outfile);
			Cells_pt[c]->output_additional_data(outfile);

			outfile << std::endl;
		}
	}


	void check_for_and_deal_with_inverted_elements()
	{
		//We check all of the elements
		for(unsigned e=0; e<this->nelement(); e++){
			dynamic_cast<CONDUCTANCE_MODEL*>(this->element_pt(e))->check_for_and_deal_with_inverted_jacobian();
		}

		//We have reordered some nodes so we need to regenerate the local and global node elements tables
		BuildNodeElementTables();
	}

	void reset_copy_variables_to_IC_values_for_all_cells_in_mesh()
	{
		//Loop over all of the cells in the mesh
		for(unsigned c=0; c<NumCells; c++)
		{
			Cells_pt[c]->reset_copy_variables_to_IC_values();
		}
	}

	void accept_copy_variables_as_IC_values_for_all_cells_in_mesh()
	{
		//Loop over all of the cells in the mesh
		for(unsigned c=0; c<NumCells; c++)
		{
			Cells_pt[c]->accept_copy_variables_as_IC_values();
		}
	}


	//Store all the cell data from the mesh in a vector,
	// boolean determines whether or not the membrane potential comes from the cells or the underlying nodes
	void store_all_cell_data_from_mesh_in_vector(Vector<double> &Cell_Data, const bool &use_node_vm)
	{
		//Resize the storage vector
		// oomph_info << Total_cell_data << std::endl;
		Cell_Data.resize(Total_cell_data, 0.0);

		//Loop over the cells
		for(unsigned c=0; c<NumCells; c++)
		{
			//Save the single cell data to a vector
			Vector<double> single_cell_data;
			Cells_pt[c]->save_state_to_vector(single_cell_data, use_node_vm);

			//Loop over the data from the cell and put it into the big vector
			for(unsigned i=Starting_Index_For_Data_Of_Cell[c]; i<((c<NumCells-1) ? Starting_Index_For_Data_Of_Cell[c+1] : Total_cell_data); i++)
			{
				Cell_Data[i] = single_cell_data[i-Starting_Index_For_Data_Of_Cell[c]];
			}
		}
	}


	void restore_all_cell_data_from_mesh_from_vector(Vector<double> &Cell_Data)
	{
		//Loop over the cells
		for(unsigned c=0; c<NumCells; c++)
		{
			// std::cout << c << std::endl;
			//Update the cell from the combined data vector
			std::vector<double>::const_iterator first = Cell_Data.begin() + Starting_Index_For_Data_Of_Cell[c];
			std::vector<double>::const_iterator last = Cell_Data.begin() + ((c<NumCells-1) ? Starting_Index_For_Data_Of_Cell[c+1] : Total_cell_data);
			std::vector<double> projected_cell_data(first, last);
			Cells_pt[c]->restore_state_from_vector(projected_cell_data, true);
		}
	}


	void Take_time_step_with_all_cells_in_mesh(const double& dt,
												Problem* problem_pt,
												const bool &use_node_vm_as_initial_value = false,
												const bool &update_underlying_node_value_post_solve = false)
	{
		#ifndef OOMPH_FORCE_SERIAL_SINGLE_CELL_SOLVE
		#ifdef OOMPH_HAS_MPI
		//If we only have one processor or the problem is distributed then we always do the cell solves in serial
		if(problem_pt->communicator_pt()->nproc() == 1 || this->is_mesh_distributed())
		{
		#endif
		#endif
			//If there is only one processor or we are running in serial then do it serially

			oomph_info << "Performing a serial timestep for all cells in a mesh" << std::endl;
			double t_start = TimingHelpers::timer();

			//Loop over all of the cells in the mesh
			for(unsigned c=0; c<NumCells; c++){
				// oomph_info << "Cell " << c << std::endl;
				//Take a timestep
				// oomph_info << "Solving cell " << c << std::endl;
				Cells_pt[c]->TakeTimestep(problem_pt->time_pt()->time(), dt, use_node_vm_as_initial_value);
				if(update_underlying_node_value_post_solve)
				{
					Cells_pt[c]->update_underlying_node_membrane_potential();
				}
			}
			double t_end = TimingHelpers::timer();
			oomph_info << "Done. It took me " << (t_end-t_start) << " seconds to complete." << std::endl;
		#ifndef OOMPH_FORCE_SERIAL_SINGLE_CELL_SOLVE
		#ifdef OOMPH_HAS_MPI
		}
		else
		{
		#ifdef PARANOID
			//Solve in serial first to check against the mpi version
			Vector<double> Serial_Cell_Data(Total_cell_data, 0.0);

			Vector<double> restore_single_cell_data;
			//Loop over all of the cells in the mesh
			for(unsigned c=0; c<NumCells; c++)
			{
				Cells_pt[c]->save_state_to_vector(restore_single_cell_data);
				//Take a timestep
				Cells_pt[c]->TakeTimestep(problem_pt->time_pt()->time(), dt, use_node_vm_as_initial_value);
				// if(update_underlying_node_value_post_solve)
				// {
				// 	Cells_pt[c]->update_underlying_node_membrane_potential();
				// }

				Vector<double> single_cell_data;
				Cells_pt[c]->save_state_to_vector(single_cell_data);
				for(unsigned i=Starting_Index_For_Data_Of_Cell[c]; i<((c<NumCells-1) ? Starting_Index_For_Data_Of_Cell[c+1] : Total_cell_data); i++)
				{
					Serial_Cell_Data[i] = single_cell_data[i-Starting_Index_For_Data_Of_Cell[c]];
				}

				Cells_pt[c]->restore_state_from_vector(restore_single_cell_data);
			}
		#endif


			//If we are compiled with parallel and we have more than one processor then run in parallel
			oomph_info << "Performing a parallel timestep for all cells in a mesh" << std::endl;
			const double t_start = TimingHelpers::timer();

			//Set up the local vector of new cell variables
			Vector<double> Local_Cell_Data(Total_cell_data, 0.0);
			//Set up the vector of combined data across all processors
			Vector<double> Combined_Cell_Data(Total_cell_data, 0.0);

		#ifdef PARANOID
			Vector<unsigned> Local_cell_is_computed(NumCells, 0);
			Vector<unsigned> Combined_cell_is_computed(NumCells, 0);

			Vector<unsigned> Local_dof_is_computed(Total_cell_data, 0);
			Vector<unsigned> Combined_dof_is_computed(Total_cell_data, 0);


		#endif

			//Loop over the cells
			for(unsigned c=0; c<NumCells; c++)
			{
				//If it is one we are to compute then compute it
				if(c%problem_pt->communicator_pt()->nproc() != problem_pt->communicator_pt()->my_rank()) continue;
				// oomph_info << "Cell " << c << std::endl;
			#ifdef PARANOID
				Local_cell_is_computed[c]++;
			#endif
				// oomph_info << "Solving cell " << c << std::endl;
				Cells_pt[c]->TakeTimestep(problem_pt->time_pt()->time(), dt, use_node_vm_as_initial_value);
				//Save the solution to the local vector
				Vector<double> single_cell_data;
				Cells_pt[c]->save_state_to_vector(single_cell_data);
				for(unsigned i=Starting_Index_For_Data_Of_Cell[c]; i<((c<NumCells-1) ? Starting_Index_For_Data_Of_Cell[c+1] : Total_cell_data); i++)
				{
					Local_Cell_Data[i] = single_cell_data[i-Starting_Index_For_Data_Of_Cell[c]];
				#ifdef PARANOID
					Local_dof_is_computed[i]++;
				#endif
				}
			}

			const double t_end_solve = TimingHelpers::timer();
			oomph_info << "Actual solve took " << (t_end_solve-t_start) << " seconds." << std::endl;

			//Mpi All reduce
			MPI_Allreduce(Local_Cell_Data.data(), Combined_Cell_Data.data(), Total_cell_data, MPI_DOUBLE, MPI_SUM, problem_pt->communicator_pt()->mpi_comm());


		#ifdef PARANOID
			MPI_Allreduce(Local_cell_is_computed.data(), Combined_cell_is_computed.data(), NumCells, MPI_UNSIGNED, MPI_SUM, problem_pt->communicator_pt()->mpi_comm());

			MPI_Allreduce(Local_dof_is_computed.data(), Combined_dof_is_computed.data(), Total_cell_data, MPI_UNSIGNED, MPI_SUM, problem_pt->communicator_pt()->mpi_comm());

			double diff = 0.0;
			//Compare the serial solution to the mpi solution
			for(unsigned i=0; i<Total_cell_data; i++)
			{
				diff = std::max(diff, std::fabs(Serial_Cell_Data[i] - Combined_Cell_Data[i])/std::max(Serial_Cell_Data[i], Combined_Cell_Data[i]));
			}
			oomph_info << "Difference in serial and mpi solution: " << diff << std::endl;
			if(diff>1e-12)
			{
				for(unsigned i=0; i<Total_cell_data; i++)
				{
					if(std::fabs(Serial_Cell_Data[i] - Combined_Cell_Data[i])/std::max(Serial_Cell_Data[i], Combined_Cell_Data[i])>1e-9)
					{
						oomph_info << Serial_Cell_Data[i] << " " << Combined_Cell_Data[i] << " " << std::fabs(Serial_Cell_Data[i] - Combined_Cell_Data[i])/std::max(Serial_Cell_Data[i], Combined_Cell_Data[i]) << " " << Combined_dof_is_computed[i] << std::endl;
					}
				}

				for(unsigned c=0; c<NumCells; c++)
				{
					oomph_info << Combined_cell_is_computed[c] << std::endl;
				}	

				throw OomphLibError("MPI and serial do not match",
								OOMPH_CURRENT_FUNCTION,
								OOMPH_EXCEPTION_LOCATION);
			}
		#endif


			const double t_end_reduce = TimingHelpers::timer();
			oomph_info << "All reduce took " << (t_end_reduce-t_end_solve) << " seconds." << std::endl;

			//Loop over the cells
			for(unsigned c=0; c<NumCells; c++)
			{
			#ifdef PARANOID
				if(Combined_cell_is_computed[c]!=1)
				{
					std::ostringstream error_message;
					error_message << "Cell " << std::to_string(c) << " is not computed" << std::endl;
					throw OomphLibError(error_message.str(),
										OOMPH_CURRENT_FUNCTION,
										OOMPH_EXCEPTION_LOCATION);
				}
			#endif
				//Update the cell from the combined data vector
				std::vector<double>::const_iterator first = Combined_Cell_Data.begin() + Starting_Index_For_Data_Of_Cell[c];
				std::vector<double>::const_iterator last = Combined_Cell_Data.begin() + ((c<NumCells-1) ? Starting_Index_For_Data_Of_Cell[c+1] : Total_cell_data);
				std::vector<double> projected_cell_data(first, last);
				Cells_pt[c]->restore_state_from_vector(projected_cell_data, update_underlying_node_value_post_solve);
			}

			const double t_end_communicate = TimingHelpers::timer();
			oomph_info << "Communicate took " << (t_end_communicate-t_end_reduce) << " seconds." << std::endl;

			const double t_end = TimingHelpers::timer();
			oomph_info << "Done. It took me " << (t_end-t_start) << " seconds to complete:" << std::endl;
			oomph_info << "\tSolve " << (t_end_solve-t_start)*100.0/(t_end-t_start) << "%" << std::endl;
			oomph_info << "\tReduce " << (t_end_reduce-t_end_solve)*100.0/(t_end-t_start) << "%" << std::endl;
			oomph_info << "\tCommunicate " << (t_end_communicate-t_end_reduce)*100.0/(t_end-t_start) << "%" << std::endl;
		}
		#endif
		#endif
	}


	void distribute(OomphCommunicator* comm_pt,
                       const Vector<unsigned>& element_domain,
                       Vector<GeneralisedElement*>& deleted_element_pt,
                       DocInfo& doc_info,
                       const bool& report_stats,
                       const bool& overrule_keep_as_halo_element_status) override
	 {

	  // Store communicator
	  Comm_pt=comm_pt;

	  // Storage for number of processors and current processor
	  int n_proc=comm_pt->nproc();
	  int my_rank=comm_pt->my_rank();

	 // Storage for number of elements and number of nodes on this mesh
	 unsigned nelem=this->nelement();
	 unsigned nnod=this->nnode();

	 std::ostringstream filename;
	 
	 // Doc the partitioning (only on processor 0)
	 //-------------------------------------------
	 if (doc_info.is_doc_enabled())
	  {
	   if (my_rank==0)
	    {
	     // Open files for doc of element partitioning
	     Vector<std::ofstream*> domain_file(n_proc);
	     for (int d=0;d<n_proc;d++)
	      {
	       // Note: doc_info.number() was set in Problem::distribute(...) to
	       // reflect the submesh number
	       //Clear the filename
	       filename.str("");
	       filename << doc_info.directory() << "/domain"
	                << d << "-" << doc_info.number() << ".dat";
	       domain_file[d]=new std::ofstream(filename.str().c_str());
	      }

	     // Doc
	     for (unsigned e=0;e<nelem;e++)
	      {
	       //If we can't cast to a finite element, we can't output because
	       //there is no output function
	       FiniteElement* f_el_pt =
	        dynamic_cast<FiniteElement*>(this->element_pt(e));
	       if(f_el_pt!=0)
	        {
	         f_el_pt->output(*domain_file[element_domain[e]],5);
	        }
	      }

	     for (int d=0;d<n_proc;d++)
	      {
	       domain_file[d]->close();
	       delete domain_file[d];
	       domain_file[d]=0;
	      }
	    }
	  }

	 // Loop over all elements, associate all
	 //--------------------------------------
	 // nodes with the highest-numbered processor and record all
	 //---------------------------------------------------------
	 // processors the node is associated with
	 //---------------------------------------

	 // Storage for processors in charge and processors associated with data
	 std::map<Data*,std::set<unsigned> > processors_associated_with_data;
	 std::map<Data*,unsigned> processor_in_charge;

	 // For all nodes set the processor in charge to zero
	 for (unsigned j=0;j<nnod;j++)
	  {
	   Node* nod_pt=this->node_pt(j);
	   processor_in_charge[nod_pt]=0;
	  }

	 // Loop over elements
	 for (unsigned e=0;e<nelem;e++)
	  {
	   // Get an element and its domain
	   FiniteElement* el_pt = dynamic_cast<FiniteElement*>(this->element_pt(e));
	   //Element will only have nodes if it is a finite element
	   if(el_pt!=0)
	    {
	     unsigned el_domain=element_domain[e];

	     // Associate nodes with highest numbered processor
	     unsigned nnod=el_pt->nnode();
	     for (unsigned j=0;j<nnod;j++)
	      {
	       Node* nod_pt=el_pt->node_pt(j);

	       // processor in charge was initialised to 0 above
	       if (el_domain>processor_in_charge[nod_pt])
	        {
	         processor_in_charge[nod_pt]=el_domain;
	        }
	       processors_associated_with_data[nod_pt].insert(el_domain);
	      }
	    }
	  }

	 // Doc the partitioning (only on processor 0)
	 //-------------------------------------------
	 if (doc_info.is_doc_enabled())
	  {
	   if (my_rank==0)
	    {
	     // Open files for doc of node partitioning
	     Vector<std::ofstream*> node_file(n_proc);
	     for (int d=0;d<n_proc;d++)
	      {
	       // Note: doc_info.number() was set in Problem::distribute(...) to
	       // reflect the submesh number...
	       //Clear the filename
	       filename.str("");
	       filename << doc_info.directory() << "/node"
	                << d << "-" << doc_info.number() << ".dat";
	       node_file[d]=new std::ofstream(filename.str().c_str());
	      }

	     // Doc
	     for (unsigned j=0;j<nnod;j++)
	      {
	       Node* nod_pt=this->node_pt(j);
	       const unsigned n_dim = nod_pt->ndim();
	       for(unsigned i=0;i<n_dim;i++)
	        {
	         *node_file[processor_in_charge[nod_pt]] << nod_pt->x(i) << " ";
	        }
	       *node_file[processor_in_charge[nod_pt]] << "\n";
	      }
	     for (int d=0;d<n_proc;d++)
	      {
	       node_file[d]->close();
	       delete node_file[d];
	       node_file[d]=0;
	      }
	    }
	  }

	 // Declare all nodes as obsolete. We'll
	 // change this setting for all nodes that must be retained
	 // further down
	 for (unsigned j=0;j<nnod;j++)
	  {
	   this->node_pt(j)->set_obsolete();
	  }


	 // Backup old mesh data and flush mesh
	 //-------------------------------------

	 // Backup pointers to elements in this mesh
	 Vector<GeneralisedElement*> backed_up_el_pt(nelem);
	 for (unsigned e=0;e<nelem;e++)
	  {
	   backed_up_el_pt[e]=this->element_pt(e);
	  }
	 
	 // Info. used to re-generate the boundary element scheme after the
	 // deletion of elements not belonging to the current processor)
	 
	 // Get the number of boundary elements before the deletion of non
	 // retained elements
	 const unsigned tmp_nboundary = this->nboundary();
	 Vector<unsigned> ntmp_boundary_elements(tmp_nboundary);
	 // In case that there are regions, also get the number of boundary
	 // elements in each region
	 Vector<Vector<unsigned> > ntmp_boundary_elements_in_region(tmp_nboundary);
	 // Also get the finite element version of the elements and back them
	 // up
	 Vector<FiniteElement*> backed_up_f_el_pt(nelem);
	 
	 // Only do this if the mesh is a TriangleMeshBase
	 TriangleMeshBase* triangle_mesh_pt = dynamic_cast<TriangleMeshBase*>(this);
	 bool is_a_triangle_mesh_base_mesh = false;
	 if (triangle_mesh_pt!=0)
	  {
	   // Set the flag to indicate we are working with a TriangleMeshBase
	   // mesh
	   is_a_triangle_mesh_base_mesh = true;
	   
	   // Are there regions?
	   const unsigned n_regions = triangle_mesh_pt->nregion();
	   
	   // Loop over the boundaries
	   for (unsigned ib = 0; ib < tmp_nboundary; ib++)
	    {
	     // Get the number of boundary elements
	     ntmp_boundary_elements[ib] = this->nboundary_element(ib);
	     
	     // Resize the container
	     ntmp_boundary_elements_in_region[ib].resize(n_regions);
	     
	     // Loop over the regions
	     for (unsigned rr = 0 ; rr < n_regions; rr++)
	      {
	       // Get the region id
	       const unsigned region_id = 
	        static_cast<unsigned>(triangle_mesh_pt->region_attribute(rr));
	       
	       // Store the number of element in the region (notice we are
	       // using the region index not the region id to refer to the
	       // region)
	       ntmp_boundary_elements_in_region[ib][rr] = 
	        triangle_mesh_pt->nboundary_element_in_region(ib, region_id);
	       
	      } // for (rr < n_regions)
	     
	    } // for (ib < tmp_nboundary)
	   
	   for (unsigned e=0;e<nelem;e++)
	    {
	     // Get the finite element version of the elements and back them
	     // up
	     backed_up_f_el_pt[e] = this->finite_element_pt(e);
	    }
	   
	  } // if (triangle_mesh_pt!=0)
	 
	 // Flush the mesh storage
	 this->flush_element_storage();
	 
	 // Delete any storage of external elements and nodes
	 this->delete_all_external_storage();
	 
	 // Boolean to indicate which element is to be retained
	 std::vector<bool> element_retained(nelem,false);
	 
	 // Storage for element numbers of root halo elements that will be
	 // retained on current processor: root_halo_element[p][j]
	 // stores the element number (in the order in which the elements are stored
	 // in backed_up_el_pt) of the j-th root halo element with processor
	 // p.
	 Vector<Vector<int> > root_halo_element(n_proc);
	 
	 // Dummy entry to make sure we always have something to send
	 for (int p=0;p<n_proc;p++)
	  {
	   root_halo_element[p].push_back(-1);
	  }

	 // Determine which elements are going to end up on which processor
	 //----------------------------------------------------------------
	 unsigned number_of_retained_elements=0;
	 
	 // Loop over all backed up elements
	 nelem=backed_up_el_pt.size();
	 for (unsigned e=0;e<nelem;e++)
	  {
	   // Get element and its domain
	   GeneralisedElement* el_pt=backed_up_el_pt[e];
	   unsigned el_domain=element_domain[e];

	   // If element is located on current processor add it back to the mesh
	   if (el_domain==unsigned(my_rank))
	    {
	     // Add element to current processor
	     element_retained[e]=true;
	     number_of_retained_elements++;
	    }
	   // Otherwise we may still need it if it's a halo element:
	   else
	    {
	     // If this current mesh has been told to keep all elements as halos,
	     // OR the element itself knows that it must be kept then
	     // keep it
	     if ((this->Keep_all_elements_as_halos) ||
	         (el_pt->must_be_kept_as_halo()))
	      {
	       if (!overrule_keep_as_halo_element_status)
	        {
	         // Add as root halo element whose non-halo counterpart is
	         // located on processor el_domain
	         if (!element_retained[e])
	          {
	           root_halo_element[el_domain].push_back(e);
	           element_retained[e]=true;
	           number_of_retained_elements++;
	          }
	        }
	      }
	     //Otherwise: Is one of the nodes associated with the current processor?
	     else
	      {
	       //Can only have nodes if this is a finite element
	       FiniteElement* finite_el_pt = dynamic_cast<FiniteElement*>(el_pt);
	       if(finite_el_pt!=0)
	        {
	         unsigned n_node = finite_el_pt->nnode();
	         for (unsigned n=0;n<n_node;n++)
	          {
	           Node* nod_pt=finite_el_pt->node_pt(n);

	           // Keep element? (use stl find?)
	           unsigned keep_it=false;
	           for (std::set<unsigned>::iterator
	                 it=processors_associated_with_data[nod_pt].begin();
	                it!=processors_associated_with_data[nod_pt].end();
	                it++)
	            {
	             if (*it==unsigned(my_rank))
	              {
	               keep_it=true;
	               //Break out of the loop over processors
	               break;
	              }
	            }

	           // Add a root halo element either if keep_it=true
	           if (keep_it)
	            {
	             // Add as root halo element whose non-halo counterpart is
	             // located on processor el_domain
	             if (!element_retained[e])
	              {
	               root_halo_element[el_domain].push_back(e);
	               element_retained[e]=true;
	               number_of_retained_elements++;
	              }
	             //Now break out of loop over nodes
	             break;
	            }
	          }
	        }
	      } //End of testing for halo by virtue of shared nodes
	    }//End of halo element conditions
	  } //end of loop over elements
	 
	 // First check that the number of elements is greater than zero, when
	 // working with submeshes it may be possible that some of them have
	 // no elements (face element meshes) since those may have been
	 // deleted in "Problem::actions_before_distribute()"
	 if (nelem > 0)
	  {
	   // Check that we are working with a TriangleMeshBase mesh, if
	   // that is the case then we need to create shared boundaries
	   if (is_a_triangle_mesh_base_mesh)
	    {
	     // Creation of shared boundaries
	     // ------------------------------
	     // All processors share the same boundary id for the created
	     // shared boundary. We need all the elements on all processors,
	     // that is why this step is performed before the deletion of the
	     // elements not associated to the current processor. 
	     // N.B.: This applies only to unstructured meshes
	     this->create_shared_boundaries(comm_pt, element_domain, 
	                                    backed_up_el_pt,
	                                    backed_up_f_el_pt,
	                                    processors_associated_with_data, 
	                                    overrule_keep_as_halo_element_status);
	    } // if (is_a_triangle_mesh_base_mesh)
	  } // if (nelem > 0)
	 
	 // NOTE: No need to add additional layer of halo elements.
	 //       Procedure for removing "overlooked" halo nodes in 
	 //       deals classify_halo_and_haloed_nodes() deals 
	 //       with the problem addressed here. [code that dealt with this
	 //       problem at distribution stage has been removed]
	 
	 // Store the finite element pointer version of the elements that are
	 // about to be deleted, used to reset the boundary elements info
	 Vector<FiniteElement*> deleted_f_element_pt;
	 
	 // Copy the elements associated with the actual
	 // current processor into its own permanent storage.
	 // Do it in the order in which the elements appeared originally
	 nelem=backed_up_el_pt.size();
	 for (unsigned e=0;e<nelem;e++)
	  {
	   GeneralisedElement* el_pt=backed_up_el_pt[e];
	   if (element_retained[e])
	    {
	     this->add_element_pt(el_pt);
	    }
	   else
	    {
	     // Flush the object attached to the tree for this element?
	     RefineableElement* ref_el_pt=dynamic_cast<RefineableElement*>(el_pt);
	     if (ref_el_pt!=0)
	      {
	       ref_el_pt->tree_pt()->flush_object();
	      }
	     
	     
	     // Store pointer to the element that's about to be deleted.
	     
	     // Only for structured meshes since this "deleted_element_pt"
	     // vector is used in the "problem" class to set null pointer to
	     // the deleted elements in the Base_mesh_element_pt structure
	     if (!is_a_triangle_mesh_base_mesh)
	      {
	       deleted_element_pt.push_back(el_pt);
	      } // if (!is_a_triangle_mesh_base_mesh)
	     
	     if (is_a_triangle_mesh_base_mesh)
	      {
	       // Store pointer to the finite element that's about to be deleted
	       deleted_f_element_pt.push_back(backed_up_f_el_pt[e]);
	      }
	     
	     // Delete the element
	     delete el_pt;
	    }
	  }

	 // Copy the root halo elements associated with the actual
	 // current processor into its own permanent storage; the order
	 // here is somewhat random but we compensate for that by
	 // ensuring that the corresponding haloed elements are
	 // added in the same order below
	#ifdef PARANOID
	 std::map<unsigned,bool> done;
	#endif
	 for (int d=0;d<n_proc;d++)
	  {
	   nelem=root_halo_element[d].size();
	   for (unsigned e=0;e<nelem;e++)
	    {
	     int number=root_halo_element[d][e];
	     if (number>=0)
	      {
	#ifdef PARANOID
	       if (done[number])
	        {
	         std::ostringstream error_message;
	         error_message
	          << "Have already added element " << number
	          << " as root halo element\n"
	          << std::endl;
	         throw OomphLibError(error_message.str(),
	                             OOMPH_CURRENT_FUNCTION,
	                             OOMPH_EXCEPTION_LOCATION);
	        }
	       done[number]=true;
	#endif
	       this->add_root_halo_element_pt(d,backed_up_el_pt[number]);
	      }
	    }
	  }


	 // Now get root haloed elements: root_haloed_element[p][j] stores
	 // the element number (in the order in which the elements are stored
	 // in backedup_el_pt) of the j-th rooted halo element with processor
	 // p. On proc my_proc this the same as root_haloed_element[my_proc][j]
	 // on processor p, so get the information by gatherv operations.
	 Vector<Vector<unsigned> > root_haloed_element(n_proc);

	 // Find out number of root halo elements with each other proc
	 Vector<int> nhalo(n_proc,0);
	 Vector<int> nhaloed(n_proc,0);
	 for (int p=0;p<n_proc;p++)
	  {
	   nhalo[p]=root_halo_element[p].size();
	  }

	 // Each processor sends number of halo elements it has with processor
	 // p to processor p where this information is stored in nhaloed[...]
	 for (int p=0;p<n_proc;p++)
	  {
	   // Gather the p-th entries in nhalo from every processor on
	   // processor p and store them in nhaloed consecutively
	   // starting at beginning
	   MPI_Gather(&nhalo[p], 1, MPI_INT,
	              &nhaloed[0], 1, MPI_INT,
	              p,comm_pt->mpi_comm());
	  }

	 // In the big sequence of concatenated root halo elements (enumerated
	 // individually on the various processors) where do the root halo
	 // elements from a given processor start? Also figure out how many
	 // root haloed elements there are in total by summing up their numbers
	 Vector<int> start_index(n_proc,0);
	 unsigned total_number_of_root_haloed_elements=0;
	 for (int i_proc=0; i_proc<n_proc; i_proc++)
	  {
	   total_number_of_root_haloed_elements+=nhaloed[i_proc];
	   if (i_proc!=0)
	    {
	     start_index[i_proc]=total_number_of_root_haloed_elements-
	      nhaloed[i_proc];
	    }
	   else
	    {
	     start_index[0]=0;
	    }
	  }

	 // Storage for all root haloed elements from the various processors, one
	 // after the other, with some padding from negative entries to avoid
	 // zero length vectors
	 Vector<int> all_root_haloed_element(total_number_of_root_haloed_elements,
	                                     0);

	 // Now send the ids of the relevant elements via gatherv
	 for (int p=0;p<n_proc;p++)
	  {
	   // Gather the p-th entries in nhalo from every processor on
	   // processor p and store them in nhaloed consecutively
	   // starting at beginning
	   MPI_Gatherv(&root_halo_element[p][0], // pointer to first entry in vector
	                                         // to be gathered on processor p
	               nhalo[p], // Number of entries to be sent
	               MPI_INT,
	               &all_root_haloed_element[0], // Target -- this will store
	                                            // the element numbers of
	                                            // all root haloed elements
	                                            // received from other processors
	                                            // in order
	               &nhaloed[0], // Pointer to the vector containing the lengths
	                            // of the vectors received from elsewhere
	               &start_index[0], // "offset" for storage of vector received
	                                // from various processors in the global
	                                // concatenated vector
	               MPI_INT,
	               p, // processor that gathers the information
	               comm_pt->mpi_comm());
	  }


	 // Determine root haloed elements
	 //-------------------------------

	 // Loop over all other processors
	 unsigned count=0;
	 for (int d=0;d<n_proc;d++)
	  {

	#ifdef PARANOID
	 std::map<unsigned,bool> done;
	#endif

	   // Loop over root haloed elements with specified processor
	   unsigned n=nhaloed[d];
	   for (unsigned e=0;e<n;e++)
	    {

	     int number=all_root_haloed_element[count];
	     count++;

	     // Ignore padded -1s that were only inserted to avoid
	     // zero sized vectors
	     if (number>=0)
	      {
	       // Get pointer to element
	       GeneralisedElement* el_pt=backed_up_el_pt[number];

	       // Halo elements can't be haloed themselves
	       if (!el_pt->is_halo())
	        {

	#ifdef PARANOID
	         if (done[number])
	          {
	           std::ostringstream error_message;
	           error_message
	            << "Have already added element " << number
	            << " as root haloed element\n"
	            << std::endl;
	           throw OomphLibError(error_message.str(),
	                               OOMPH_CURRENT_FUNCTION,
	                               OOMPH_EXCEPTION_LOCATION);
	          }
	         done[number]=true;
	#endif

	         // Current element is haloed by other processor
	         this->add_root_haloed_element_pt(d,el_pt);
	        }
	      }
	    }
	  }


	 // Doc stats
	 if (report_stats)
	  {
	   oomph_info << "Processor " << my_rank
	              << " holds " << this->nelement()
	              << " elements of which " << this->nroot_halo_element()
	              << " are root halo elements \n while "
	              << this->nroot_haloed_element()
	              << " are root haloed elements" << std::endl;
	  }


	 // Loop over all retained elements and mark their nodes
	 //-----------------------------------------------------
	 // as to be retained too (some double counting going on here)
	 //-----------------------------------------------------------
	 nelem=this->nelement();
	 for (unsigned e=0;e<nelem;e++)
	  {
	   FiniteElement* f_el_pt= dynamic_cast<FiniteElement*>(this->element_pt(e));

	   //If we have a finite element
	   if(f_el_pt!=0)
	    {
	     // Loop over nodes
	     unsigned nnod=f_el_pt->nnode();
	     for (unsigned j=0;j<nnod;j++)
	      {
	       Node* nod_pt=f_el_pt->node_pt(j);
	       nod_pt->set_non_obsolete();
	      }
	    }
	  }


	 //BEFORE we kill the dead nodes we need to remember which cells have to be saved (all those associated with a live node)
	 unsigned n_save_cell = 0;
	 std::vector<bool> cell_is_saved(NumCells, false);
	 //Loop over the nodes and delete the cells associated with those which are obsolete
	 for(unsigned i=0; i<this->nnode(); i++)
	 {
	 	if(!(this->node_pt(i)->is_obsolete()))
	 	{
	 		cell_is_saved[i] = true;
	 		n_save_cell++;
	 	}
	 }
	 
	 
	 // Now remove the pruned nodes
	 this->prune_dead_nodes();
	 
	 
	#ifdef OOMPH_HAS_TRIANGLE_LIB
	 if (is_a_triangle_mesh_base_mesh)
	  {
	   triangle_mesh_pt->
	    reset_boundary_element_info(ntmp_boundary_elements,
	                                ntmp_boundary_elements_in_region,
	                                deleted_f_element_pt);
	  } // if (tri_mesh_pt!=0)
	 else
	  {
	#endif // #ifdef OOMPH_HAS_TRIANGLE_LIB   
	   
	   // Temporarly set the mesh as distributed
	   this->setup_boundary_element_info();
	   
	#ifdef OOMPH_HAS_TRIANGLE_LIB
	  }
	#endif
	 
	 // Re-setup tree forest. (Call this every time even if
	 // a (distributed) mesh has no elements on this processor.
	 // We still need to participate in communication.)
	 TreeBasedRefineableMeshBase* ref_mesh_pt=
	  dynamic_cast<TreeBasedRefineableMeshBase*>(this);
	 if (ref_mesh_pt!=0)
	  {
	   ref_mesh_pt->setup_tree_forest();
	  }

	 // Classify nodes
	 classify_halo_and_haloed_nodes(doc_info,report_stats);

	  // Doc?
	 //-----
	 if (doc_info.is_doc_enabled())
	  {
	   doc_mesh_distribution(doc_info);
	  }


	 oomph_info << "Deleting cells after distribute " << this->nnode() << " " << this->nelement() << " " << NumCells << std::endl;

	 Vector<CellModelBaseFullySegregated*> new_cell_pt;
	 //Loop over the cells
	 for(unsigned i=0; i<NumCells; i++)
	 {
 	  //If the cell is one we should save, save it
 	  if(cell_is_saved[i])
	  {
		new_cell_pt.push_back(Cells_pt[i]);

		Cells_pt[i] = nullptr;
	  } 
	  else //Otherwise delete it
	  {
		delete (Cells_pt[i]);
		Cells_pt[i] = nullptr;
	  } 
	 }

	 oomph_info << "N save cell " << n_save_cell << std::endl;

	 //Re-generate the lookup tables for nodes and elements
	 BuildNodeElementTables();

	 //Clear the vector of cells
	 Cells_pt.clear();
	 NumCells=0;

	 //loop over them and reassign them to the correct nodes
	 for(unsigned i=0; i<n_save_cell; i++)
	 {

		//Get a pointer to the cell
		CellModelBaseFullySegregated* cell_pt = new_cell_pt[i];

		//Add it back to the vector of cells
		Cells_pt.push_back(cell_pt);

		//loop over the nodes and get the one which matches the pointer in the cell
		for(unsigned l=0; l<this->nnode(); l++)
		{
			//Get a pointer to the test node
			Node* nod_pt = this->node_pt(l);

			//If it is the node attached to the cell
			if(nod_pt == cell_pt->base_node_pt())
			{
				//Re attach the cell to the correct node
				add_cell_to_node(l, NumCells);
				//Stop checking nodes
				break;
			}

			//If we've reached the end we have been unable to find the node
			if(l==this->nnode())
			{
				throw OomphLibError("I can't locate the node attached to this cell for some reason",
									OOMPH_CURRENT_FUNCTION,
									OOMPH_EXCEPTION_LOCATION);
			}
		}

		NumCells++;
	 }
	 oomph_info << "Num nodes left " << this->nnode() << std::endl;
	 oomph_info << "Num non-halo nodes " << this->nnode() - this->nhalo_node() << std::endl;
	 oomph_info << "Num cells post rebuild " << NumCells << std::endl;

	 SetupDataIndices();
	}



};


}//End namespace

#endif