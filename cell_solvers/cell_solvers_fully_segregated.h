//LIC// ====================================================================
//LIC// 
//LIC//====================================================================


//Header file for CellInterface elements
#ifndef OOMPH_FULLY_SEGREGATED_CELL_SOLVER_ELEMENTS_HEADER
#define OOMPH_FULLY_SEGREGATED_CELL_SOLVER_ELEMENTS_HEADER

// Config header generated by autoconfig
#ifdef HAVE_CONFIG_H
	#include <oomph-lib-config.h>
#endif

//For the custom integration schemes
#include "../toms_utilities/toms_integral.h"


//OOMPH-LIB headers
#include "../generic/nodes.h"
#include "../generic/oomph_utilities.h"
#include "../generic/Qelements.h"
#include "../generic/Telements.h"
#include "../generic/error_estimator.h"
#include "../generic/problem.h"
#include "../generic/assembly_handler.h"


#include "../cell_models/cell_model_base.h"

#include "../cell_membrane_potential/cell_membrane_potential_elements.h"

#include <boost/tokenizer.hpp>

namespace oomph
{

//A wrapper class for the membrane potential equations defined in CONDUCTANCE_MODEL. Essentially provides suitably overriden version of the
// functions which get data from the cell model as well as lookup schemes for the cells associated with the nodes of the element.
template <class CONDUCTANCE_MODEL>
class FullySegregatedCellEquations : public virtual FiniteElement,
									public virtual CONDUCTANCE_MODEL,
									public virtual ConductingCellFunctionsBase
{
public:

	////General class functions

	//Constructor
	FullySegregatedCellEquations() : CONDUCTANCE_MODEL()
	{
		//Provide storage for the pointer to each cell associated with each node in the element
		Cell_associated_with_each_node_pt.resize(this->nnode(), nullptr);
	}

	//Destructor
	~FullySegregatedCellEquations()
	{

	}


	//Sometimes when generating a mesh from a list of elements and nodes the elements are inverted
	//To solve this we simply swap the first and second nodes, however this requires also
	//swapping the cell associated with the nodes as well so we provide a function to do it all for us
	void check_for_and_deal_with_inverted_jacobian()
	{
		//Check if it is negative
		bool jacobian_passed_test;
		this->check_J_eulerian_at_knots(jacobian_passed_test);
		//If it is, swap the first two node pointers
		if(!jacobian_passed_test){
			//Save a pointer to the first node
			Node* nod_pt = this->node_pt(0);


			//Swap the first and second nodes
			this->node_pt(0) = this->node_pt(1);
			this->node_pt(1) = nod_pt;


			//Now we need to swap the pointers to the cells for the nodes,
			// we do this and reapply the initial conditions - essentially we are
			// calling the build cell function again but without actually re-building
			// the cell

			//Swap the cells associated with the nodes since we have swapped the nodes
			CellModelBaseFullySegregated* cell_pt = Cell_associated_with_each_node_pt[0];
			Cell_associated_with_each_node_pt[0] = Cell_associated_with_each_node_pt[1];
			Cell_associated_with_each_node_pt[1] = cell_pt;

			//Reinform the cells what the local node and coordinates are in the element

			//First the first cell

			//Get the integral point and local and global coordinates of the node in the element
			//Integral point
			unsigned ipt = this->ipt_at_node(0);
			//Local coordinate
			Vector<double> s;
			this->local_coordinate_of_node(0, s);
			//Global coordinate
			Vector<double> x(this->dim());
			this->get_x(s, x);
			//add the element and local and global coordinates to the cell
			Cell_associated_with_each_node_pt[0]->set_my_element_and_coordinate(dynamic_cast<ConductingCellFunctionsBase*>(this),
																this->node_pt(0),
																Cell_associated_with_each_node_pt[0],
																this->vm_index_BaseCellMembranePotential(),
																ipt, s, x, 0);
			//Call the cell to assign initial conditions
			Cell_associated_with_each_node_pt[0]->assign_initial_conditions(true);


			//Then the second cell

			//Get the integral point and local and global coordinates of the node in the element
			//Integral point
			ipt = this->ipt_at_node(1);
			//Local coordinate
			this->local_coordinate_of_node(1, s);
			//Global coordinate
			this->get_x(s, x);
			//add the element and local and global coordinates to the cell
			Cell_associated_with_each_node_pt[1]->set_my_element_and_coordinate(dynamic_cast<ConductingCellFunctionsBase*>(this),
																this->node_pt(1),
																Cell_associated_with_each_node_pt[1],
																this->vm_index_BaseCellMembranePotential(),
																ipt, s, x, 1);
			//Call the cell to assign initial conditions
			Cell_associated_with_each_node_pt[1]->assign_initial_conditions(true);


			// oomph_info << "element " << e << " swapped nodes." << std::endl;
		}
	}


	//Get a pointer to the cell associated with the node
	CellModelBaseFullySegregated* get_cell_at_node_pt(const unsigned& l) const
	{
		return Cell_associated_with_each_node_pt[l];
	}


	//get the integration point associated with node n
	inline unsigned ipt_at_node(const unsigned &n) const
			{return ipt_not_at_nodes + n;}

	//The required amount of storage per node
	inline unsigned required_nvalue(const unsigned &n) const {
		return (CONDUCTANCE_MODEL::required_nvalue(n));
	}

	inline void add_cell_to_node(const unsigned &l, CellModelBaseFullySegregated* cell_pt){
		Cell_associated_with_each_node_pt[l] = cell_pt;
	}



	/////Get variables from cell model

	//Get Vm predicted from cell model
	inline double get_nodal_predicted_vm(const unsigned &l) const {
		//If the node has an associated cell then use that given by the cell model,
		//else just return the value at the node
		if(get_cell_at_node_pt(l)!=nullptr)
		{
			return get_cell_at_node_pt(l)->get_predicted_vm();
		}
		else
		{
			return this->get_nodal_membrane_potential_BaseCellMembranePotential(l);
		}
	}

	//Get Integral of Iion from cell model
	inline double get_nodal_integral_iion(const unsigned &l) const {
		//If the node has an associated cell then use that given by the cell model,
		//else just return the value zero
		if(get_cell_at_node_pt(l)!=nullptr)
		{
			return get_cell_at_node_pt(l)->get_Integral_Iion();
		}
		else
		{
			return 0.0;
		}
	}



	//Get active strain from cell model
	inline double get_nodal_active_strain(const unsigned &l) const {
		//If the node has an associated cell then use that given by the cell model,
		//else just return the value zero
		if(get_cell_at_node_pt(l)!=nullptr)
		{
			return get_cell_at_node_pt(l)->get_active_strain();
		}
		else
		{
			return 0.0;
		}
	}	

	//Get general data from cell at node - generally used for outputting but can be used for other things, such as communicating ion flux to an external element



	/////Send variables to cell model

	//Set cell type of cell at node
	void set_cell_type(const unsigned &l, const unsigned &cell_type){
		if(get_cell_at_node_pt(l)!=nullptr)
		{
			get_cell_at_node_pt(l)->set_cell_type(cell_type);
		}
	}

	//Send general data to cell at node
	inline void set_other_data_at_node(const unsigned &l, const unsigned &var, const double &value){
		if(get_cell_at_node_pt(l)!=nullptr)
		{
			get_cell_at_node_pt(l)->set_other_data(var, value);
		}
	}

	//Assign initial conditions - the cell model generally does this itself but we can override it by forcing it to use the variables this function sends instead
	inline void assign_initial_conditions(const unsigned&l, const Vector<double>& vals, const double& vm){
		if(get_cell_at_node_pt(l)!=nullptr)
		{
			get_cell_at_node_pt(l)->assign_initial_conditions(vals, vm);
		}
	}



	/////Interpolate data from the cell models

	//Get interpolated Vm predicted from cell model
	double get_interpolated_predicted_vm_from_cell_model(const Vector<double>& s) const {
		//The thing we are outputting
		double out = 0.0;
		//The shape function
		const unsigned n_node = this->nnode();
		Shape psi(n_node);
		shape(s,psi);
		//Loop over the nodes
		for(unsigned l=0; l<n_node; l++){
			out += psi[l]*get_nodal_predicted_vm(l);
		}

		return out;
	}


	//Overload this function of the conduction element in case it needs to do strang splitting
	double get_nodal_predicted_vm_BaseCellMembranePotential(const unsigned &l) const
	{	
		return get_nodal_predicted_vm(l);
	}


	//Overload this function of the conduction element in case it needs to do toms splitting method
	double get_nodal_integral_iion_BaseCellMembranePotential(const unsigned &l) const
	{	
		return get_nodal_integral_iion(l);
	}


	//Get interpolated active strain from cell model
	double get_interpolated_active_strain_from_cell_model(const Vector<double>& s) const {
		//The thing we are outputting
		double out = 0.0;
		//The shape function
		const unsigned n_node = this->nnode();
		Shape psi(n_node);
		shape(s,psi);
		//Loop over the nodes
		for(unsigned l=0; l<n_node; l++){
			out += psi[l]*get_nodal_active_strain(l);
		}

		return out;
	}


	// Get interpolated general data from cell model - this is dangerous, make sure that you are definitely interpolating the same data from all nodes in the element
	//													the issue arrises from that each node could be associated with different cell models, the general output data
	//													of which might not line up if you are not careful. I provide no safety checks for this, you are on your own.
	// void get_interpolated_general_output_from_cell_model(const Vector<double>& s, Vector<double> &Out) const {
	// 	Out.resize(Cell_associated_with_each_node_pt[0]->Num_Output_Data, 0.0);
	// 	#ifdef PARANOID
	// 	for(unsigned l=1; l<n_node; l++){
	// 		if(get_cell_at_node_pt(l)->Num_Output_Data != Cell_associated_with_each_node_pt[0]->Num_Output_Data)
	// 		{
	// 			throw OomphLibError(
	// 				"Number of output variables of nodes does not match",
	// 				OOMPH_CURRENT_FUNCTION,
	// 				OOMPH_EXCEPTION_LOCATION);
	// 		}
	// 	}
	// 	#endif

	// 	const unsigned n_node = this->nnode();
	// 	Shape psi(n_node);
	// 	shape(s,psi);

	// 	for(unsigned l=0; l<n_node; l++){
	// 		Vector<double> node_out(get_cell_at_node_pt(l)->Num_Output_Data, 0.0);
	// 		get_cell_at_node_pt(l)->get_optional_cell_output(l, node_out);
	// 		for(unsigned i=0; i<CELL_MODEL::Num_Output_Data; i++){
	// 			Out[i] += psi[l]*node_out[i];
	// 		}
	// 	}
	// }
	


	/////Set general node-wise data

	//Set general nodal parameters



	/////Fill in residuals and jacobian

	void fill_in_contribution_to_residuals(Vector<double> &residuals)
	{
		CONDUCTANCE_MODEL::fill_in_generic_residual_contribution_BaseCellMembranePotential(residuals, GeneralisedElement::Dummy_matrix,
																				GeneralisedElement::Dummy_matrix, 0);
	}

	void fill_in_contribution_to_jacobian(Vector<double> &residuals,
		                                   DenseMatrix<double> &jacobian)
	{	
		CONDUCTANCE_MODEL::fill_in_contribution_to_jacobian(residuals, jacobian);
		// fill_in_contribution_to_jacobian(residuals, jacobian);
	}

	void fill_in_contribution_to_jacobian_and_mass_matrix(Vector<double> &residuals, DenseMatrix<double> &jacobian,
															DenseMatrix<double> &mass_matrix)
	{
		//Broken - how can this be filled in for the cell variables? - Not obvious
		FiniteElement::fill_in_contribution_to_jacobian_and_mass_matrix(residuals, jacobian, mass_matrix);
	}




	unsigned nscalar_paraview() const
	{
		return 1;
	}

	void scalar_value_paraview(std::ofstream& file_out,
								const unsigned& i,
								const unsigned& nplot) const
	{
		//Vector of local coordinates
		Vector<double> s(this->dim());

		const unsigned n_node = this->nnode();
		// const unsigned vm_index = this->vm_index_BaseCellMembranePotential();
		Shape psi(n_node);
		DShape dpsidx(n_node,this->dim());

		// Loop over plot points
		unsigned num_plot_points=this->nplot_points_paraview(nplot);
		for (unsigned iplot=0;iplot<num_plot_points;iplot++){
			// Get local coordinates of plot point
			this->get_s_plot(iplot,nplot,s);

			if(i==0){
				file_out << this->interpolated_vm_BaseCellMembranePotential(s) << std::endl;
			}

			// Vector<double> out(2, 0.0);
			// get_interpolated_general_output_from_cell_model(s, out);
			// if( i==1 || i==2 ){
			// 	return out[i-1];
			// }
		}
	}

	void scalar_value_fct_paraview(std::ofstream& file_out,
									const unsigned& i,
									const unsigned& nplot,
									FiniteElement::SteadyExactSolutionFctPt
									exact_soln_pt) const
	{
		scalar_value_paraview(file_out,i,nplot);
	}

	std::string scalar_name_paraview(const unsigned& i) const
	{
		return "Transmembrane potential";
		// switch(i)
		// case(0) : return "Transmembrane potential";
		// case(1) : return "ActStrain";
		// case(2) : return "CellType";
	}



protected:
	//The number of integral points which are not additional ones placed at the nodes
	unsigned ipt_not_at_nodes;

private:
	//Pointer to the cell corresponding to each node in the element
	Vector<CellModelBaseFullySegregated*> Cell_associated_with_each_node_pt;
};













//Q Element
template<unsigned DIM, unsigned NNODE_1D, template<unsigned> class CONDUCTANCE_MODEL>
class QFullySegregatedCellElement : public virtual QElement<DIM, NNODE_1D>,
									public virtual FullySegregatedCellEquations<CONDUCTANCE_MODEL<DIM>>
{
private:

	inline static GaussWithNodes<DIM, NNODE_1D> NewIntegralScheme;

public:

	QFullySegregatedCellElement() : QElement<DIM, NNODE_1D>(),
									FullySegregatedCellEquations<CONDUCTANCE_MODEL<DIM>>()
	{
		//set the integration scheme to one with integral points aligned with the nodes
		// GaussWithNodes<DIM, NNODE_1D>* new_integral_pt = new GaussWithNodes<DIM, NNODE_1D>;
		// this->set_integration_scheme(new GaussWithNodes<DIM, NNODE_1D>);
		this->set_integration_scheme(&NewIntegralScheme);
		//set the number of integral points which are not aligned with nodes
		this->ipt_not_at_nodes = this->integral_pt()->nweight() - this->nnode();
	}

	QFullySegregatedCellElement(const QFullySegregatedCellElement<DIM, NNODE_1D, CONDUCTANCE_MODEL>& dummy){BrokenCopy::broken_copy("QFullySegregatedCellElement");}

	void operator=(const QFullySegregatedCellElement<DIM, NNODE_1D, CONDUCTANCE_MODEL>&){BrokenCopy::broken_assign("QFullySegregatedCellElement");}


	//====================================================================
	//Output functions
	//====================================================================
	/// Output with default number of plot points
	void output(std::ostream &outfile){
		FullySegregatedCellEquations<CONDUCTANCE_MODEL<DIM>>::output(outfile);
	}
	/// \short Output FE representation of soln: x,y,V_fct,[vars] or x,y,z,V_fct,[vars] at 
	/// nplot^DIM plot points
	void output(std::ostream &outfile, const unsigned &nplot){
		FullySegregatedCellEquations<CONDUCTANCE_MODEL<DIM>>::output(outfile, nplot);
	}
	/// C_style output with default number of plot points
	void output(FILE* file_pt){
		FullySegregatedCellEquations<CONDUCTANCE_MODEL<DIM>>::output(file_pt);
	}
	 /// \short C-style output FE representation of soln: x,y,V_fct,[vars] or x,y,z,V_fct,[vars] at 
	 /// n_plot^DIM plot points
	 void output(FILE* file_pt, const unsigned &n_plot){
	 	FullySegregatedCellEquations<CONDUCTANCE_MODEL<DIM>>::output(file_pt, n_plot);
	}

	//======================================================================
	/// \short Define the shape functions and test functions and derivatives
	/// w.r.t. global coordinates and return Jacobian of mapping.
	///
	/// Galerkin: Test functions = shape functions
	//======================================================================
	double dshape_and_dtest_eulerian_BaseCellMembranePotential(const Vector<double> &s,
														Shape &psi, 
														DShape &dpsidx,
														Shape &test, 
														DShape &dtestdx) const
	{
		//Call the geometrical shape functions and derivatives  
		double J = this->dshape_eulerian(s,psi,dpsidx);
		//Loop over the test functions and derivatives and set them equal to the
		//shape functions
		for(unsigned i=0;i<NNODE_1D;i++)
		{
			test[i] = psi[i]; 
			for(unsigned j=0;j<DIM;j++)
			{
				dtestdx(i,j) = dpsidx(i,j);
			}
		}
		//Return the jacobian
		return J;
	}

	//======================================================================
	/// Define the shape functions and test functions and derivatives
	/// w.r.t. global coordinates and return Jacobian of mapping.
	///
	/// Galerkin: Test functions = shape functions
	//======================================================================
	double dshape_and_dtest_eulerian_at_knot_BaseCellMembranePotential(const unsigned &ipt,
																Shape &psi, 
																DShape &dpsidx,
																Shape &test, 
																DShape &dtestdx) const
	{
		//Call the geometrical shape functions and derivatives  
		double J = this->dshape_eulerian_at_knot(ipt,psi,dpsidx);
		//Set the test functions equal to the shape functions (pointer copy)
		test = psi;
		dtestdx = dpsidx;
		//Return the jacobian
		return J;
	}

	double 	d2shape_and_d2test_eulerian_at_knot_BaseCellMembranePotential(const unsigned &ipt, 
																		Shape &psi, 
																		DShape &dpsidx, 
																		DShape &d2psidx,
																		Shape &test, 
																		DShape &dtestdx, 
																		DShape &d2testdx) const
	{
		const double J = this->d2shape_eulerian_at_knot(ipt, psi, dpsidx, d2psidx);
		test = psi;
		dtestdx = dpsidx;
		d2testdx = d2psidx;

		return J;
	}

};


template<unsigned NNODE_1D, unsigned DIM, template<unsigned> class CONDUCTANCE_MODEL>
class FaceGeometry<QFullySegregatedCellElement<DIM, NNODE_1D, CONDUCTANCE_MODEL> >:
	public virtual QElement<DIM-1, NNODE_1D>
{
public:
	FaceGeometry()	:	QElement<DIM-1, NNODE_1D>()	{}
};	

template<unsigned NNODE_1D, template<unsigned> class CONDUCTANCE_MODEL>
class FaceGeometry<QFullySegregatedCellElement<1, NNODE_1D, CONDUCTANCE_MODEL> >:
	public virtual PointElement
{
public:
	FaceGeometry()	:	PointElement()	{}
};






//T Element
template<unsigned DIM, unsigned NNODE_1D, template<unsigned> class CONDUCTANCE_MODEL>
class TFullySegregatedCellElement : public virtual TElement<DIM, NNODE_1D>,
									public virtual FullySegregatedCellEquations<CONDUCTANCE_MODEL<DIM>>
{
private:
	inline static TGaussWithNodes<DIM, NNODE_1D> NewIntegralScheme;
public:
	TFullySegregatedCellElement() : TElement<DIM, NNODE_1D>(),
									FullySegregatedCellEquations<CONDUCTANCE_MODEL<DIM>>()
	{
		//set the integration scheme to one with integral points aligned with the nodes
		// TGaussWithNodes<DIM, NNODE_1D>* new_integral_pt = new TGaussWithNodes<DIM, NNODE_1D>;
		// this->set_integration_scheme(new TGaussWithNodes<DIM, NNODE_1D>);
		this->set_integration_scheme(&NewIntegralScheme);
		//set the number of integral points which are not aligned with nodes
		this->ipt_not_at_nodes = this->integral_pt()->nweight() - this->nnode();
	}

	TFullySegregatedCellElement(const TFullySegregatedCellElement<DIM, NNODE_1D, CONDUCTANCE_MODEL>& dummy){BrokenCopy::broken_copy("TFullySegregatedCellElement");}

	void operator=(const TFullySegregatedCellElement<DIM, NNODE_1D, CONDUCTANCE_MODEL>&){BrokenCopy::broken_assign("TFullySegregatedCellElement");}


	//====================================================================
	//Output functions
	//====================================================================
	/// Output with default number of plot points
	void output(std::ostream &outfile){
		FullySegregatedCellEquations<CONDUCTANCE_MODEL<DIM>>::output(outfile);
	}
	/// \short Output FE representation of soln: x,y,V_fct,[vars] or x,y,z,V_fct,[vars] at 
	/// nplot^DIM plot points
	void output(std::ostream &outfile, const unsigned &nplot){
		FullySegregatedCellEquations<CONDUCTANCE_MODEL<DIM>>::output(outfile, nplot);
	}
	/// C_style output with default number of plot points
	void output(FILE* file_pt){
		FullySegregatedCellEquations<CONDUCTANCE_MODEL<DIM>>::output(file_pt);
	}
	 /// \short C-style output FE representation of soln: x,y,V_fct,[vars] or x,y,z,V_fct,[vars] at 
	 /// n_plot^DIM plot points
	 void output(FILE* file_pt, const unsigned &n_plot){
	 	FullySegregatedCellEquations<CONDUCTANCE_MODEL<DIM>>::output(file_pt, n_plot);
	}

	//======================================================================
	/// \short Define the shape functions and test functions and derivatives
	/// w.r.t. global coordinates and return Jacobian of mapping.
	///
	/// Galerkin: Test functions = shape functions
	//======================================================================
	double dshape_and_dtest_eulerian_BaseCellMembranePotential(const Vector<double> &s,
														Shape &psi, 
														DShape &dpsidx,
														Shape &test, 
														DShape &dtestdx) const
	{
		//Call the geometrical shape functions and derivatives  
		double J = this->dshape_eulerian(s,psi,dpsidx);
		//Loop over the test functions and derivatives and set them equal to the
		//shape functions
		for(unsigned i=0;i<NNODE_1D;i++)
		{
			test[i] = psi[i]; 
			for(unsigned j=0;j<DIM;j++)
			{
				dtestdx(i,j) = dpsidx(i,j);
			}
		}
		//Return the jacobian
		return J;
	}

	//======================================================================
	/// Define the shape functions and test functions and derivatives
	/// w.r.t. global coordinates and return Jacobian of mapping.
	///
	/// Galerkin: Test functions = shape functions
	//======================================================================
	double dshape_and_dtest_eulerian_at_knot_BaseCellMembranePotential(const unsigned &ipt,
																Shape &psi, 
																DShape &dpsidx,
																Shape &test, 
																DShape &dtestdx) const
	{
		//Call the geometrical shape functions and derivatives  
		double J = this->dshape_eulerian_at_knot(ipt,psi,dpsidx);
		//Set the test functions equal to the shape functions (pointer copy)
		test = psi;
		dtestdx = dpsidx;
		//Return the jacobian
		return J;
	}

	double 	d2shape_and_d2test_eulerian_at_knot_BaseCellMembranePotential(const unsigned &ipt, 
																		Shape &psi, 
																		DShape &dpsidx, 
																		DShape &d2psidx,
																		Shape &test, 
																		DShape &dtestdx, 
																		DShape &d2testdx) const
	{
		const double J = this->d2shape_eulerian_at_knot(ipt, psi, dpsidx, d2psidx);
		test = psi;
		dtestdx = dpsidx;
		d2testdx = d2psidx;

		return J;
	}

};


template<unsigned NNODE_1D, unsigned DIM, template<unsigned> class CONDUCTANCE_MODEL>
class FaceGeometry<TFullySegregatedCellElement<DIM, NNODE_1D, CONDUCTANCE_MODEL> >:
	public virtual TElement<DIM-1, NNODE_1D>
{
public:
	FaceGeometry()	:	TElement<DIM-1, NNODE_1D>()	{}
};	

template<unsigned NNODE_1D, template<unsigned> class CONDUCTANCE_MODEL>
class FaceGeometry<TFullySegregatedCellElement<1, NNODE_1D, CONDUCTANCE_MODEL> >:
	public virtual PointElement
{
public:
	FaceGeometry()	:	PointElement()	{}
};


















//Mesh base class which handles cell objects and provides suitable pointers to the cells to each element in the mesh
//NOTE this class requires the elements and nodes to already be constructed hence you MUST inherit from this class
// AFTER the mesh class
template<class CONDUCTANCE_MODEL>
class CellMeshBase : public virtual Mesh
{
private:
	//Work out what elements contain each 'global' node and which local node indexes correspond to these nodes.
	void BuildNodeElementTables()
	{
		//Original slow brute force method

		// //First we allocate suitable storage in the vectors
		// Elements_containing_node.resize(this->nnode());

		// //Next we loop over all the nodes
		// for(unsigned l=0; l<this->nnode(); l++){
		// 	//Get a pointer to the l-th node
		// 	Node* mesh_nod_pt = this->node_pt(l);

		// 	//Next loop over all the elements in the mesh
		// 	for(unsigned e=0; e<this->nelement(); e++){
		// 		//Get a pointer to the element
		// 		FiniteElement* elem_pt = this->finite_element_pt(e);

		// 		//Now we loop over the nodes in that element
		// 		for(unsigned l1=0; l1<elem_pt->nnode(); l1++){
		// 			//get a pointer to that element
		// 			Node* elem_nod_pt = elem_pt->node_pt(l1);

		// 			if(mesh_nod_pt==elem_nod_pt){
		// 				//If the pointers point to the same object then add the element and the local node number to the table
		// 				Elements_containing_node[l].push_back(std::pair<unsigned long, unsigned>(e, l1));
		// 			}
		// 		}
		// 	}
		// }


		//Much faster method

		oomph_info << "Building node-element/local node table" << std::endl;
		double t_start = TimingHelpers::timer();

		//First we allocate suitable storage in the vectors
		Elements_containing_node.resize(this->nnode());

		//Map of node pointers to global node number
		std::map<Node*, unsigned> Node_pt_to_global_number;
		//Build the map of node pointers to global node numbers
		for(unsigned l=0; l<this->nnode(); l++){
			//Get a pointer to the l-th node
			Node* nod_pt = this->node_pt(l);
			//Fill in the entry
			Node_pt_to_global_number[nod_pt] = l;
		}

		//Loop over all the elements in the mesh
		for(unsigned e=0; e<this->nelement(); e++){
			//get a pointer to the element
			FiniteElement* elem_pt = this->finite_element_pt(e);
			//Now we loop over the nodes in that element
			for(unsigned l1=0; l1<elem_pt->nnode(); l1++){
				//get a pointer to that element
				Node* elem_nod_pt = elem_pt->node_pt(l1);
				//Use the map setup earlier to determine what the global node number of the local node l1 is and fill in its entry of the table
				Elements_containing_node[Node_pt_to_global_number[elem_nod_pt]].push_back(std::pair<unsigned long, unsigned>(e, l1));
			}
		}


		// for(unsigned l=0; l<this->nnode(); l++){
		// 	oomph_info << "Node " << l << ": " << std::endl;
		// 	for(unsigned e=0; e<Elements_containing_node[l].size(); e++){
		// 		oomph_info << "\t" << Elements_containing_node[l][e].first << " " << Elements_containing_node[l][e].second << std::endl;
		// 	}
		// 	oomph_info << std::endl;
		// }


		double t_end = TimingHelpers::timer();
		oomph_info << "Done. It took me " << (t_end - t_start) << " seconds." << std::endl;

	}

protected:

	//Should you wish to change the way the mesh calculates the elements containing each node then use this function
	void Set_Elements_containing_node(const Vector<Vector<std::pair<unsigned long, unsigned>>> &new_vect)
	{
		Elements_containing_node = new_vect;
	}

	//This function is left virtual since the way in which cells are built on the mesh is entirely problem-dependent.
	// the helper function build_cell_at_node(...) is provided to handle all of the tricky communications, I strongly
	// recommend you use it, if you for any reason do not need to use it please let me know so I can change the functionality
	virtual void BuildCells()
	{
		throw OomphLibError(
			"I am attempting to build the cells in the mesh but you haven't overloaded the appropriate function",
			OOMPH_CURRENT_FUNCTION,
			OOMPH_EXCEPTION_LOCATION);
	}

	//Build a cell at the location of the l-th node in the mesh. We need to pass the cell by pointer to all elements which contain
	// the l-th node in the mesh and also pass one of these elements and the local coordinate of the node within that element
	// to the cell.
	template<class CELL_MODEL>
	void build_cell_at_node(const unsigned long& l)
	{
		//Build the cell
		Cells_pt.push_back(new CELL_MODEL);

		//Pass the cell by pointer to all of the elements containing the node
		for(unsigned i=0; i<Elements_containing_node[l].size(); i++){
			//Get a pointer to the i-th element containing the node
			CONDUCTANCE_MODEL* elem_pt = dynamic_cast<CONDUCTANCE_MODEL*>(this->element_pt(Elements_containing_node[l][i].first));
			//Add the pointer to the suitable entry in the vector of cell pointers in the element
			elem_pt->add_cell_to_node(Elements_containing_node[l][i].second, Cells_pt[NumCells]);
		}



		//Pass the element and node to the cell - we just take the first element number in the lookup table
		CONDUCTANCE_MODEL* elem_pt = dynamic_cast<CONDUCTANCE_MODEL*>(this->element_pt(Elements_containing_node[l][0].first));
		//Get the local node index in the element
		const unsigned node_ind = Elements_containing_node[l][0].second;

		//Get the integral point and local and global coordinates of the node in the element
		//Integral point
		const unsigned ipt = elem_pt->ipt_at_node(node_ind);
		//Local coordinate
		Vector<double> s;
		elem_pt->local_coordinate_of_node(node_ind, s);
		//Global coordinate
		Vector<double> x(elem_pt->dim());
		elem_pt->get_x(s, x);


		//add the element and local and global coordinates to the cell
		Cells_pt[NumCells]->set_my_element_and_coordinate(dynamic_cast<ConductingCellFunctionsBase*>(elem_pt),
															elem_pt->node_pt(node_ind),
															Cells_pt[NumCells],
															elem_pt->vm_index_BaseCellMembranePotential(),
															ipt, s, x, node_ind);

		//Call the cell to assign initial conditions
		Cells_pt[NumCells]->assign_initial_conditions(true);

		//Increment the number of cells
		NumCells++;
	}

	//Setup the indexes of where in the vector of cell data each cells data starts
	// Data is packaged as Vm_0, w_0, Vm_1, w_1, ... , Vm_n, w_n
	#ifdef OOMPH_HAS_MPI
	void SetupDataIndices()
	{
		//provide suitable storage
		Starting_Index_For_Data_Of_Cell.resize(NumCells, 0);

		//iterate through the cells other than the first, that one starts at 0
		for(unsigned c=1; c<NumCells; c++){
			//The index at which this cells data is stored
			Starting_Index_For_Data_Of_Cell[c] = ( Starting_Index_For_Data_Of_Cell[c-1] + (Cells_pt[c-1]->get_Num_Cell_Vars() + 1 + 1 + 1 + 1) );
		}

		//The total number of data associated with the cells
		Total_cell_data = ( Starting_Index_For_Data_Of_Cell[NumCells-1] + (Cells_pt[NumCells-1]->get_Num_Cell_Vars() + 1 + 1 + 1 + 1) );
	}
	#endif


	virtual void FinalizeMeshSetup()
	{
		//Setup node and element tables
		BuildNodeElementTables();

		//Build the cells in the mesh, this is a user overloaded function
		BuildCells();

		// oomph_info << Cells_pt.size() << std::endl;

		#ifdef OOMPH_HAS_MPI
		SetupDataIndices();
		#endif
	}


	//Vector of cells in the mesh
	Vector<CellModelBaseFullySegregated*> Cells_pt;
	
private:

	//The number of cells in the mesh
	unsigned long NumCells;

	//Vector containing vectors of element numbers containing each node in the mesh and the local node number of the node within that element
	// Global_Node_index[Element_Counter[Global_Element_Index, Local_Node_Index_Within_Element]]
	Vector<Vector<std::pair<unsigned long, unsigned>>> Elements_containing_node;

	#ifdef OOMPH_HAS_MPI
	//Indices in a vector containing all variables for the cells in the mesh of where each cells data begins
	Vector<unsigned long> Starting_Index_For_Data_Of_Cell;
	unsigned long Total_cell_data;
	#endif



public:
	//Access to the ith cell
	CellModelBaseFullySegregated* cell_pt(const unsigned& i){return Cells_pt[i];}

	inline unsigned num_cells() const {return NumCells;}

	CellMeshBase() : NumCells(0)
	{

	}

	~CellMeshBase()
	{
		//Kill all the cells
		for(unsigned c=0; c<NumCells; c++)
		{
			delete Cells_pt[c];
			Cells_pt[c] = 0;
		}
	}


	//Save the cell data to file, blank line means no node is associated with that node
	void save_cells_to_file(std::ofstream& out_file)
	{
		//Loop over the cells in the mesh

		//The cell number is the same as the node number.

		for(unsigned c=0; c<NumCells; c++)
		{
			CellModelBaseFullySegregated* cell_pt = Cells_pt[c];

			if(cell_pt != nullptr)
			{
				Vector<double> vect;
				cell_pt->save_state_to_vector(vect, true);

				for(unsigned i=0; i<vect.size(); i++)
				{
					out_file << vect[i] << " ";
				}

				//Also output the cell type
				cell_pt->output_cell_type(out_file);
			}

			out_file << std::endl;
		}
	}

	//Load the cell data from file and restore the cells from it
	void load_cells_from_file(std::ifstream& in_file)
	{
		oomph_info << "Loading cell data from file" << std::endl;
		//Read in the file line by line
		unsigned c=0;
		std::string line;
		while(std::getline(in_file, line))
		{
			//If the line is zero, skip it
			if(line.size()==0)
			{
				oomph_info << "line " << c << " is zero, skipping." << std::endl;
			}
			else
			{
				// oomph_info << "Line is non-zero" << std::endl;
				//read in the line to a big vector
				Vector<double> BigVector;

				std::istringstream iss(line);
				std::string str;
				while(iss >> str)
				{
					BigVector.push_back(std::atof(str.c_str()));
				}
				// oomph_info << BigVector.size() << " tokens in line" << std::endl;

				//Get up to the last one and put into a vector of variables
				Vector<double> vars_vect(BigVector.size()-1, 0.0);
				for(unsigned i=0; i<vars_vect.size(); i++)
				{
					vars_vect[i] = BigVector[i];
				}

				//The last one is the cell type
				const unsigned cell_type = (unsigned)BigVector[vars_vect.size()];

				Cells_pt[c]->restore_state_from_vector(vars_vect, true);
				Cells_pt[c]->set_cell_type(cell_type);

				Cells_pt[c]->accept_copy_variables_as_IC_values();
			}

			c++;
		}
	}


	void output_cells(const double &t, std::ostream &outfile)
	{
		for(unsigned c=0; c<NumCells; c++){
			// Cells_pt[c]->calculate_optional_output(t);

			Cells_pt[c]->output_global_coord(outfile);
			Cells_pt[c]->output_cell_type(outfile);
			Cells_pt[c]->output_cell_variables(outfile);
			Cells_pt[c]->output_additional_data(outfile);

			outfile << std::endl;
		}
	}


	void check_for_and_deal_with_inverted_elements()
	{
		//We check all of the elements
		for(unsigned e=0; e<this->nelement(); e++){
			dynamic_cast<CONDUCTANCE_MODEL*>(this->element_pt(e))->check_for_and_deal_with_inverted_jacobian();
		}

		//We have reordered some nodes so we need to regenerate the local and global node elements tables
		BuildNodeElementTables();
	}

	void reset_copy_variables_to_IC_values_for_all_cells_in_mesh()
	{
		//Loop over all of the cells in the mesh
		for(unsigned c=0; c<NumCells; c++)
		{
			Cells_pt[c]->reset_copy_variables_to_IC_values();
		}
	}

	void accept_copy_variables_as_IC_values_for_all_cells_in_mesh()
	{
		//Loop over all of the cells in the mesh
		for(unsigned c=0; c<NumCells; c++)
		{
			Cells_pt[c]->accept_copy_variables_as_IC_values();
		}
	}


	//Store all the cell data from the mesh in a vector,
	// boolean determines whether or not the membrane potential comes from the cells or the underlying nodes
	void store_all_cell_data_from_mesh_in_vector(Vector<double> &Cell_Data, const bool &use_node_vm)
	{
		//Resize the storage vector
		Cell_Data.resize(Total_cell_data, 0.0);

		//Loop over the cells
		for(unsigned c=0; c<NumCells; c++)
		{
			//Save the single cell data to a vector
			Vector<double> single_cell_data;
			Cells_pt[c]->save_state_to_vector(single_cell_data, use_node_vm);

			//Loop over the data from the cell and put it into the big vector
			for(unsigned i=Starting_Index_For_Data_Of_Cell[c]; i<((c<NumCells-1) ? Starting_Index_For_Data_Of_Cell[c+1] : Total_cell_data); i++)
			{
				Cell_Data[i] = single_cell_data[i-Starting_Index_For_Data_Of_Cell[c]];
			}
		}
	}


	void restore_all_cell_data_from_mesh_from_vector(Vector<double> &Cell_Data)
	{
		//Loop over the cells
		for(unsigned c=0; c<NumCells; c++)
		{
			// std::cout << c << std::endl;
			//Update the cell from the combined data vector
			std::vector<double>::const_iterator first = Cell_Data.begin() + Starting_Index_For_Data_Of_Cell[c];
			std::vector<double>::const_iterator last = Cell_Data.begin() + ((c<NumCells-1) ? Starting_Index_For_Data_Of_Cell[c+1] : Total_cell_data);
			std::vector<double> projected_cell_data(first, last);
			Cells_pt[c]->restore_state_from_vector(projected_cell_data, true);
		}
	}


	void Take_time_step_with_all_cells_in_mesh(const double& dt,
												Problem* problem_pt,
												const bool &use_node_vm_as_initial_value = false,
												const bool &update_underlying_node_value_post_solve = false)
	{
		#ifdef OOMPH_HAS_MPI
		if(problem_pt->communicator_pt()->nproc() == 1)
		{
		#endif
			//If there is only one processor or we are running in serial then do it serially

			oomph_info << "Performing a serial timestep for all cells in a mesh" << std::endl;
			double t_start = TimingHelpers::timer();

			//Loop over all of the cells in the mesh
			for(unsigned c=0; c<NumCells; c++){
				// oomph_info << "Cell " << c << std::endl;
				//Take a timestep
				Cells_pt[c]->TakeTimestep(problem_pt->time_pt()->time(), dt, use_node_vm_as_initial_value);
				if(update_underlying_node_value_post_solve)
				{
					Cells_pt[c]->update_underlying_node_membrane_potential();
				}
			}
			double t_end = TimingHelpers::timer();
			oomph_info << "Done. It took me " << (t_end-t_start) << " seconds to complete." << std::endl;

		#ifdef OOMPH_HAS_MPI
		}
		else
		{
			//If we are compiled with parallel and we have more than one processor then run in parallel
			oomph_info << "Performing a parallel timestep for all cells in a mesh" << std::endl;
			const double t_start = TimingHelpers::timer();

			//Set up the local vector of new cell variables
			Vector<double> Local_Cell_Data(Total_cell_data, 0.0);
			//Set up the vector of combined data across all processors
			Vector<double> Combined_Cell_Data(Total_cell_data, 0.0);

			Vector<unsigned> Local_cell_is_computed(NumCells, 0);
			Vector<unsigned> Combined_cell_is_computed(NumCells, 0);

			//Loop over the cells
			for(unsigned c=0; c<NumCells; c++)
			{
				//If it is one we are to compute then compute it
				if(c%problem_pt->communicator_pt()->nproc() != problem_pt->communicator_pt()->my_rank()) continue;
				// oomph_info << "Cell " << c << std::endl;
				Local_cell_is_computed[c]++;
				Cells_pt[c]->TakeTimestep(problem_pt->time_pt()->time(), dt, use_node_vm_as_initial_value);
				//Save the solution to the local vector
				Vector<double> single_cell_data;
				Cells_pt[c]->save_state_to_vector(single_cell_data);
				for(unsigned i=Starting_Index_For_Data_Of_Cell[c]; i<((c<NumCells-1) ? Starting_Index_For_Data_Of_Cell[c+1] : Total_cell_data); i++)
				{
					Local_Cell_Data[i] = single_cell_data[i-Starting_Index_For_Data_Of_Cell[c]];
				}
			}

			const double t_end_solve = TimingHelpers::timer();
			oomph_info << "Actual solve took " << (t_end_solve-t_start) << " seconds." << std::endl;

			//Mpi All reduce
			MPI_Allreduce(Local_Cell_Data.data(), Combined_Cell_Data.data(), Total_cell_data, MPI_DOUBLE, MPI_SUM, problem_pt->communicator_pt()->mpi_comm());


			MPI_Allreduce(Local_cell_is_computed.data(), Combined_cell_is_computed.data(), NumCells, MPI_UNSIGNED, MPI_SUM, problem_pt->communicator_pt()->mpi_comm());


			const double t_end_reduce = TimingHelpers::timer();
			oomph_info << "All reduce took " << (t_end_reduce-t_end_solve) << " seconds." << std::endl;

			//Loop over the cells
			for(unsigned c=0; c<NumCells; c++)
			{
				if(Combined_cell_is_computed[c]!=1)
				{
					std::ostringstream error_message;
					error_message << "Cell " << std::to_string(c) << " is not computed" << std::endl;
					throw OomphLibError(error_message.str(),
										OOMPH_CURRENT_FUNCTION,
										OOMPH_EXCEPTION_LOCATION);
				}
				//Update the cell from the combined data vector
				std::vector<double>::const_iterator first = Combined_Cell_Data.begin() + Starting_Index_For_Data_Of_Cell[c];
				std::vector<double>::const_iterator last = Combined_Cell_Data.begin() + ((c<NumCells-1) ? Starting_Index_For_Data_Of_Cell[c+1] : Total_cell_data);
				std::vector<double> projected_cell_data(first, last);
				Cells_pt[c]->restore_state_from_vector(projected_cell_data, update_underlying_node_value_post_solve);
			}

			const double t_end_communicate = TimingHelpers::timer();
			oomph_info << "Communicate took " << (t_end_communicate-t_end_reduce) << " seconds." << std::endl;

			const double t_end = TimingHelpers::timer();
			oomph_info << "Done. It took me " << (t_end-t_start) << " seconds to complete." << std::endl;
		}
		#endif


		//Check for nans
		//Loop over the cells
		// for(unsigned c=0; c<NumCells; c++)
		// {
		// 	if(!std::isfinite(Cells_pt[c]->get_predicted_vm()))
		// 	{
		// 		oomph_info << "At t=" << problem_pt->time_pt()->time() << ": Cell " << c << " vm is non-finite" << std::endl;
		// 	}

		// 	for(unsigned i=0; i<Cells_pt[c]->get_Num_Cell_Vars(); i++)
		// 	{
		// 		if(!std::isfinite(Cells_pt[c]->get_cell_variable(i)))
		// 		{
		// 			oomph_info << "At t=" << problem_pt->time_pt()->time() << ": Cell " << c << " variable " << i << " is non-finite" << std::endl;
		// 		}
		// 	}
		// }

	}

};


}//End namespace

#endif