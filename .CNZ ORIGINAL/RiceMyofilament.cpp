#include "RiceMyofilament.hpp"

#include <cmath>



RiceMyofilament::RiceMyofilament(double usr_SLset, double usr_SLrest)
    : SLset(usr_SLset),
      SLrest(usr_SLrest) {
    InitialiseMyofilamentStates();
    dN = dXBprer = dXBpostr = dSL = 0.0;
    dxXBpostr = dxXBprer = dTRPNCaL =  dTRPNCaH = dintf = 0.0;
    EngineeringStrain = 0.0;
}


void RiceMyofilament::SetSLrest(double usr_SLrest) {
    SLrest = usr_SLrest;
}

void RiceMyofilament::SetSLset(double usr_SLset) {
    SLset = usr_SLset;
}


void RiceMyofilament::InitialiseMyofilamentStates() {
    N        = 0.97;  // N
    XBprer   = 0.01;   // XBprer
    XBpostr  = 0.01;   // XBpostr
    SL       = SLset;   // SL
    xXBpostr = x_0;   // xXBpostr
    xXBprer  = 0.0;   // xXBprer
    TRPNCaL  = 0.01447254;   // TropCaL
    TRPNCaH  = 0.2320947;   // TropCaH
    intf     = 0.0;   // intergral of force, normallised
}

double RiceMyofilament::MyofilamentODE(const double Cai) {

    double P        = 1 - N - XBprer - XBpostr; //
    //   Compute single overlap fractions
    double sovr_ze   = std::min(len_thick / 2, SL / 2);       //   z-line end
    double sovr_cle = std::max(SL / 2 - (SL - len_thin), len_hbare / 2); //   centerline of end
    double len_sovr  = sovr_ze - sovr_cle;               //   single overlap length
    double SOVFThick = len_sovr * 2 / (len_thick - len_hbare); //   thick filament overlap frac
    double SOVFThin  = len_sovr / len_thin;              //   thin filament overlap frac

    //   Compute combined Ca binding to high- (w/XB) and low- (no XB) sites
    double Tropreg = (1 - SOVFThin) * TRPNCaL + SOVFThin * TRPNCaH;
    double permtot = sqrt(1 / (1 + pow((perm50 / Tropreg), nperm)));
    double inprmt = std::min(1.0 / permtot, 100.0);

    //   Adjustments for Ca activation, temperature, SL, stress and strain
    double konT    = kon /** pow(Qkon, ((Temp - 310.0) / 10.0))*/;
    double koffLT  = koffL /** pow(Qkoff, ((Temp - 310.0) / 10.0))*/ * koffmod;
    double koffHT  = koffH /** pow(Qkoff, ((Temp - 310.0) / 10.0))*/ * koffmod;
    double kn_pT   = kn_p * permtot /** pow(Qkn_p, ((Temp - 310.0) / 10.0))*/;
    double kp_nT   = kp_n * inprmt /** pow(Qkp_n, ((Temp - 310.0) / 10.0))*/;
    double fappT   = fapp * xbmodsp /** pow(Qfapp, ((Temp - 310.0) / 10.0))*/;
    double gapslmd = 1 + (1 - SOVFThick) * gslmod;
    double gappT   = gapp * gapslmd * xbmodsp /** pow(Qgapp, ((Temp - 310.0) / 10.0))*/;
    double hfmd    = exp(-sign(xXBprer) * hfmdc * ((xXBprer / x_0) * (xXBprer / x_0)));
    double hbmd    = exp(sign((xXBpostr - x_0)) * hbmdc * (((xXBpostr - x_0) / x_0) * ((xXBpostr - x_0) / x_0)));
    double hfT     = hf * hfmd * xbmodsp /** pow(Qhf, ((Temp - 310.0) / 10.0))*/;
    double hbT     = hb * hbmd * xbmodsp /** pow(Qhb, ((Temp - 310.0) / 10.0))*/;
    double gxbmd   = heav(x_0 - xXBpostr) * exp(sigmap * ((x_0 - xXBpostr) / x_0) * ((x_0 - xXBpostr) / x_0))
                     + (1 - heav(x_0 - xXBpostr)) * exp(sigman * (((xXBpostr - x_0) / x_0) * ((xXBpostr - x_0) / x_0)));
    double gxbT    = gxb * gxbmd * xbmodsp /** pow(Qgxb, ((Temp - 310.0) / 10.0))*/;

    //   Regulation and corssbridge cycling state derivatives
    dTRPNCaL  = konT * Cai * (1 - TRPNCaL) - koffLT * TRPNCaL;
    dTRPNCaH  = konT * Cai * (1 - TRPNCaH) - koffHT * TRPNCaH;
    // double dN_NoXB   = -kn_pT * N_NoXB + kp_nT * P_NoXB;
    // double dP_NoXB   = -kp_nT * P_NoXB + kn_pT * N_NoXB;
    dN        = -kn_pT * N + kp_nT * P;
    // double //   dP      = -kp_nT*P + kn_pT*N - fappT*P + gappT*XBprer + gxbT*XBpostr;
    dXBprer   = fappT * P - gappT * XBprer - hfT * XBprer + hbT * XBpostr;
    dXBpostr  = hfT * XBprer - hbT * XBpostr - gxbT * XBpostr;
    // double dP        = -(dN + dXBprer + dXBpostr);

    //   steady-state fractions in XBprer and XBpostr using King-Altman rule
    double SSXBprer = (hb * fapp + gxb * fapp) / (gxb * hf + fapp * hf + gxb * gapp + hb * fapp + hb * gapp + gxb * fapp);
    double SSXBpostr = fapp * hf / (gxb * hf + fapp * hf + gxb * gapp + hb * fapp + hb * gapp + gxb * fapp);
    //   normalization for scaling active and passive force (maximal force)
    double Fnordv = kxb * x_0 * SSXBpostr;

    //   Calculate Forces (active, passive, preload, afterload)
    double force = kxb * SOVFThick * (xXBpostr * XBpostr + xXBprer * XBprer);
    double active = force / Fnordv;
    Force = force;
    NormalizedForce = active;
    double ppforce_c = heav(SL - SL_c) * PCon_c * (exp(PExp_c * fabs(SL - SL_c)) - 1);

    double ppforce_t = sign(SL - SLrest) * PCon_t *(exp(PExp_t *fabs((SL - SLrest))) - 1);
    // if (Rice_Usr_para.singlecell == False) ppforce_t += std::max(0, (PCon_c * exp(PExp_c * (SL - SL_c))));

    // Assume initial is generated by a preload force to counteract passive force
    // Preload force is computed here
    double PreloadF = sign((SLset - SLrest)) * PCon_t *(exp(PExp_t *fabs((SLset - SLrest))) - 1.0);
    // if (Rice_Usr_para.singlecell == False) PreloadF += std::max(0, (PCon_c * exp(PExp_c * (SLset - SL_c))));

    double ppforce = ppforce_t + ppforce_c;
    // ppforce += std::max(0, (PCon_c * exp(PExp_c * (SL - SL_c))));
    double preload = sign(SLset - SLrest) * PCon_t *(exp(PExp_t *fabs(SLset - SLrest)) - 1);
    // printf("%f\n", preload);
    preload = PreloadF;
    // preload += std::max(0, (PCon_c * exp(PExp_c * (SLset - SL_c))));
    double afterload = 0;  // either static constant or due to series elastic element
    /*if (Rice_Usr_para.SEon == True) {
        afterload = KSE * (SLset - SL);
    }
    */

    dintf = /*(1 - Rice_Usr_para.SEon_LengthClamp) **/ (-ppforce + preload - active + afterload); //   total force
    dSL = /*(1 - Rice_Usr_para.SEon_LengthClamp)**/((intf + (SLset - SL) * visc) / massf) * heav(SL - SLmin) * heav(SLmax - SL);
    //   Mean strain of strongly-bound states due to SL motion and XB cycling
    double dutyprer  = (hbT * fappT + gxbT * fappT)  //   duty fractions using the
                       / (fappT * hfT + gxbT * hfT + gxbT * gappT + hbT * fappT + hbT * gappT + gxbT * fappT);
    double dutypostr = fappT * hfT              //   King-Alman Rule
                       / (fappT * hfT + gxbT * hfT + gxbT * gappT + hbT * fappT + hbT * gappT + gxbT * fappT);
    dxXBprer = dSL / 2.0 + xPsi / dutyprer * (-xXBprer * fappT + (xXBpostr - x_0 - xXBprer) * hbT);
    dxXBpostr = dSL / 2.0 + xPsi / dutypostr * (x_0 + xXBprer - xXBpostr) * hfT;

    //   Ca buffering by low-affinity troponin C (LTRPNCa)
    double FrSBXB    = (XBpostr + XBprer) / (SSXBpostr + SSXBprer);
    double dFrSBXB   = (dXBpostr + dXBprer) / (SSXBpostr + SSXBprer);

    double dsovr_ze  = -dSL / 2.0 * heav(len_thick - SL);
    double dsovr_cle = -dSL / 2.0 * heav((2.0 * len_thin - SL) - len_hbare);
    double dlen_sovr = dsovr_ze - dsovr_cle;
    double dSOVFThin = dlen_sovr / len_thin;
    double dSOVFThick = 2.0 * dlen_sovr / (len_thick - len_hbare);

    double TropToT = Trop_conc * ((1 - SOVFThin) * TRPNCaL
                                  + SOVFThin * (FrSBXB * TRPNCaH + (1 - FrSBXB) * TRPNCaL));
    double dTropToT = Trop_conc * (-dSOVFThin * TRPNCaL + (1 - SOVFThin) * dTRPNCaL
                                   + dSOVFThin * (FrSBXB * TRPNCaH + (1 - FrSBXB) * TRPNCaL)
                                   + SOVFThin * (dFrSBXB * TRPNCaH + FrSBXB * dTRPNCaH - dFrSBXB * TRPNCaL
                                           + (1 - FrSBXB) * dTRPNCaL));
    /*double dforce = kxb * dSOVFThick * (xXBpostr * XBpostr + xXBprer * XBprer)
                    + kxb * SOVFThick * (dxXBpostr * XBpostr + xXBpostr * dXBpostr
                                         + dxXBprer * XBprer + xXBprer * dXBprer);*/
    return dTropToT;
}

double RiceMyofilament::MyofilamentODETemperature(const double Cai) {

    double P        = 1 - N - XBprer - XBpostr; //
    //   Compute single overlap fractions
    double sovr_ze   = std::min(len_thick / 2, SL / 2);       //   z-line end
    double sovr_cle = std::max(SL / 2 - (SL - len_thin), len_hbare / 2); //   centerline of end
    double len_sovr  = sovr_ze - sovr_cle;               //   single overlap length
    double SOVFThick = len_sovr * 2 / (len_thick - len_hbare); //   thick filament overlap frac
    double SOVFThin  = len_sovr / len_thin;              //   thin filament overlap frac

    //   Compute combined Ca binding to high- (w/XB) and low- (no XB) sites
    double Tropreg = (1 - SOVFThin) * TRPNCaL + SOVFThin * TRPNCaH;
    double permtot = sqrt(1 / (1 + pow((perm50 / Tropreg), nperm)));
    double inprmt = std::min(1.0 / permtot, 100.0);

    //   Adjustments for Ca activation, temperature, SL, stress and strain
    double konT    = kon * pow(Qkon, ((Temp - 310.0) / 10.0));
    double koffLT  = koffL * pow(Qkoff, ((Temp - 310.0) / 10.0)) * koffmod;
    double koffHT  = koffH * pow(Qkoff, ((Temp - 310.0) / 10.0)) * koffmod;
    double kn_pT   = kn_p * permtot * pow(Qkn_p, ((Temp - 310.0) / 10.0));
    double kp_nT   = kp_n * inprmt * pow(Qkp_n, ((Temp - 310.0) / 10.0));
    double fappT   = fapp * xbmodsp * pow(Qfapp, ((Temp - 310.0) / 10.0));
    double gapslmd = 1 + (1 - SOVFThick) * gslmod;
    double gappT   = gapp * gapslmd * xbmodsp * pow(Qgapp, ((Temp - 310.0) / 10.0));
    double hfmd    = exp(-sign(xXBprer) * hfmdc * ((xXBprer / x_0) * (xXBprer / x_0)));
    double hbmd    = exp(sign((xXBpostr - x_0)) * hbmdc * (((xXBpostr - x_0) / x_0) * ((xXBpostr - x_0) / x_0)));
    double hfT     = hf * hfmd * xbmodsp * pow(Qhf, ((Temp - 310.0) / 10.0));
    double hbT     = hb * hbmd * xbmodsp * pow(Qhb, ((Temp - 310.0) / 10.0));
    double gxbmd   = heav(x_0 - xXBpostr) * exp(sigmap * ((x_0 - xXBpostr) / x_0) * ((x_0 - xXBpostr) / x_0))
                     + (1 - heav(x_0 - xXBpostr)) * exp(sigman * (((xXBpostr - x_0) / x_0) * ((xXBpostr - x_0) / x_0)));
    double gxbT    = gxb * gxbmd * xbmodsp * pow(Qgxb, ((Temp - 310.0) / 10.0));

    //   Regulation and corssbridge cycling state derivatives
    dTRPNCaL  = konT * Cai * (1 - TRPNCaL) - koffLT * TRPNCaL;
    dTRPNCaH  = konT * Cai * (1 - TRPNCaH) - koffHT * TRPNCaH;
    // double dN_NoXB   = -kn_pT * N_NoXB + kp_nT * P_NoXB;
    // double dP_NoXB   = -kp_nT * P_NoXB + kn_pT * N_NoXB;
    dN        = -kn_pT * N + kp_nT * P;
    // double //   dP      = -kp_nT*P + kn_pT*N - fappT*P + gappT*XBprer + gxbT*XBpostr;
    dXBprer   = fappT * P - gappT * XBprer - hfT * XBprer + hbT * XBpostr;
    dXBpostr  = hfT * XBprer - hbT * XBpostr - gxbT * XBpostr;
    // double dP        = -(dN + dXBprer + dXBpostr);

    //   steady-state fractions in XBprer and XBpostr using King-Altman rule
    double SSXBprer = (hb * fapp + gxb * fapp) / (gxb * hf + fapp * hf + gxb * gapp + hb * fapp + hb * gapp + gxb * fapp);
    double SSXBpostr = fapp * hf / (gxb * hf + fapp * hf + gxb * gapp + hb * fapp + hb * gapp + gxb * fapp);
    //   normalization for scaling active and passive force (maximal force)
    double Fnordv = kxb * x_0 * SSXBpostr;

    //   Calculate Forces (active, passive, preload, afterload)
    double force = kxb * SOVFThick * (xXBpostr * XBpostr + xXBprer * XBprer);
    double active = force / Fnordv;
    Force = force;
    NormalizedForce = active;
    double ppforce_c = heav(SL - SL_c) * PCon_c * (exp(PExp_c * fabs(SL - SL_c)) - 1);

    double ppforce_t = sign(SL - SLrest) * PCon_t *(exp(PExp_t *fabs((SL - SLrest))) - 1);
    // if (Rice_Usr_para.singlecell == False) ppforce_t += std::max(0, (PCon_c * exp(PExp_c * (SL - SL_c))));

    // Assume initial is generated by a preload force to counteract passive force
    // Preload force is computed here
    double PreloadF = sign((SLset - SLrest)) * PCon_t *(exp(PExp_t *fabs((SLset - SLrest))) - 1.0);
    // if (Rice_Usr_para.singlecell == False) PreloadF += std::max(0, (PCon_c * exp(PExp_c * (SLset - SL_c))));

    double ppforce = ppforce_t + ppforce_c;
    // ppforce += std::max(0, (PCon_c * exp(PExp_c * (SL - SL_c))));
    double preload = sign(SLset - SLrest) * PCon_t *(exp(PExp_t *fabs(SLset - SLrest)) - 1);
    // printf("%f\n", preload);
    preload = PreloadF;
    // preload += std::max(0, (PCon_c * exp(PExp_c * (SLset - SL_c))));
    double afterload = 0;  // either static constant or due to series elastic element
    /*if (Rice_Usr_para.SEon == True) {
        afterload = KSE * (SLset - SL);
    }
    */

    dintf = /*(1 - Rice_Usr_para.SEon_LengthClamp) **/ (-ppforce + preload - active + afterload); //   total force
    dSL = /*(1 - Rice_Usr_para.SEon_LengthClamp)**/((intf + (SLset - SL) * visc) / massf) * heav(SL - SLmin) * heav(SLmax - SL);
    //   Mean strain of strongly-bound states due to SL motion and XB cycling
    double dutyprer  = (hbT * fappT + gxbT * fappT)  //   duty fractions using the
                       / (fappT * hfT + gxbT * hfT + gxbT * gappT + hbT * fappT + hbT * gappT + gxbT * fappT);
    double dutypostr = fappT * hfT              //   King-Alman Rule
                       / (fappT * hfT + gxbT * hfT + gxbT * gappT + hbT * fappT + hbT * gappT + gxbT * fappT);
    dxXBprer = dSL / 2.0 + xPsi / dutyprer * (-xXBprer * fappT + (xXBpostr - x_0 - xXBprer) * hbT);
    dxXBpostr = dSL / 2.0 + xPsi / dutypostr * (x_0 + xXBprer - xXBpostr) * hfT;

    //   Ca buffering by low-affinity troponin C (LTRPNCa)
    double FrSBXB    = (XBpostr + XBprer) / (SSXBpostr + SSXBprer);
    double dFrSBXB   = (dXBpostr + dXBprer) / (SSXBpostr + SSXBprer);

    double dsovr_ze  = -dSL / 2.0 * heav(len_thick - SL);
    double dsovr_cle = -dSL / 2.0 * heav((2.0 * len_thin - SL) - len_hbare);
    double dlen_sovr = dsovr_ze - dsovr_cle;
    double dSOVFThin = dlen_sovr / len_thin;
    double dSOVFThick = 2.0 * dlen_sovr / (len_thick - len_hbare);

    double TropToT = Trop_conc * ((1 - SOVFThin) * TRPNCaL
                                  + SOVFThin * (FrSBXB * TRPNCaH + (1 - FrSBXB) * TRPNCaL));
    double dTropToT = Trop_conc * (-dSOVFThin * TRPNCaL + (1 - SOVFThin) * dTRPNCaL
                                   + dSOVFThin * (FrSBXB * TRPNCaH + (1 - FrSBXB) * TRPNCaL)
                                   + SOVFThin * (dFrSBXB * TRPNCaH + FrSBXB * dTRPNCaH - dFrSBXB * TRPNCaL
                                           + (1 - FrSBXB) * dTRPNCaL));
    /*double dforce = kxb * dSOVFThick * (xXBpostr * XBpostr + xXBprer * XBprer)
                    + kxb * SOVFThick * (dxXBpostr * XBpostr + xXBpostr * dXBpostr
                                         + dxXBprer * XBprer + xXBprer * dXBprer);*/
    return dTropToT;
}
void RiceMyofilament::FESolve(const double dt) {
    N        = Foward_Euler(dt, dN, N);
    XBprer   = Foward_Euler(dt, dXBprer, XBprer);
    XBpostr  = Foward_Euler(dt, dXBpostr, XBpostr);
    SL       = Foward_Euler(dt, dSL, SL);
    xXBpostr = Foward_Euler(dt, dxXBpostr, xXBpostr);
    xXBprer  = Foward_Euler(dt, dxXBprer, xXBprer);
    TRPNCaL  = Foward_Euler(dt, dTRPNCaL, TRPNCaL);
    TRPNCaH  = Foward_Euler(dt, dTRPNCaH, TRPNCaH);
    intf     = Foward_Euler(dt, dintf, intf);


    if (N+XBpostr + XBpostr+TRPNCaH !=N+XBpostr + XBpostr+TRPNCaH ){
        std::cerr << " Nan in force model" << std::endl;
        std::exit(0);
    }
}


double RiceMyofilament::GetStrain() {
    return (SL - SLset) / SLset;
}


void RiceMyofilament::OutputState() {
    std::ofstream out("RiceMyofilamentStates.dat", std::ofstream::out);
    if (!out.is_open())
    {
        std::cerr << "cannot open file to output RiceMyofilament states. Programe stopped!" << std::endl;
        std::exit(0);
    }


    out << N << " "
        << XBprer   << " "
        << XBpostr  << " "
        << SL       << " "
        << xXBpostr << " "
        << xXBprer  << " "
        << TRPNCaL  << " "
        << TRPNCaH  << " "
        << intf     << " ";
    out.close();
    
}

double RiceMyofilament::SolveForceSingleTimeStep(const double Cai, const double usr_dt) {
    double dTronccai = MyofilamentODE(Cai);
    FESolve(usr_dt);
    return dTronccai;
}
