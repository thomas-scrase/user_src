//LIC// ====================================================================
//LIC// 
//LIC// ====================================================================


#ifndef OOMPH_MULTI_DOMAIN_CARDIAC_TISSUE_SUB_ELEMENTS
#define OOMPH_MULTI_DOMAIN_CARDIAC_TISSUE_SUB_ELEMENTS

// Config header generated by autoconfig
#ifdef HAVE_CONFIG_H
  #include <oomph-lib-config.h>
#endif


//Generic for the element with external element
// #include "generic.h"

//Include the storage_augmented_cell_elements header
#include "../toms_utilities/diff_augmented_cell_wrapper.h"

//Monodomain elements
#include "../cell_membrane_potential/cell_membrane_potential_elements.h"

//Solid elements for the external solid element for geometric data
#include "../anisotropic_solid/anisotropic_solid_elements.h"
#include "../anisotropic_solid/refineable_anisotropic_solid_elements.h"

//Cell interface elements (includes cell models)
#include "../cell_interface/cell_interface_elements.h"

#include "../solid/solid_traction_elements.h"



namespace oomph{

//We make this work for both monodomain and bidomain based conducting cell elements
template<class UPDATED_CELL_ELEMENT, class EXT_ANISOTROPIC_SOLID_ELEMENT>
class ConductingCellElementWithExternalAnisotropicSolidElement :
public virtual DiffAugmentedCell<UPDATED_CELL_ELEMENT>,
public virtual ElementWithExternalElement
{
public:
	ConductingCellElementWithExternalAnisotropicSolidElement() :
	DiffAugmentedCell<UPDATED_CELL_ELEMENT>(),
	ElementWithExternalElement(),
	solid_interaction_index(0)
	{
		ElementWithExternalElement::set_ninteraction(1);

		this->ignore_external_geometric_data();
	}


	// void interpolated_zeta(const Vector<double> &s, Vector<double> &zeta) const override
	// {	
	// 	// oomph_info << "ConductingCellElementWithExternalAnisotropicSolidElement<...>::interpolated_zeta" << std::endl;

	// 	// {
	// 	// 	oomph_info << "Reporting shape function pre" << std::endl;
	// 	// 	Shape psi(this->nnode(),this->nnodal_position_type());
	// 	// 	this->shape(s,psi);
	// 	// 	for(unsigned n=0; n<this->nnode(); n++){
	// 	// 		oomph_info << "Node " << n << ":" << std::endl;
	// 	// 		for(unsigned k=0; k<this->nnodal_position_type(); k++){
	// 	// 			oomph_info << "Nodal position type: " << k << std::endl;
	// 	// 			//Locally cache the value of the shape function
	// 	// 			oomph_info << psi(n,k) << std::endl;
	// 	// 		}
	// 	// 	}
	// 	// }


	// 	UPDATED_CELL_ELEMENT::interpolated_zeta(s,zeta);
	// }
	
	void identify_field_data_for_interactions(std::set<std::pair<Data*,unsigned> > &paired_field_data) override
	{
		FiniteElement::identify_field_data_for_interactions(paired_field_data);
	}

	void describe_local_dofs(std::ostream &out, const std::string &current_string) const
	{
		UPDATED_CELL_ELEMENT::describe_local_dofs(out, current_string);
	}

	//Inform cell element where to get diffusion tensor data from
	//Monodomain
	void get_diff_monodomain(const unsigned& ipt,
                            const Vector<double> &s,
                            const Vector<double>& x,
                            DenseMatrix<double>& D) const
	{
		DiffAugmentedCell<UPDATED_CELL_ELEMENT>::get_interpolated_diffusion_matrix(s, D);
	}
	//Bidomain
	void get_intracellular_conductivity_bidomain(const unsigned& ipt,
	                                            const Vector<double> &s,
	                                            const Vector<double>& x,
	                                            DenseMatrix<double>& G_i) const
	{
		DiffAugmentedCell<UPDATED_CELL_ELEMENT>::get_interpolated_diffusion_matrix(s, G_i);
	}
	void get_extracellular_conductivity_bidomain(const unsigned& ipt,
		                                            const Vector<double> &s,
		                                            const Vector<double>& x,
		                                            DenseMatrix<double>& G_e) const
	{
		DiffAugmentedCell<UPDATED_CELL_ELEMENT>::get_interpolated_diffusion_matrix(s, G_e);
	}


	// void output(std::ostream &outfile, const unsigned &nplot)
	// {
	// 	unsigned num_plot_points=nplot_points(2);//we ignore the nplot passed because it only makes sense for the cell model to do 
	// 	for (unsigned iplot=0;iplot<num_plot_points;iplot++)
	// 	{
	// 		Vector<double> cell_model_out_iplot;//This is resized as needed by the cell model
	// 		UPDATED_CELL_ELEMENT::output_to_vect(cell_model_out_iplot, iplot);
	// 	}
	// }



	/////Inform solid element where to get diffusion tensor data from



	/////Inform solid element where to get active strain from



	//Tell the elements how to fill in residuals
	//Residuals fill in should be unchanged from just that of the underlying cell element

	void fill_in_contribution_to_jacobian(Vector<double> &residuals, 
												DenseMatrix<double> &jacobian)
	{	
		// ElementWithExternalElement::fill_in_contribution_to_jacobian(residuals,jacobian);
		UPDATED_CELL_ELEMENT::fill_in_contribution_to_jacobian(residuals,jacobian);
		// Fill in contribution from external elements
		// This probably won't do anything but we keep it in here just in case we want to do some non-segregated
		//  or weird stuff with the elements
		this->fill_in_jacobian_from_external_interaction_by_fd(residuals,jacobian);
	}

	/// Add the element's contribution to its residuals vector,
	/// jacobian matrix and mass matrix
	void fill_in_contribution_to_jacobian_and_mass_matrix(Vector<double> &residuals,
															DenseMatrix<double> &jacobian,
															DenseMatrix<double> &mass_matrix)
	{
		//Call the standard (Broken) function
		//which will prevent these elements from being used
		//in eigenproblems until replaced.
		FiniteElement::fill_in_contribution_to_jacobian_and_mass_matrix(residuals,jacobian,mass_matrix);
	}

	unsigned solid_interaction_index;

};



// //============================================================================
// /// FaceGeometry of a 3D QAnisotropicPVDElement element
// //============================================================================
// template<unsigned NNODE_1D, class CELL_MODEL, template<unsigned> class CONDUCTANCE_MODEL, class EXT_ANISOTROPIC_SOLID_ELEMENT>
// class FaceGeometry<ConductingCellElementWithExternalAnisotropicSolidElement<QConductingCellElement<3,NNODE_1D, CELL_MODEL , CONDUCTANCE_MODEL>, EXT_ANISOTROPIC_SOLID_ELEMENT> > :
// public virtual QElement<2,NNODE_1D>
// {
// public:
// 	FaceGeometry() : QElement<2,NNODE_1D>() {}
// };

// //============================================================================
// /// FaceGeometry of FaceGeometry of a 3D QAnisotropicPVDElement element
// //============================================================================
// template<unsigned NNODE_1D, class CELL_MODEL, template<unsigned> class CONDUCTANCE_MODEL, class EXT_ANISOTROPIC_SOLID_ELEMENT>
// class FaceGeometry<FaceGeometry<ConductingCellElementWithExternalAnisotropicSolidElement<QConductingCellElement<3,NNODE_1D, CELL_MODEL , CONDUCTANCE_MODEL>, EXT_ANISOTROPIC_SOLID_ELEMENT> > > :
// public virtual QElement<1,NNODE_1D>
// {
// public:
// /// Constructor must call the constructor of the underlying solid element
// 	FaceGeometry() : QElement<1,NNODE_1D>() {}
// };


// //============================================================================
// /// FaceGeometry of a 2D QAnisotropicPVDElement element
// //============================================================================
// template<unsigned NNODE_1D, class CELL_MODEL, template<unsigned> class CONDUCTANCE_MODEL, class EXT_ANISOTROPIC_SOLID_ELEMENT>
// class FaceGeometry<ConductingCellElementWithExternalAnisotropicSolidElement<QConductingCellElement<2,NNODE_1D, CELL_MODEL , CONDUCTANCE_MODEL>, EXT_ANISOTROPIC_SOLID_ELEMENT> > :
// public virtual QElement<1,NNODE_1D>
// {
// public:
// 	FaceGeometry() : QElement<2,NNODE_1D>() {}
// };

// //============================================================================
// /// FaceGeometry of FaceGeometry of a 2D QAnisotropicPVDElement element
// //============================================================================
// template<unsigned NNODE_1D, class CELL_MODEL, template<unsigned> class CONDUCTANCE_MODEL, class EXT_ANISOTROPIC_SOLID_ELEMENT>
// class FaceGeometry<FaceGeometry<ConductingCellElementWithExternalAnisotropicSolidElement<QConductingCellElement<2,NNODE_1D, CELL_MODEL , CONDUCTANCE_MODEL>, EXT_ANISOTROPIC_SOLID_ELEMENT> > > :
// public virtual PointElement
// {
// public:
// /// Constructor must call the constructor of the underlying solid element
// 	FaceGeometry() : PointElement() {}
// };






// //============================================================================
// /// FaceGeometry of a 3D QAnisotropicPVDElement element
// //============================================================================
// template<unsigned NNODE_1D, class CELL_MODEL, template<unsigned> class CONDUCTANCE_MODEL, class EXT_ANISOTROPIC_SOLID_ELEMENT>
// class FaceGeometry<ConductingCellElementWithExternalAnisotropicSolidElement<TConductingCellElement<3,NNODE_1D, CELL_MODEL , CONDUCTANCE_MODEL>, EXT_ANISOTROPIC_SOLID_ELEMENT> > :
// public virtual TElement<2,NNODE_1D>
// {
// public:
// 	FaceGeometry() : TElement<2,NNODE_1D>() {}
// };

// //============================================================================
// /// FaceGeometry of FaceGeometry of a 3D QAnisotropicPVDElement element
// //============================================================================
// template<unsigned NNODE_1D, class CELL_MODEL, template<unsigned> class CONDUCTANCE_MODEL, class EXT_ANISOTROPIC_SOLID_ELEMENT>
// class FaceGeometry<FaceGeometry<ConductingCellElementWithExternalAnisotropicSolidElement<TConductingCellElement<3,NNODE_1D, CELL_MODEL , CONDUCTANCE_MODEL>, EXT_ANISOTROPIC_SOLID_ELEMENT> > > :
// public virtual TElement<1,NNODE_1D>
// {
// public:
// /// Constructor must call the constructor of the underlying solid element
// 	FaceGeometry() : TElement<1,NNODE_1D>() {}
// };














template<class ANISOTROPIC_SOLID_ELEMENT, class EXT_UPDATED_CELL_ELEMENT>
class AnisotropicSolidElementWithExternalConductingCellElement :
public virtual ANISOTROPIC_SOLID_ELEMENT,
public virtual ElementWithExternalElement
{
public:
	AnisotropicSolidElementWithExternalConductingCellElement() :
	ANISOTROPIC_SOLID_ELEMENT(),
	ElementWithExternalElement(),
	cell_interaction_index(0)
	{
		ElementWithExternalElement::set_ninteraction(1);

		this->ignore_external_geometric_data();
	}

	// void shape(const Vector<double> &s, Shape &psi) const override
	// {
	// 	throw OomphLibError(
	// 		"Overridden",
	// 		OOMPH_CURRENT_FUNCTION,
	// 		OOMPH_EXCEPTION_LOCATION);
	// }
	// void interpolated_x(const Vector<double> &s,Vector<double>& x) const override
	// {
	// 	ANISOTROPIC_SOLID_ELEMENT::interpolated_x(s, x);

	// }

	// void interpolated_zeta(const Vector<double> &s, Vector<double> &zeta) const override
	// {	
	// 	// oomph_info << " AnisotropicSolidElementWithExternalConductingCellElement<...>::interpolated_zeta ";

	// // 	std::cout << "Local coord:";
	// // 	for(unsigned d=0; d<this->dim(); d++){
	// // 		std::cout << " " << s[d];
	// // 	}
	// // 	std::cout << std::endl;

	// // 	std::cout << "Num nodes " << this->nnode() << std::endl;
	// // 	for(unsigned n=0; n<this->nnode(); n++){
	// // 		std::cout << "Node " << n << ":" << std::endl;
	// // 		for(unsigned k=0; k<this->nnodal_position_type(); k++){
	// // 			std::cout << "Nodal position type: " << k << std::endl;
	// // 			for(unsigned d=0; d<this->dim(); d++){
	// // 				std::cout << this->node_pt(n)->x_gen(k,d) << " ";
	// // 			}
	// // 			std::cout << std::endl;
	// // 		}
	// // 		std::cout << std::endl;
	// // 	}

	// 	// std::cout << "Reporting global coord of each node:" << std::endl;
	// 	// for(unsigned n=0; n<this->nnode(); n++){
	// 	// 	std::cout << "Node " << n << ":" << std::endl;
	// 	// 	for(unsigned d=0; d<this->dim(); d++){
	// 	// 		std::cout << " " << this->node_pt(n)->x(d);
	// 	// 	}
	// 	// 	std::cout << std::endl;
	// 	// }
	// 	// std::cout << std::endl;

	// 	// {
	// 	// 	oomph_info << "Reporting shape function pre" << std::endl;
	// 	// 	Shape psi(this->nnode(),this->nnodal_position_type());
	// 	// 	this->shape(s,psi);
	// 	// 	for(unsigned n=0; n<this->nnode(); n++){
	// 	// 		oomph_info << "Node " << n << ":" << std::endl;
	// 	// 		for(unsigned k=0; k<this->nnodal_position_type(); k++){
	// 	// 			oomph_info<< "Nodal position type: " << k << std::endl;
	// 	// 			//Locally cache the value of the shape function
	// 	// 			oomph_info<< psi(n,k) << std::endl;
	// 	// 		}
	// 	// 	}
	// 	// }


	// 	ANISOTROPIC_SOLID_ELEMENT::interpolated_zeta(s, zeta);

	// 	// {
	// 	// 	std::cout << "Reporting shape function post" << std::endl;
	// 	// 	Shape psi(this->nnode(),this->nnodal_position_type());
	// 	// 	this->shape(s,psi);
	// 	// 	for(unsigned n=0; n<this->nnode(); n++){
	// 	// 		std::cout << "Node " << n << ":" << std::endl;
	// 	// 		for(unsigned k=0; k<this->nnodal_position_type(); k++){
	// 	// 			std::cout << "Nodal position type: " << k << std::endl;
	// 	// 			//Locally cache the value of the shape function
	// 	// 			std::cout << psi(n,k) << std::endl;
	// 	// 		}
	// 	// 	}
	// 	// }
	// // 	// zeta[0] +=10.0;

	// // 	std::cout << "AnisotropicSolidElementWithExternalConductingCellElement<...>::interpolated_zeta END" << std::endl;
	// }	


	
	void identify_field_data_for_interactions(std::set<std::pair<Data*,unsigned> > &paired_field_data) override
	{
		FiniteElement::identify_field_data_for_interactions(paired_field_data);
	}

	// void describe_local_dofs(std::ostream &out, const std::string &current_string) const
	// {
	// 	ANISOTROPIC_SOLID_ELEMENT::describe_local_dofs(out, current_string);
	// }


	//Inform solid element where to get diffusion tensor data from
	void anisotropic_matrix(const unsigned& ipt,
                           const Vector<double> &s,
                           const Vector<double>& xi,
                           DenseMatrix<double>& A)
    {
    	dynamic_cast<DiffAugmentedCell<EXT_UPDATED_CELL_ELEMENT>*>(external_element_pt(cell_interaction_index, ipt))->
    				get_interpolated_preferential_vectors(external_element_local_coord(cell_interaction_index, ipt), A);
    }


	//Inform solid element where to get active strain from
	void driving_strain(const unsigned& ipt,
                       const Vector<double>& s,
                       const Vector<double>& xi,
                       Vector<double>& V)
    {
    	V.resize(this->dim(), 0.0);
    	V[0] = -dynamic_cast<EXT_UPDATED_CELL_ELEMENT*>(external_element_pt(cell_interaction_index, ipt))->
    			get_interpolated_active_strain(external_element_local_coord(cell_interaction_index, ipt));
    	// oomph_info << "Active Strain " << V[0] << std::endl;
    }

	//Tell the elements how to fill in residuals
	//Residuals fill in should be unchanged from just that of the underlying cell element
    void fill_in_contribution_to_jacobian(Vector<double> &residuals, 
												DenseMatrix<double> &jacobian)
	{	
		// ElementWithExternalElement::fill_in_contribution_to_jacobian(residuals,jacobian);
		ANISOTROPIC_SOLID_ELEMENT::fill_in_contribution_to_jacobian(residuals,jacobian);
		// Fill in contribution from external elements
		// This probably won't do anything but we keep it in here just in case we want to do some non-segregated
		//  or weird stuff with the elements
		this->fill_in_jacobian_from_external_interaction_by_fd(residuals,jacobian);
	}

	/// Add the element's contribution to its residuals vector,
	/// jacobian matrix and mass matrix
	void fill_in_contribution_to_jacobian_and_mass_matrix(Vector<double> &residuals,
															DenseMatrix<double> &jacobian,
															DenseMatrix<double> &mass_matrix)
	{
		//Call the standard (Broken) function
		//which will prevent these elements from being used
		//in eigenproblems until replaced.
		FiniteElement::fill_in_contribution_to_jacobian_and_mass_matrix(residuals,jacobian,mass_matrix);
	}

	void describe_local_dofs(std::ostream& out,const std::string& current_string) const
	{
		ANISOTROPIC_SOLID_ELEMENT::describe_local_dofs(out, current_string);
		ElementWithExternalElement::describe_local_dofs(out, current_string);
	}

	// void shape(const Vector<double> &s, Shape &psi) const
	// {
	//  	// ANISOTROPIC_SOLID_ELEMENT::shape(s, psi);
	// }

	unsigned cell_interaction_index;

};





//Now we need to define all of the many many face geometries for these types of elements


// template<unsigned NNODE_1D>
//   class FaceGeometry<QAnisotropicPVDElement<2,NNODE_1D> > :
//   public virtual SolidQElement<1,NNODE_1D>
//   {
//     public:
//    /// Constructor must call the constructor of the underlying solid element
//    FaceGeometry() : SolidQElement<1,NNODE_1D>() {}
//   };
 

//  //==============================================================
// /// FaceGeometry of the FaceGeometry of the 2D QAnisotropicPVDElement 
// //==============================================================
// template<unsigned NNODE_1D>
// class FaceGeometry<FaceGeometry<QAnisotropicPVDElement<2,NNODE_1D> > >:
//  public virtual PointElement
// {
//   public:
//  //Make sure that we call the constructor of the SolidQElement
//  //Only the Intel compiler seems to need this!
//  FaceGeometry() : PointElement() {}
// };



//To be deleted
// //============================================================================
// /// FaceGeometry of a 3D QAnisotropicPVDElement element
// //============================================================================
// template<unsigned NNODE_1D>
//  class FaceGeometry<QAnisotropicPVDElement<3,NNODE_1D> > :
//  public virtual SolidQElement<2,NNODE_1D>
//  {
//    public:
//   /// Constructor must call the constructor of the underlying solid element
//   FaceGeometry() : SolidQElement<2,NNODE_1D>() {}
//  };
 
// //============================================================================
// /// FaceGeometry of FaceGeometry of a 3D QAnisotropicPVDElement element
// //============================================================================
//  template<unsigned NNODE_1D>
//   class FaceGeometry<FaceGeometry<QAnisotropicPVDElement<3,NNODE_1D> > > :
//   public virtual SolidQElement<1,NNODE_1D>
//   {
//     public:
//    /// Constructor must call the constructor of the underlying solid element
//    FaceGeometry() : SolidQElement<1,NNODE_1D>() {}
//   };



// //============================================================================
// /// FaceGeometry of a 3D QAnisotropicPVDElement element
// //============================================================================
// template<unsigned NNODE_1D, class EXT_UPDATED_CELL_ELEMENT>
// class FaceGeometry<AnisotropicSolidElementWithExternalConductingCellElement<QAnisotropicPVDElement<3,NNODE_1D>, EXT_UPDATED_CELL_ELEMENT> > :
// // public virtual AnisotropicSolidElementWithExternalConductingCellElement<QAnisotropicPVDElement<2,NNODE_1D>, EXT_UPDATED_CELL_ELEMENT>
// public virtual SolidQElement<2, NNODE_1D>
// {
// public:
// 	FaceGeometry() : SolidQElement<2,NNODE_1D>() {}
// };

// //============================================================================
// /// FaceGeometry of FaceGeometry of a 3D QAnisotropicPVDElement element
// //============================================================================
//  template<unsigned NNODE_1D, class EXT_UPDATED_CELL_ELEMENT>
// class FaceGeometry<FaceGeometry<AnisotropicSolidElementWithExternalConductingCellElement<QAnisotropicPVDElement<3,NNODE_1D>, EXT_UPDATED_CELL_ELEMENT> > > :
// public virtual SolidQElement<1,NNODE_1D>
// {
// public:
// /// Constructor must call the constructor of the underlying solid element
// 	FaceGeometry() : SolidQElement<1,NNODE_1D>() {}
// };

// //============================================================================
// /// FaceGeometry of a 2D QAnisotropicPVDElement element
// //============================================================================
// template<unsigned NNODE_1D, class EXT_UPDATED_CELL_ELEMENT>
// class FaceGeometry<AnisotropicSolidElementWithExternalConductingCellElement<QAnisotropicPVDElement<2,NNODE_1D>, EXT_UPDATED_CELL_ELEMENT> > :
// public virtual SolidQElement<1, NNODE_1D>
// {
// public:
// 	FaceGeometry() : SolidQElement<1,NNODE_1D>() {}
// };

// //============================================================================
// /// FaceGeometry of FaceGeometry of a 2D QAnisotropicPVDElement element
// //============================================================================
//  template<unsigned NNODE_1D, class EXT_UPDATED_CELL_ELEMENT>
// class FaceGeometry<FaceGeometry<AnisotropicSolidElementWithExternalConductingCellElement<QAnisotropicPVDElement<2,NNODE_1D>, EXT_UPDATED_CELL_ELEMENT> > > :
// public virtual PointElement
// {
// public:
// /// Constructor must call the constructor of the underlying solid element
// 	FaceGeometry() : PointElement() {}
// };





// //============================================================================
// /// FaceGeometry of a 3D QAnisotropicPVDElementWithPressure element
// //============================================================================
// template<class EXT_UPDATED_CELL_ELEMENT>
// class FaceGeometry<AnisotropicSolidElementWithExternalConductingCellElement<QAnisotropicPVDElementWithPressure<3>, EXT_UPDATED_CELL_ELEMENT> > :
// // public virtual AnisotropicSolidElementWithExternalConductingCellElement<QAnisotropicPVDElement<2,NNODE_1D>, EXT_UPDATED_CELL_ELEMENT>
// public virtual SolidQElement<2, 3>
// {
// public:
// 	FaceGeometry() : SolidQElement<2,3>() {}
// };

// //============================================================================
// /// FaceGeometry of FaceGeometry of a 3D QAnisotropicPVDElementWithPressure element
// //============================================================================
//  template<class EXT_UPDATED_CELL_ELEMENT>
// class FaceGeometry<FaceGeometry<AnisotropicSolidElementWithExternalConductingCellElement<QAnisotropicPVDElementWithPressure<3>, EXT_UPDATED_CELL_ELEMENT> > > :
// public virtual SolidQElement<1,3>
// {
// public:
// /// Constructor must call the constructor of the underlying solid element
// 	FaceGeometry() : SolidQElement<1,3>() {}
// };

// //============================================================================
// /// FaceGeometry of a 2D QAnisotropicPVDElementWithPressure element
// //============================================================================
// template<class EXT_UPDATED_CELL_ELEMENT>
// class FaceGeometry<AnisotropicSolidElementWithExternalConductingCellElement<QAnisotropicPVDElementWithPressure<2>, EXT_UPDATED_CELL_ELEMENT> > :
// // public virtual AnisotropicSolidElementWithExternalConductingCellElement<QAnisotropicPVDElement<2,NNODE_1D>, EXT_UPDATED_CELL_ELEMENT>
// public virtual SolidQElement<1, 3>
// {
// public:
// 	FaceGeometry() : SolidQElement<1,3>() {}
// };

// //============================================================================
// /// FaceGeometry of FaceGeometry of a 2D QAnisotropicPVDElementWithPressure element
// //============================================================================
//  template<class EXT_UPDATED_CELL_ELEMENT>
// class FaceGeometry<FaceGeometry<AnisotropicSolidElementWithExternalConductingCellElement<QAnisotropicPVDElementWithPressure<2>, EXT_UPDATED_CELL_ELEMENT> > > :
// public virtual PointElement
// {
// public:
// /// Constructor must call the constructor of the underlying solid element
// 	FaceGeometry() : PointElement() {}
// };







// template<class ANISOTROPIC_SOLID_ELEMENT, class EXT_UPDATED_CELL_ELEMENT>
// class FaceGeometry<AnisotropicSolidElementWithExternalConductingCellElement<ANISOTROPIC_SOLID_ELEMENT, EXT_UPDATED_CELL_ELEMENT> > :
// public virtual AnisotropicSolidElementWithExternalConductingCellElement<ANISOTROPIC_SOLID_ELEMENT, EXT_UPDATED_CELL_ELEMENT>
// {
// public:
// 	FaceGeometry() : AnisotropicSolidElementWithExternalConductingCellElement<ANISOTROPIC_SOLID_ELEMENT, EXT_UPDATED_CELL_ELEMENT>() {}
// };













// //=======================================================================
// /// Face geometry for element is the same as that for the underlying
// /// wrapped element
// //=======================================================================
//  template<class ELEMENT>
//  class FaceGeometry<ProjectableAnisotropicPVDElement<ELEMENT> > 
//   : public virtual FaceGeometry<ELEMENT>
//  {
//  public:
//   FaceGeometry() : FaceGeometry<ELEMENT>() {}
//  };


// //=======================================================================
// /// Face geometry of the Face Geometry for element is the same as 
// /// that for the underlying wrapped element
// //=======================================================================
//  template<class ELEMENT>
//  class FaceGeometry<FaceGeometry<
//  ProjectableAnisotropicPVDElement<ELEMENT> > >
//  : public virtual FaceGeometry<FaceGeometry<ELEMENT> >
//  {
//    public:
//    FaceGeometry() : FaceGeometry<FaceGeometry<ELEMENT> >() {}
//  };












// //======================================================================
// /// FaceGeometry of 2D QAnisotropicPVDElementWithPressure
// //======================================================================
// template<>
// class FaceGeometry<QAnisotropicPVDElementWithPressure<2> >: 
// public virtual SolidQElement<1,3>
// {
//   public:
//  /// Constructor must call constructor of underlying solid element
//  FaceGeometry() : SolidQElement<1,3>() {}
// };


// //======================================================================
// /// FaceGeometry of FaceGeometry of 2D QAnisotropicPVDElementWithPressure
// //======================================================================
// template<>
// class FaceGeometry<FaceGeometry<QAnisotropicPVDElementWithPressure<2> > >: 
// public virtual PointElement
// {
//   public:
//  /// Constructor must call constructor of underlying solid element
//  FaceGeometry() : PointElement() {}
// };

// //======================================================================
// /// FaceGeometry of 3D QAnisotropicPVDElementWithPressure
// //======================================================================
// template<>
// class FaceGeometry<QAnisotropicPVDElementWithPressure<3> >: 
// public virtual SolidQElement<2,3>
// {
//   public:
//  /// Constructor must call constructor of underlying solid element
//  FaceGeometry() : SolidQElement<2,3>() {}
// };


// //======================================================================
// /// FaceGeometry of FaceGeometry of 3D QAnisotropicPVDElementWithPressure
// //======================================================================
// template<>
// class FaceGeometry<FaceGeometry<QAnisotropicPVDElementWithPressure<3> > >: 
// public virtual SolidQElement<1,3>
// {
//   public:
//  /// Constructor must call constructor of underlying solid element
//   FaceGeometry() : SolidQElement<1,3>() {}
// };












// //===============================================================
// /// FaceGeometry for 2D QAnisotropicPVDElementWithContinuousPressure element
// //===============================================================
// template<>
// class FaceGeometry<QAnisotropicPVDElementWithContinuousPressure<2> >: 
// public virtual SolidQElement<1,3>
// {
//   public:
//  /// Constructor must call constructor of the underlying Solid element
//  FaceGeometry() : SolidQElement<1,3>() {}
// };



// //===============================================================
// /// FaceGeometry of FaceGeometry 
// /// for 2D QAnisotropicPVDElementWithContinuousPressure element
// //===============================================================
// template<>
// class FaceGeometry<FaceGeometry<QAnisotropicPVDElementWithContinuousPressure<2> > >: 
// public virtual PointElement
// {
//   public:
//  /// Constructor must call constructor of the underlying Point element
//   FaceGeometry() : PointElement() {}
// };


// //===============================================================
// /// FaceGeometry for 3D QAnisotropicPVDElementWithContinuousPressure element
// //===============================================================
// template<>
// class FaceGeometry<QAnisotropicPVDElementWithContinuousPressure<3> >: 
// public virtual SolidQElement<2,3>
// {
//   public:
//  /// Constructor must call constructor of the underlying Solid element
//  FaceGeometry() : SolidQElement<2,3>() {}
// };



// //===============================================================
// /// FaceGeometry of FaceGeometry 
// /// for 3D QAnisotropicPVDElementWithContinuousPressure element
// //===============================================================
// template<>
// class FaceGeometry<FaceGeometry<QAnisotropicPVDElementWithContinuousPressure<3> > >: 
// public virtual SolidQElement<1,3>
// {
//   public:
//  /// Constructor must call constructor of the underlying element
//   FaceGeometry() : SolidQElement<1,3>() {}
// };













// //============================================================================
// /// FaceGeometry of a 2D TAnisotropicPVDElement element
// //============================================================================
// template<unsigned NNODE_1D>
// class FaceGeometry<TAnisotropicPVDElement<2,NNODE_1D> > :
//  public virtual SolidTElement<1,NNODE_1D>
// {
//   public:
//  /// Constructor must call the constructor of the underlying solid element
//   FaceGeometry() : SolidTElement<1,NNODE_1D>() {}
// };
 

// //==============================================================
// /// FaceGeometry of the FaceGeometry of the 2D TAnisotropicPVDElement 
// //==============================================================
// template<unsigned NNODE_1D>
// class FaceGeometry<FaceGeometry<TAnisotropicPVDElement<2,NNODE_1D> > >:
//  public virtual PointElement
// {
//   public:
//  //Make sure that we call the constructor of the SolidQElement
//  //Only the Intel compiler seems to need this!
//   FaceGeometry() : PointElement() {}
// };


//To be deleted
// //============================================================================
// /// FaceGeometry of a 3D TAnisotropicPVDElement element
// //============================================================================
// template<unsigned NNODE_1D>
// class FaceGeometry<TAnisotropicPVDElement<3,NNODE_1D> > :
//  public virtual SolidTElement<2,NNODE_1D>
// {
//   public:
//  /// Constructor must call the constructor of the underlying solid element
//   FaceGeometry() : SolidTElement<2,NNODE_1D>() {}
// };
 
// //============================================================================
// /// FaceGeometry of FaceGeometry of a 3D TAnisotropicPVDElement element
// //============================================================================
// template<unsigned NNODE_1D>
// class FaceGeometry<FaceGeometry<TAnisotropicPVDElement<3,NNODE_1D> > > :
//  public virtual SolidTElement<1,NNODE_1D>
// {
//   public:
//  /// Constructor must call the constructor of the underlying solid element
//   FaceGeometry() : SolidTElement<1,NNODE_1D>() {}
// };


//============================================================================
/// FaceGeometry of a 3D QAnisotropicPVDElement element
// //============================================================================
// template<unsigned NNODE_1D, class EXT_UPDATED_CELL_ELEMENT>
// class FaceGeometry<AnisotropicSolidElementWithExternalConductingCellElement<TAnisotropicPVDElement<3,NNODE_1D>, EXT_UPDATED_CELL_ELEMENT> > :
// // public virtual AnisotropicSolidElementWithExternalConductingCellElement<TAnisotropicPVDElement<2,NNODE_1D>, EXT_UPDATED_CELL_ELEMENT>
// public virtual SolidTElement<2,NNODE_1D>
// {
// public:
// 	FaceGeometry() : SolidTElement<2,NNODE_1D>() {}
// };

// //============================================================================
// /// FaceGeometry of FaceGeometry of a 3D QAnisotropicPVDElement element
// //============================================================================
//  template<unsigned NNODE_1D, class EXT_UPDATED_CELL_ELEMENT>
// class FaceGeometry<FaceGeometry<AnisotropicSolidElementWithExternalConductingCellElement<TAnisotropicPVDElement<3,NNODE_1D>, EXT_UPDATED_CELL_ELEMENT> > > :
// public virtual SolidTElement<1,NNODE_1D>
// {
// public:
// /// Constructor must call the constructor of the underlying solid element
// 	FaceGeometry() : SolidTElement<1,NNODE_1D>() {}
// };










// //============================================================================
// /// FaceGeometry of a 2D TAnisotropicPVDBubbleEnrichedElement element
// //============================================================================
// template<unsigned NNODE_1D>
// class FaceGeometry<TAnisotropicPVDBubbleEnrichedElement<2,NNODE_1D> > :
//  public virtual SolidTElement<1,NNODE_1D>
// {
//   public:
//  /// Constructor must call the constructor of the underlying solid element
//   FaceGeometry() : SolidTElement<1,NNODE_1D>() {}
// };
 

// //==============================================================
// /// FaceGeometry of the FaceGeometry of the 2D TAnisotropicPVDBubbleEnrichedElement 
// //==============================================================
// template<unsigned NNODE_1D>
// class FaceGeometry<FaceGeometry<TAnisotropicPVDBubbleEnrichedElement<2,NNODE_1D> > >:
// public virtual PointElement
// {
//   public:
//  //Make sure that we call the constructor of the SolidQElement
//  //Only the Intel compiler seems to need this!
//   FaceGeometry() : PointElement() {}
// };


// //============================================================================
// /// FaceGeometry of a 3D TAnisotropicPVDBubbleEnrichedElement element
// //============================================================================
// template<unsigned NNODE_1D>
// class FaceGeometry<TAnisotropicPVDBubbleEnrichedElement<3,NNODE_1D> > :
//  public virtual SolidTBubbleEnrichedElement<2,NNODE_1D>
// {
//   public:
//  /// Constructor must call the constructor of the underlying solid element
//   FaceGeometry() : SolidTBubbleEnrichedElement<2,NNODE_1D>() {}
// };
 
// //============================================================================
// /// FaceGeometry of FaceGeometry of a 3D TAnisotropicPVDElement element
// //============================================================================
// template<unsigned NNODE_1D>
// class FaceGeometry<FaceGeometry<TAnisotropicPVDBubbleEnrichedElement<3,NNODE_1D> > > :
//  public virtual SolidTElement<1,NNODE_1D>
// {
//   public:
//  /// Constructor must call the constructor of the underlying solid element
//   FaceGeometry() : SolidTElement<1,NNODE_1D>() {}
// };









	














};


#endif