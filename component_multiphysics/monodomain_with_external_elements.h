//LIC// ====================================================================
//LIC// This file contains component_multiphysics elements, elements which are
//LIC//	themselves useless but occupy a domain in a multi-discretised multi-
//LIC//	physics element.
//LIC//
//LIC//
//LIC// This file contains the multi domain expansion for the monodomain element
//LIC// which allows for it to be used in multi-domain discretisation problems
//LIC// along with anisotropic_solid element and cell_interface_elements, each in
//LIC// their own distinctly discretised domains.
//LIC//
//LIC// This file also contains the refineable monodomain element with exeternal
//LIC// elements.
//LIC// ====================================================================

#ifndef OOMPH_MONODOMAIN_WITH_TWO_EXTERNAL_ELEMENTS
#define OOMPH_MONODOMAIN_WITH_TWO_EXTERNAL_ELEMENTS

// Config header generated by autoconfig
#ifdef HAVE_CONFIG_H
  #include <oomph-lib-config.h>
#endif

//Generic for the element with external element
#include "generic.h"

//Monodomain elements
#include "../monodomain/monodomain_elements.h"
#include "../monodomain/refineable_monodomain_elements.h"

//Cell interface elements (includes cell models)
#include "../cell_interface/cell_interface_elements.h"

//Solid elements for the external solid element for geometric data
#include "../anisotropic_solid/anisotropic_solid_elements.h"


namespace oomph{
	template<unsigned DIM, unsigned NNODE_1D>
	class QMonodomainElementWithExternalCellAndSolidElements	:
	public virtual QMonodomainElement<DIM, NNODE_1D>,
	public virtual ElementWithExternalElement
	{
	private:
		QMonodomainElementWithExternalCellAndSolidElements()	:
		QMonodomainElement<DIM, NNODE_1D>(),
		ElementWithExternalElement()
		{
			this->set_ninteraction(2);
		}

		void get_source_monodomain(const unsigned& ipt,
									const Vector<double>& x,
									double& source) const
		{
			//Get the interaction numbers
			const unsigned cell_interaction = 0;
			const unsigned solid_interaction = 1;

			//Zero the source
			source = 0.0;
			//Set the Vector to hold local coordinates
			Vector<double> s(DIM,0.0);
			//Assign values of s
			for(unsigned i=0;i<DIM;i++) s[i] = this->integral_pt()->knot(ipt,i);
			//If a source function has been set, use it
			if(QMonodomainElement<DIM, NNODE_1D>::Source_fct_pt!=0){
				//Get source strength
				(*QMonodomainElement<DIM, NNODE_1D>::Source_fct_pt)(x,source);
			}

			//Add the membrane current from the external cell interface element
			source += dynamic_cast<CellInterfaceEquations<DIM>*> //cast the external element
			(external_element_pt(cell_interaction, ipt))->			//get the external element pointer
				interpolated_membrane_current_CellInterface(external_element_local_coord(cell_interaction,ipt)); //call the membrane current function at the correct local coord
		}

		void get_diff_monodomain(const unsigned& ipt,
									const Vector<double> &s,
									const Vector<double>& x,
									DenseMatrix<double>& D) const
		{
			D = dynamic_cast<VectorWithDiffusionStorageEnrichmentEquations<DIM*(DIM+1)>*>
			(external_element_pt(cell_interaction, ipt))->
				get_interpolated_diffusion_matrix_augmented_cell(external_element_local_coord(cell_interaction,ipt));
		}

		//!!!!!HOW TO ADD EXTERNAL GEOMETRIC DATA FROM ANIS_SOLID ELEMENT


		///\short Compute the element's residual vector and the Jacobian matrix.
		/// Jacobian is computed by finite-differencing
		void fill_in_contribution_to_jacobian(Vector<double> &residuals, 
												DenseMatrix<double> &jacobian)
		{
			ElementWithExternalElement::fill_in_contribution_to_jacobian(residuals,jacobian);
		}

		/// Add the element's contribution to its residuals vector,
		/// jacobian matrix and mass matrix
		void fill_in_contribution_to_jacobian_and_mass_matrix(Vector<double> &residuals,
																DenseMatrix<double> &jacobian,
																DenseMatrix<double> &mass_matrix)
		{
			//Call the standard (Broken) function
			//which will prevent these elements from being used
			//in eigenproblems until replaced.
			FiniteElement::fill_in_contribution_to_jacobian_and_mass_matrix(residuals,jacobian,mass_matrix);
		}
	};



	template<unsigned DIM, unsigned NNODE_1D>
	class RefineableQMonodomainElementWithExternalCellAndSolidElements	:
	public virtual RefineableQMonodomainElement<DIM, NNODE_1D>,
	public virtual ElementWithExternalElement
	{
	private:
		RefineableQMonodomainElementWithExternalCellAndSolidElements()	:
		RefineableQMonodomainElement<DIM, NNODE_1D>(),
		ElementWithExternalElement()
		{
			this->set_ninteraction(2);
		}

		void get_source_monodomain(const unsigned& ipt,
									const Vector<double>& x,
									double& source) const
		{
			//Get the interaction numbers
			const unsigned cell_interaction = 0;
			const unsigned solid_interaction = 1;

			//Zero the source
			source = 0.0;
			//Set the Vector to hold local coordinates
			Vector<double> s(DIM,0.0);
			//Assign values of s
			for(unsigned i=0;i<DIM;i++) s[i] = this->integral_pt()->knot(ipt,i);
			//If a source function has been set, use it
			if(RefineableQMonodomainElement<DIM, NNODE_1D>::Source_fct_pt!=0){
				//Get source strength
				(*RefineableQMonodomainElement<DIM, NNODE_1D>::Source_fct_pt)(x,source);
			}

			//Add the membrane current from the external cell interface element
			source += dynamic_cast<CellInterfaceEquations<DIM>*> //cast the external element
			(external_element_pt(cell_interaction, ipt))->			//get the external element pointer
				interpolated_membrane_current_CellInterface(external_element_local_coord(cell_interaction,ipt)); //call the membrane current function at the correct local coord
		}

		void get_diff_monodomain(const unsigned& ipt,
									const Vector<double> &s,
									const Vector<double>& x,
									DenseMatrix<double>& D) const
		{
			D = dynamic_cast<VectorWithDiffusionStorageEnrichmentEquations<DIM*(DIM+1)>*>
			(external_element_pt(cell_interaction, ipt))->
				get_interpolated_diffusion_matrix_augmented_cell(external_element_local_coord(cell_interaction,ipt));
		}

		//!!!!!HOW TO ADD EXTERNAL GEOMETRIC DATA FROM ANIS_SOLID ELEMENT


		///\short Compute the element's residual vector and the Jacobian matrix.
		/// Jacobian is computed by finite-differencing
		void fill_in_contribution_to_jacobian(Vector<double> &residuals, 
												DenseMatrix<double> &jacobian)
		{
			ElementWithExternalElement::fill_in_contribution_to_jacobian(residuals,jacobian);
		}

		/// Add the element's contribution to its residuals vector,
		/// jacobian matrix and mass matrix
		void fill_in_contribution_to_jacobian_and_mass_matrix(Vector<double> &residuals,
																DenseMatrix<double> &jacobian,
																DenseMatrix<double> &mass_matrix)
		{
			//Call the standard (Broken) function
			//which will prevent these elements from being used
			//in eigenproblems until replaced.
			FiniteElement::fill_in_contribution_to_jacobian_and_mass_matrix(residuals,jacobian,mass_matrix);
		}
	};

}
#endif