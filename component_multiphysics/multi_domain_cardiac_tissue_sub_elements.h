//LIC// ====================================================================
//LIC// Contains elements which allow cell elements, mono elements, and 
//LIC// Anisotropic Solid elements to communicate with eachother when they
//LIC// exist in separate domain discretisations.
//LIC// Cell elements are always upgraded to DiffAugmented<CELL_ELEMENT>
//LIC//  in order to ensure that get_diff / get_preferential_vectors
//LIC//  functions are implemented properly. This is a pretty safe default method
//LIC//  to use since fibre/sheet aligment data is usually described at the
//LIC//  location of cells in tissue scan data.
//LIC// ====================================================================

//!!!!! Add class type of external elements to template class for the following elements
//		This will mean each of the following can be used with refineable and non-refineable external
//		elements. Obviously do not add class type parameter for external cell elements since these
//		cannot be refineable

//!!!!! replace get diff monodomain with a suitable base membrane potential element function

#ifndef OOMPH_MULTI_DOMAIN_CARDIAC_TISSUE_SUB_ELEMENTS
#define OOMPH_MULTI_DOMAIN_CARDIAC_TISSUE_SUB_ELEMENTS

// Config header generated by autoconfig
#ifdef HAVE_CONFIG_H
  #include <oomph-lib-config.h>
#endif

// #ifdef OOMPH_HAS_MPI
// //mpi headers
// #include "mpi.h"
// #endif

//Generic for the element with external element
// #include "generic.h"

//Include the storage_augmented_cell_elements header
#include "../toms_utilities/diff_augmented_cell_wrapper.h"

//Monodomain elements
#include "../cell_membrane_potential/cell_membrane_potential_elements.h"

//Solid elements for the external solid element for geometric data
#include "../anisotropic_solid/anisotropic_solid_elements.h"
#include "../anisotropic_solid/refineable_anisotropic_solid_elements.h"

//Cell interface elements (includes cell models)
#include "../cell_interface/cell_interface_elements.h"



namespace oomph{

	//========================================================================================================================================
	//========================================================================================================================================
	//Storage augmented cell element with external membrane potential element
	//========================================================================================================================================
	//========================================================================================================================================
	template<class CELL_ELEMENT, class EXT_MEMBRANE_POTENTIAL_ELEMENT>
	class CellElementWithExternalMembranePotentialElement	:
	public virtual DiffAugmentedCell<CELL_ELEMENT>,
	public virtual ElementWithExternalElement
	{
	public:
		CellElementWithExternalMembranePotentialElement()	:
		DiffAugmentedCell<CELL_ELEMENT>(),
		ElementWithExternalElement()
		{
			// std::cout << "setting ninteraction to 1:\n\t External Membrane Potential Element" << std::endl;
			ElementWithExternalElement::set_ninteraction(1);
			// std::cout << "set" << std::endl;
			// ElementWithExternalElement::ignore_external_geometric_data ();
		}

		void identify_field_data_for_interactions(std::set<std::pair<Data*,unsigned> > &paired_field_data) override
		{
			// std::cout << "identify field data CellElementWithExternalMembranePotentialElement" << std::endl;
			FiniteElement::identify_field_data_for_interactions(paired_field_data);
		}

		void get_membrane_potential_CellInterface(const unsigned& ipt,
													const Vector<double>& s,
													const Vector<double>& x,
													double& V) const override
		{
			const unsigned mono_interaction = 0;

			if(external_element_pt(mono_interaction,ipt)){
					V = dynamic_cast<EXT_MEMBRANE_POTENTIAL_ELEMENT*>(external_element_pt(mono_interaction, ipt))->
							interpolated_vm_BaseCellMembranePotential(external_element_local_coord(mono_interaction, ipt));
			}
		}
		
		///\short Compute the element's residual vector
		void fill_in_contribution_to_residuals(Vector<double> &residuals)
		{	
			CELL_ELEMENT::fill_in_contribution_to_residuals(residuals);
		}

		///\short Compute the element's residual vector and the Jacobian matrix.
		/// Jacobian is computed by finite-differencing
		void fill_in_contribution_to_jacobian(Vector<double> &residuals, 
												DenseMatrix<double> &jacobian)
		{	
			// DiffAugmentedCell<CELL_ELEMENT>::fill_in_contribution_to_jacobian(residuals,jacobian);
			CELL_ELEMENT::fill_in_contribution_to_jacobian(residuals, jacobian);
			// Fill in contribution from external elements
			// this->fill_in_jacobian_from_external_interaction_by_fd(residuals,jacobian);
		}

		/// Add the element's contribution to its residuals vector,
		/// jacobian matrix and mass matrix
		void fill_in_contribution_to_jacobian_and_mass_matrix(Vector<double> &residuals,
																DenseMatrix<double> &jacobian,
																DenseMatrix<double> &mass_matrix)
		{
			//Call the standard (Broken) function
			//which will prevent these elements from being used
			//in eigenproblems until replaced.
			FiniteElement::fill_in_contribution_to_jacobian_and_mass_matrix(residuals,jacobian,mass_matrix);
		}
	};


	//========================================================================================================================================
	//========================================================================================================================================
	//Storage augmented cell elements with external mono and solid elements
	//========================================================================================================================================
	//========================================================================================================================================
	template<class CELL_ELEMENT, class EXT_MEMBRANE_POTENTIAL_ELEMENT, class EXT_SOLID_ELEMENT>
	class CellElementWithExternalMembranePotentialAndSolidElements	:
	// public virtual DiffAugmentedCell<CELL_ELEMENT>,
	public virtual CELL_ELEMENT,
	public virtual ElementWithExternalElement
	{
	public:
		CellElementWithExternalMembranePotentialAndSolidElements()	:
		// DiffAugmentedCell<CELL_ELEMENT>(),
		CELL_ELEMENT(),
		ElementWithExternalElement()
		{
			// std::cout << "setting ninteraction to 2:\n\tExternal Membrane Potential Element\n\tExternal Solid Element" << std::endl;
			ElementWithExternalElement::set_ninteraction(2);
			// std::cout << "set" << std::endl;
			// ElementWithExternalElement::ignore_external_geometric_data();
		}

		void identify_field_data_for_interactions(std::set<std::pair<Data*,unsigned> > &paired_field_data) override
		{
			// std::cout << "identify field data CellElementWithExternalMembranePotentialAndSolidElements" << std::endl;
			FiniteElement::identify_field_data_for_interactions(paired_field_data);
		}

		// void get_membrane_potential_CellInterface(const unsigned& ipt,
		// 											const Vector<double>& s,
		// 											const Vector<double>& x,
		// 											double& V) const
		// {
		// 	const unsigned mono_interaction = 0;
		// 	const unsigned solid_interaction = 1;

		// 	EXT_MEMBRANE_POTENTIAL_ELEMENT* ext_elmt_pt = dynamic_cast<EXT_MEMBRANE_POTENTIAL_ELEMENT*>(external_element_pt(mono_interaction, ipt));

		// 	if(ext_elmt_pt){
		// 			V = ext_elmt_pt->interpolated_vm_BaseCellMembranePotential(external_element_local_coord(mono_interaction, ipt));
		// 	}
		// }

		//!!!!!HOW TO ADD EXTERNAL GEOMETRIC DATA FROM ANIS_SOLID ELEMENT


		///\short Compute the element's residual vector and the Jacobian matrix.
		/// Jacobian is computed by finite-differencing
		void fill_in_contribution_to_jacobian(Vector<double> &residuals, 
												DenseMatrix<double> &jacobian)
		{	
			// ElementWithExternalElement::fill_in_contribution_to_jacobian(residuals,jacobian);
			CELL_ELEMENT::fill_in_contribution_to_jacobian(residuals,jacobian);
			// Fill in contribution from external elements
			// ElementWithExternalElement::fill_in_jacobian_from_external_interaction_by_fd(residuals,jacobian);
		}

		/// Add the element's contribution to its residuals vector,
		/// jacobian matrix and mass matrix
		void fill_in_contribution_to_jacobian_and_mass_matrix(Vector<double> &residuals,
																DenseMatrix<double> &jacobian,
																DenseMatrix<double> &mass_matrix)
		{
			//Call the standard (Broken) function
			//which will prevent these elements from being used
			//in eigenproblems until replaced.
			FiniteElement::fill_in_contribution_to_jacobian_and_mass_matrix(residuals,jacobian,mass_matrix);
		}
	};



	//========================================================================================================================================
	//========================================================================================================================================
	//Membrane potential element with external cell element
	//========================================================================================================================================
	//========================================================================================================================================
	template<class MEMBRANE_POTENTIAL_ELEMENT, class EXT_CELL_ELEMENT>
	class MembranePotentialElementWithExternalCellElement	:
	public virtual MEMBRANE_POTENTIAL_ELEMENT,
	public virtual ElementWithExternalElement
	{
	public:
		MembranePotentialElementWithExternalCellElement()	:
		MEMBRANE_POTENTIAL_ELEMENT(),
		ElementWithExternalElement()
		{
			ElementWithExternalElement::set_ninteraction(1);
		}

		void identify_field_data_for_interactions(std::set<std::pair<Data*,unsigned> > &paired_field_data) override
		{
			// std::cout << "identify field data MembranePotentialElementWithExternalCellElement" << std::endl;
			FiniteElement::identify_field_data_for_interactions(paired_field_data);
		}

		void get_source_BaseCellMembranePotential(const unsigned& ipt,
									const Vector<double>& x,
									double& source) const override
		{
			//Get the interaction numbers
			const unsigned cell_interaction = 0;

			//Zero the source
			source = 0.0;
			//Set the Vector to hold local coordinates
			Vector<double> s(MEMBRANE_POTENTIAL_ELEMENT::dim(),0.0);
			//Assign values of s
			for(unsigned i=0;i<MEMBRANE_POTENTIAL_ELEMENT::dim();i++) s[i] = this->integral_pt()->knot(ipt,i);

			//If a source function has been set, use it
			if(MEMBRANE_POTENTIAL_ELEMENT::Source_fct_pt!=0){
				//Get source strength
				(*MEMBRANE_POTENTIAL_ELEMENT::Source_fct_pt)(x,source);				
			}



			//Add the membrane current from the external cell interface element
			// source += dynamic_cast< DiffAugmentedCell<EXT_CELL_ELEMENT>*> //cast the external element
			source += dynamic_cast<EXT_CELL_ELEMENT*> //cast the external element
			(external_element_pt(cell_interaction, ipt))->			//get the external element pointer
				get_interpolated_membrane_current_CellInterface(
					external_element_local_coord(cell_interaction,ipt)); //call the membrane current function at the correct local coord
		}

		void get_diff_monodomain(const unsigned& ipt,
								const Vector<double> &s,
								const Vector<double>& x,
								DenseMatrix<double>& D) const
		{
			//Get the interaction numbers
			const unsigned cell_interaction = 0;
			const unsigned solid_interaction = 1;

			dynamic_cast<DiffAugmentedCell<EXT_CELL_ELEMENT>*>
			// dynamic_cast<EXT_CELL_ELEMENT*>
			(external_element_pt(cell_interaction, ipt))->
				get_interpolated_diffusion_matrix(external_element_local_coord(cell_interaction,ipt), D);
		}

		///\short Compute the element's residual vector
		void fill_in_contribution_to_residuals(Vector<double> &residuals)
		{	
			MEMBRANE_POTENTIAL_ELEMENT::fill_in_contribution_to_residuals(residuals);
		}

		///\short Compute the element's residual vector and the Jacobian matrix.
		/// Jacobian is computed by finite-differencing
		void fill_in_contribution_to_jacobian(Vector<double> &residuals, 
												DenseMatrix<double> &jacobian)
		{
			MEMBRANE_POTENTIAL_ELEMENT::fill_in_contribution_to_jacobian(residuals,jacobian);
			this->fill_in_jacobian_from_external_interaction_by_fd(residuals,jacobian);
		}

		/// Add the element's contribution to its residuals vector,
		/// jacobian matrix and mass matrix
		void fill_in_contribution_to_jacobian_and_mass_matrix(Vector<double> &residuals,
																DenseMatrix<double> &jacobian,
																DenseMatrix<double> &mass_matrix)
		{
			//Call the standard (Broken) function
			//which will prevent these elements from being used
			//in eigenproblems until replaced.
			FiniteElement::fill_in_contribution_to_jacobian_and_mass_matrix(residuals,jacobian,mass_matrix);
		}
	};



	//========================================================================================================================================
	//========================================================================================================================================
	//Membrane potential element with external cell and solid elements
	//========================================================================================================================================
	//========================================================================================================================================
	template<class MEMBRANE_POTENTIAL_ELEMENT, class EXT_CELL_ELEMENT, class EXT_SOLID_ELEMENT>
	class MembranePotentialElementWithExternalCellAndSolidElements	:
	public virtual MEMBRANE_POTENTIAL_ELEMENT,
	public virtual ElementWithExternalElement
	{
	public:
		MembranePotentialElementWithExternalCellAndSolidElements()	:
		MEMBRANE_POTENTIAL_ELEMENT(),
		ElementWithExternalElement()
		{
			ElementWithExternalElement::set_ninteraction(2);
		}

		void identify_field_data_for_interactions(std::set<std::pair<Data*,unsigned> > &paired_field_data) override
		{
			// std::cout << "identify field data MembranePotentialElementWithExternalCellAndSolidElements" << std::endl;
			FiniteElement::identify_field_data_for_interactions(paired_field_data);
		}

		void get_source_BaseCellMembranePotential(const unsigned& ipt,
									const Vector<double>& x,
									double& source) const
		{
			//Get the interaction numbers
			const unsigned cell_interaction = 0;
			const unsigned solid_interaction = 1;

			//Zero the source
			source = 0.0;
			//Set the Vector to hold local coordinates
			Vector<double> s(MEMBRANE_POTENTIAL_ELEMENT::dim(),0.0);
			//Assign values of s
			for(unsigned i=0;i<MEMBRANE_POTENTIAL_ELEMENT::dim();i++) s[i] = this->integral_pt()->knot(ipt,i);

			//If a source function has been set, use it
			if(MEMBRANE_POTENTIAL_ELEMENT::Source_fct_pt!=0){
				//Get source strength
				(*MEMBRANE_POTENTIAL_ELEMENT::Source_fct_pt)(x,source);				
			}



			//Add the membrane current from the external cell interface element
			source += dynamic_cast<EXT_CELL_ELEMENT*> //cast the external element
			(external_element_pt(cell_interaction, ipt))->			//get the external element pointer
				get_interpolated_membrane_current_CellInterface(
					external_element_local_coord(cell_interaction,ipt)); //call the membrane current function at the correct local coord
			// std::cout << source << std::endl;
		}

		// void get_diff_monodomain(const unsigned& ipt,
		// 							const Vector<double> &s,
		// 							const Vector<double>& x,
		// 							DenseMatrix<double>& D) const
		// {
		// 	//Get the interaction numbers
		// 	const unsigned cell_interaction = 0;
		// 	const unsigned solid_interaction = 1;

		// 	dynamic_cast<DiffAugmentedCell<EXT_CELL_ELEMENT>*>
		// 	(external_element_pt(cell_interaction, ipt))->
		// 		get_interpolated_diffusion_matrix(external_element_local_coord(cell_interaction,ipt),D);
		// }

		//!!!!!HOW TO ADD EXTERNAL GEOMETRIC DATA FROM ANIS_SOLID ELEMENT


		///\short Compute the element's residual vector and the Jacobian matrix.
		/// Jacobian is computed by finite-differencing
		void fill_in_contribution_to_jacobian(Vector<double> &residuals, 
												DenseMatrix<double> &jacobian)
		{
			// ElementWithExternalElement::fill_in_contribution_to_jacobian(residuals,jacobian);
			MEMBRANE_POTENTIAL_ELEMENT::fill_in_contribution_to_jacobian(residuals,jacobian);
			// ElementWithExternalElement::fill_in_jacobian_from_external_interaction_by_fd(residuals,jacobian);
		}

		/// Add the element's contribution to its residuals vector,
		/// jacobian matrix and mass matrix
		void fill_in_contribution_to_jacobian_and_mass_matrix(Vector<double> &residuals,
																DenseMatrix<double> &jacobian,
																DenseMatrix<double> &mass_matrix)
		{
			//Call the standard (Broken) function
			//which will prevent these elements from being used
			//in eigenproblems until replaced.
			FiniteElement::fill_in_contribution_to_jacobian_and_mass_matrix(residuals,jacobian,mass_matrix);
		}
	};



	//========================================================================================================================================
	//========================================================================================================================================
	//Anisotropic solid with external augmented cell elements
	//========================================================================================================================================
	//========================================================================================================================================

	template<class SOLID_ELEMENT, class EXT_CELL_ELEMENT>
	class SolidElementWithExternalCellElement	:
	public virtual SOLID_ELEMENT,
	public virtual ElementWithExternalElement
	{
	public:
		SolidElementWithExternalCellElement()	:
		SOLID_ELEMENT(),
		ElementWithExternalElement()
		{
			ElementWithExternalElement::set_ninteraction(0);
		}

		void identify_field_data_for_interactions(std::set<std::pair<Data*,unsigned> > &paired_field_data) override
		{
			// std::cout << "identify field data SolidElementWithExternalCellElement" << std::endl;
			FiniteElement::identify_field_data_for_interactions(paired_field_data);
		}

		void describe_local_dofs(std::ostream &out, const std::string &current_string) const
		{
			SOLID_ELEMENT::describe_local_dofs(out, current_string);
		}

		double prestress(const unsigned& i,
	                    const unsigned& j,
	                    const unsigned& ipt,
                        const Vector<double> &s,
	                    const Vector<double> xi) override
	   {
	 //   	//cell active stress
	 //   	double cell_active_stress=0.0;
	 //   	//get the vectors
		// DenseMatrix<double> A(this->dim(),0.0);
		// this->anisotropic_matrix(ipt, s, xi, A);

		// unsigned cell_interaction = 0;

	 //   	// EXT_CELL_ELEMENT* ext_element_pt = dynamic_cast<EXT_CELL_ELEMENT*>(external_element_pt(cell_interaction, ipt));

	 //   	// if(ext_element_pt != NULL){
		// 	// cell_active_stress = ext_element_pt->get_interpolated_active_stress(external_element_local_coord(cell_interaction, ipt));
		// 	// cell_active_stress = dynamic_cast<EXT_CELL_ELEMENT*>(external_element_pt(cell_interaction, ipt))
		// 	// 				->get_interpolated_active_stress(external_element_local_coord(cell_interaction, ipt));
		// // }

		// //we assume that the first vector is the fibre direction - makes sense, it is the most important one
	 //    if (this->Prestress_fct_pt==0)
	 //     {
	 //      return cell_active_stress*A(i,0)*A(j,0);
	 //     }
	 //    else
	 //     {
	 //      return (*this->Prestress_fct_pt)(i,j,xi) + cell_active_stress*A(i,0)*A(j,0);
	 //     }
	   }

		// void anisotropic_matrix(const unsigned& ipt,
		// 						const Vector<double> &s,
		// 						const Vector<double>& xi,
		// 						const DenseMatrix<double> &g,
		// 						const DenseMatrix<double> &G,
		// 						DenseMatrix<double>& A)
		// {
		// 	unsigned cell_interaction = 0;
		// 	dynamic_cast<DiffAugmentedCell<EXT_CELL_ELEMENT>*>
		// 		(external_element_pt(cell_interaction, ipt))->get_interpolated_preferential_vectors(external_element_local_coord(cell_interaction, ipt),A);
		// }


		///\short Compute the element's residual vector and the Jacobian matrix.
		/// Jacobian is computed by finite-differencing
		void fill_in_contribution_to_jacobian(Vector<double> &residuals, 
												DenseMatrix<double> &jacobian)
		{
			// ElementWithExternalElement::fill_in_contribution_to_jacobian(residuals,jacobian);
			SOLID_ELEMENT::fill_in_contribution_to_jacobian(residuals,jacobian);
			// ElementWithExternalElement::fill_in_jacobian_from_external_interaction_by_fd(residuals,jacobian);
		}

		/// Add the element's contribution to its residuals vector,
		/// jacobian matrix and mass matrix
		void fill_in_contribution_to_jacobian_and_mass_matrix(Vector<double> &residuals,
																DenseMatrix<double> &jacobian,
																DenseMatrix<double> &mass_matrix)
		{
			//Call the standard (Broken) function
			//which will prevent these elements from being used
			//in eigenproblems until replaced.
			FiniteElement::fill_in_contribution_to_jacobian_and_mass_matrix(residuals,jacobian,mass_matrix);
		}
	};

} //end of namespace

#endif