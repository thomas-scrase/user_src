//LIC// ====================================================================
//LIC// Contains elements which allow cell elements, mono elements, and 
//LIC// Anisotropic Solid elements to communicate with eachother when they
//LIC// exist in separate domain discretisations.
//LIC// Cell elements are always upgraded to DiffAugmented<CELL_ELEMENT>
//LIC//  in order to ensure that get_diff / get_preferential_vectors
//LIC//  functions are implemented properly. This is a pretty safe default method
//LIC//  to use since fibre/sheet aligment data is usually described at the
//LIC//  location of cells in tissue scan data.
//LIC// ====================================================================

//!!!!! Add class type of external elements to template class for the following elements
//		This will mean each of the following can be used with refineable and non-refineable external
//		elements. Obviously do not add class type parameter for external cell elements since these
//		cannot be refineable

//!!!!! replace get diff monodomain with a suitable base membrane potential element function

#ifndef OOMPH_MULTI_DOMAIN_CARDIAC_TISSUE_SUB_ELEMENTS
#define OOMPH_MULTI_DOMAIN_CARDIAC_TISSUE_SUB_ELEMENTS

// Config header generated by autoconfig
#ifdef HAVE_CONFIG_H
  #include <oomph-lib-config.h>
#endif


//Generic for the element with external element
// #include "generic.h"

//Include the storage_augmented_cell_elements header
#include "../toms_utilities/diff_augmented_cell_wrapper.h"

//Monodomain elements
#include "../cell_membrane_potential/cell_membrane_potential_elements.h"

//Solid elements for the external solid element for geometric data
#include "../anisotropic_solid/anisotropic_solid_elements.h"
#include "../anisotropic_solid/refineable_anisotropic_solid_elements.h"

//Cell interface elements (includes cell models)
#include "../cell_interface/cell_interface_elements.h"



namespace oomph{

	//========================================================================================================================================
	//========================================================================================================================================
	//Storage augmented cell element with external membrane potential element
	//========================================================================================================================================
	//========================================================================================================================================
	template<class CELL_ELEMENT, class EXT_MEMBRANE_POTENTIAL_ELEMENT>
	class CellElementWithExternalMembranePotentialElement	:
	public virtual DiffAugmentedCell<CELL_ELEMENT>,
	public virtual ElementWithExternalElement
	{
	public:
		CellElementWithExternalMembranePotentialElement()	:
		DiffAugmentedCell<CELL_ELEMENT>(),
		ElementWithExternalElement()
		{
			// std::cout << "setting ninteraction to 1:\n\t External Membrane Potential Element" << std::endl;
			ElementWithExternalElement::set_ninteraction(1);
			// std::cout << "set" << std::endl;
			// ElementWithExternalElement::ignore_external_geometric_data ();
		}

		void identify_field_data_for_interactions(std::set<std::pair<Data*,unsigned> > &paired_field_data) override
		{
			// std::cout << "identify field data CellElementWithExternalMembranePotentialElement" << std::endl;
			FiniteElement::identify_field_data_for_interactions(paired_field_data);
		}

		void get_membrane_potential_CellInterface(const unsigned& ipt,
												const Vector<double>& s,
												const Vector<double>& x,
												double& V) const override
		{
			const unsigned mono_interaction = 0;

			if(external_element_pt(mono_interaction,ipt) != nullptr){
				V = dynamic_cast<EXT_MEMBRANE_POTENTIAL_ELEMENT*>(external_element_pt(mono_interaction, ipt))->
							interpolated_vm_BaseCellMembranePotential(external_element_local_coord(mono_interaction, ipt));
			}
		}

		inline virtual void get_d_membrane_potential_dt_CellInterface(const unsigned& ipt,
																const Vector<double>& s,
																const Vector<double>& x,
																double& dVdt) const
		{
			const unsigned mono_interaction = 0;
			
			if(external_element_pt(mono_interaction,ipt) != nullptr){
				dVdt = dynamic_cast<EXT_MEMBRANE_POTENTIAL_ELEMENT*>(external_element_pt(mono_interaction, ipt))->
							interpolated_dvm_dt_BaseCellMembranePotential(external_element_local_coord(mono_interaction, ipt));
			}
		}
		
		///\short Compute the element's residual vector
		void fill_in_contribution_to_residuals(Vector<double> &residuals)
		{	
			CELL_ELEMENT::fill_in_contribution_to_residuals(residuals);
		}

		///\short Compute the element's residual vector and the Jacobian matrix.
		/// Jacobian is computed by finite-differencing
		void fill_in_contribution_to_jacobian(Vector<double> &residuals,
												DenseMatrix<double> &jacobian)
		{	
			// DiffAugmentedCell<CELL_ELEMENT>::fill_in_contribution_to_jacobian(residuals,jacobian);
			CELL_ELEMENT::fill_in_contribution_to_jacobian(residuals, jacobian);
			// Fill in contribution from external elements
			// this->fill_in_jacobian_from_external_interaction_by_fd(residuals,jacobian);
		}

		/// Add the element's contribution to its residuals vector,
		/// jacobian matrix and mass matrix
		void fill_in_contribution_to_jacobian_and_mass_matrix(Vector<double> &residuals,
																DenseMatrix<double> &jacobian,
																DenseMatrix<double> &mass_matrix)
		{
			//Call the standard (Broken) function
			//which will prevent these elements from being used
			//in eigenproblems until replaced.
			FiniteElement::fill_in_contribution_to_jacobian_and_mass_matrix(residuals,jacobian,mass_matrix);
		}
	};


	//========================================================================================================================================
	//========================================================================================================================================
	//Storage augmented cell elements with external mono and solid elements
	//========================================================================================================================================
	//========================================================================================================================================
	template<class CELL_ELEMENT, class EXT_MEMBRANE_POTENTIAL_ELEMENT, class EXT_SOLID_ELEMENT>
	class CellElementWithExternalMembranePotentialAndSolidElements	:
	public virtual DiffAugmentedCell<CELL_ELEMENT>,
	public virtual ElementWithExternalElement
	{
	public:
		CellElementWithExternalMembranePotentialAndSolidElements()	:
		DiffAugmentedCell<CELL_ELEMENT>(),
		ElementWithExternalElement()
		{
			// std::cout << "setting ninteraction to 2:\n\tExternal Membrane Potential Element\n\tExternal Solid Element" << std::endl;
			ElementWithExternalElement::set_ninteraction(1);
			// std::cout << "set" << std::endl;
			// ElementWithExternalElement::ignore_external_geometric_data();
		}

		void identify_field_data_for_interactions(std::set<std::pair<Data*,unsigned> > &paired_field_data) override
		{
			// std::cout << "identify field data CellElementWithExternalMembranePotentialAndSolidElements" << std::endl;
			FiniteElement::identify_field_data_for_interactions(paired_field_data);
		}

		void get_membrane_potential_CellInterface(const unsigned& ipt,
													const Vector<double>& s,
													const Vector<double>& x,
													double& V) const override
		{
			const unsigned mono_interaction = 0;
			const unsigned solid_interaction = 1;

			// oomph_info << "Attemping get ext element" << std::endl;
			if(external_element_pt(mono_interaction, ipt) != nullptr){
				EXT_MEMBRANE_POTENTIAL_ELEMENT* ext_elmt_pt = dynamic_cast<EXT_MEMBRANE_POTENTIAL_ELEMENT*>(external_element_pt(mono_interaction, ipt));
				// oomph_info << "Ext element exists" << std::endl;
				V = ext_elmt_pt->interpolated_vm_BaseCellMembranePotential(external_element_local_coord(mono_interaction, ipt));
			}
			// oomph_info << "Didn't die" << std::endl;
		}

		//!!!!!HOW TO ADD EXTERNAL GEOMETRIC DATA FROM ANIS_SOLID ELEMENT


		///\short Compute the element's residual vector
		void fill_in_contribution_to_residuals(Vector<double> &residuals)
		{	
			CELL_ELEMENT::fill_in_contribution_to_residuals(residuals);
		}

		///\short Compute the element's residual vector and the Jacobian matrix.
		/// Jacobian is computed by finite-differencing
		void fill_in_contribution_to_jacobian(Vector<double> &residuals, 
												DenseMatrix<double> &jacobian)
		{	
			// ElementWithExternalElement::fill_in_contribution_to_jacobian(residuals,jacobian);
			CELL_ELEMENT::fill_in_contribution_to_jacobian(residuals,jacobian);
			// Fill in contribution from external elements
			// this->fill_in_jacobian_from_external_interaction_by_fd(residuals,jacobian);
		}

		/// Add the element's contribution to its residuals vector,
		/// jacobian matrix and mass matrix
		void fill_in_contribution_to_jacobian_and_mass_matrix(Vector<double> &residuals,
																DenseMatrix<double> &jacobian,
																DenseMatrix<double> &mass_matrix)
		{
			//Call the standard (Broken) function
			//which will prevent these elements from being used
			//in eigenproblems until replaced.
			FiniteElement::fill_in_contribution_to_jacobian_and_mass_matrix(residuals,jacobian,mass_matrix);
		}
	};



	//========================================================================================================================================
	//========================================================================================================================================
	//Membrane potential element with external cell element
	//========================================================================================================================================
	//========================================================================================================================================
	template<class MEMBRANE_POTENTIAL_ELEMENT, class EXT_CELL_ELEMENT>
	class MembranePotentialElementWithExternalCellElement	:
	public virtual MEMBRANE_POTENTIAL_ELEMENT,
	public virtual ElementWithExternalElement
	{
	public:
		MembranePotentialElementWithExternalCellElement()	:
		MEMBRANE_POTENTIAL_ELEMENT(),
		ElementWithExternalElement()
		{
			ElementWithExternalElement::set_ninteraction(1);
		}

		void identify_field_data_for_interactions(std::set<std::pair<Data*,unsigned> > &paired_field_data) override
		{
			// std::cout << "identify field data MembranePotentialElementWithExternalCellElement" << std::endl;
			FiniteElement::identify_field_data_for_interactions(paired_field_data);
		}

		void get_source_BaseCellMembranePotential(const unsigned& ipt,
									const Vector<double>& x,
									double& source) const override
		{
			//Get the interaction numbers
			const unsigned cell_interaction = 0;

			//Zero the source
			source = 0.0;
			//Set the Vector to hold local coordinates
			Vector<double> s(MEMBRANE_POTENTIAL_ELEMENT::dim(),0.0);
			//Assign values of s
			for(unsigned i=0;i<MEMBRANE_POTENTIAL_ELEMENT::dim();i++) s[i] = this->integral_pt()->knot(ipt,i);

			//If a source function has been set, use it
			if(MEMBRANE_POTENTIAL_ELEMENT::Source_fct_pt!=0){
				//Get source strength
				(*MEMBRANE_POTENTIAL_ELEMENT::Source_fct_pt)(x,source);				
			}


			if(external_element_pt(cell_interaction, ipt) != nullptr){
				//Add the membrane current from the external cell interface element
				source += dynamic_cast<EXT_CELL_ELEMENT*> //cast the external element
				(external_element_pt(cell_interaction, ipt))->			//get the external element pointer
					get_interpolated_membrane_current_CellInterface(
						external_element_local_coord(cell_interaction,ipt)); //call the membrane current function at the correct local coord
			}
		}

		void get_diff_monodomain(const unsigned& ipt,
								const Vector<double> &s,
								const Vector<double>& x,
								DenseMatrix<double>& D) const override
		{
			//Get the interaction numbers
			const unsigned cell_interaction = 0;
			const unsigned solid_interaction = 1;
			if(external_element_pt(cell_interaction, ipt) != nullptr){
				dynamic_cast<DiffAugmentedCell<EXT_CELL_ELEMENT>*>
				// dynamic_cast<EXT_CELL_ELEMENT*>
				(external_element_pt(cell_interaction, ipt))->
					get_interpolated_diffusion_matrix(external_element_local_coord(cell_interaction,ipt), D);
			}

			// std::cout << "Diff Tensor: " << std::endl;	
			// for(unsigned i=0; i<this->dim(); i++){
			// 	for(unsigned j=0; j<this->dim(); j++){
			// 		std::cout << D(i,j) << " ";
			// 	}
			// 	std::cout << std::endl;
			// }
		}

		///\short Compute the element's residual vector
		void fill_in_contribution_to_residuals(Vector<double> &residuals)
		{	
			MEMBRANE_POTENTIAL_ELEMENT::fill_in_contribution_to_residuals(residuals);
		}

		///\short Compute the element's residual vector and the Jacobian matrix.
		/// Jacobian is computed by finite-differencing
		void fill_in_contribution_to_jacobian(Vector<double> &residuals, 
												DenseMatrix<double> &jacobian)
		{
			MEMBRANE_POTENTIAL_ELEMENT::fill_in_contribution_to_jacobian(residuals,jacobian);
			// this->fill_in_jacobian_from_external_interaction_by_fd(residuals,jacobian);
		}

		/// Add the element's contribution to its residuals vector,
		/// jacobian matrix and mass matrix
		void fill_in_contribution_to_jacobian_and_mass_matrix(Vector<double> &residuals,
																DenseMatrix<double> &jacobian,
																DenseMatrix<double> &mass_matrix)
		{
			//Call the standard (Broken) function
			//which will prevent these elements from being used
			//in eigenproblems until replaced.
			FiniteElement::fill_in_contribution_to_jacobian_and_mass_matrix(residuals,jacobian,mass_matrix);
		}
	};



	//========================================================================================================================================
	//========================================================================================================================================
	//Membrane potential element with external cell and solid elements
	//========================================================================================================================================
	//========================================================================================================================================
	template<class MEMBRANE_POTENTIAL_ELEMENT, class EXT_CELL_ELEMENT, class EXT_SOLID_ELEMENT>
	class MembranePotentialElementWithExternalCellAndSolidElements	:
	public virtual MEMBRANE_POTENTIAL_ELEMENT,
	public virtual ElementWithExternalElement
	{
	public:
		MembranePotentialElementWithExternalCellAndSolidElements()	:
		MEMBRANE_POTENTIAL_ELEMENT(),
		ElementWithExternalElement()
		{
			ElementWithExternalElement::set_ninteraction(2);
		}

		void identify_field_data_for_interactions(std::set<std::pair<Data*,unsigned> > &paired_field_data) override
		{
			// std::cout << "identify field data MembranePotentialElementWithExternalCellAndSolidElements" << std::endl;
			FiniteElement::identify_field_data_for_interactions(paired_field_data);
		}

		void get_source_BaseCellMembranePotential(const unsigned& ipt,
									const Vector<double>& x,
									double& source) const override
		{
			//Get the interaction numbers
			const unsigned cell_interaction = 0;
			const unsigned solid_interaction = 1;

			//Zero the source
			source = 0.0;
			//Set the Vector to hold local coordinates
			Vector<double> s(MEMBRANE_POTENTIAL_ELEMENT::dim(),0.0);
			//Assign values of s
			for(unsigned i=0;i<MEMBRANE_POTENTIAL_ELEMENT::dim();i++) s[i] = this->integral_pt()->knot(ipt,i);

			//If a source function has been set, use it
			if(MEMBRANE_POTENTIAL_ELEMENT::Source_fct_pt!=0){
				//Get source strength
				(*MEMBRANE_POTENTIAL_ELEMENT::Source_fct_pt)(x,source);				
			}


			if(external_element_pt(cell_interaction, ipt) != nullptr){
				//Add the membrane current from the external cell interface element
				source += dynamic_cast<EXT_CELL_ELEMENT*> //cast the external element
				(external_element_pt(cell_interaction, ipt))->			//get the external element pointer
					get_interpolated_membrane_current_CellInterface(
						external_element_local_coord(cell_interaction,ipt)); //call the membrane current function at the correct local coord
			}
		}

		void get_diff_monodomain(const unsigned& ipt,
									const Vector<double> &s,
									const Vector<double>& x,
									DenseMatrix<double>& D) const override
		{
			//Get the interaction numbers
			const unsigned cell_interaction = 0;
			const unsigned solid_interaction = 1;
			if(external_element_pt(cell_interaction, ipt) != nullptr){
				dynamic_cast<DiffAugmentedCell<EXT_CELL_ELEMENT>*>
				// dynamic_cast<EXT_CELL_ELEMENT*>
				(external_element_pt(cell_interaction, ipt))->
					get_interpolated_diffusion_matrix(external_element_local_coord(cell_interaction,ipt),D);
			}

			// std::cout << "Diff Tensor: " << std::endl;	
			// for(unsigned i=0; i<this->dim(); i++){
			// 	for(unsigned j=0; j<this->dim(); j++){
			// 		std::cout << D(i,j) << " ";
			// 	}
			// 	std::cout << std::endl;
			// }
		}

		//!!!!!HOW TO ADD EXTERNAL GEOMETRIC DATA FROM ANIS_SOLID ELEMENT


		///\short Compute the element's residual vector
		void fill_in_contribution_to_residuals(Vector<double> &residuals)
		{	
			MEMBRANE_POTENTIAL_ELEMENT::fill_in_contribution_to_residuals(residuals);
		}

		///\short Compute the element's residual vector and the Jacobian matrix.
		/// Jacobian is computed by finite-differencing
		void fill_in_contribution_to_jacobian(Vector<double> &residuals, 
												DenseMatrix<double> &jacobian)
		{
			// ElementWithExternalElement::fill_in_contribution_to_jacobian(residuals,jacobian);
			MEMBRANE_POTENTIAL_ELEMENT::fill_in_contribution_to_jacobian(residuals,jacobian);
			// this->fill_in_jacobian_from_external_interaction_by_fd(residuals,jacobian);
		}

		/// Add the element's contribution to its residuals vector,
		/// jacobian matrix and mass matrix
		void fill_in_contribution_to_jacobian_and_mass_matrix(Vector<double> &residuals,
																DenseMatrix<double> &jacobian,
																DenseMatrix<double> &mass_matrix)
		{
			//Call the standard (Broken) function
			//which will prevent these elements from being used
			//in eigenproblems until replaced.
			FiniteElement::fill_in_contribution_to_jacobian_and_mass_matrix(residuals,jacobian,mass_matrix);
		}
	};



	//========================================================================================================================================
	//========================================================================================================================================
	//Anisotropic solid with external augmented cell elements
	//========================================================================================================================================
	//========================================================================================================================================

	template<class SOLID_ELEMENT, class EXT_CELL_ELEMENT>
	class SolidElementWithExternalCellElement	:
	public virtual SOLID_ELEMENT,
	public virtual ElementWithExternalElement
	{
	public:
		SolidElementWithExternalCellElement()	:
		SOLID_ELEMENT(),
		ElementWithExternalElement()
		{
			ElementWithExternalElement::set_ninteraction(1);
		}

		void identify_field_data_for_interactions(std::set<std::pair<Data*,unsigned> > &paired_field_data) override
		{
			FiniteElement::identify_field_data_for_interactions(paired_field_data);
		}

		void describe_local_dofs(std::ostream &out, const std::string &current_string) const
		{
			SOLID_ELEMENT::describe_local_dofs(out, current_string);
		}

		void driving_strain(const unsigned& ipt,
                           const Vector<double>& s,
                           const Vector<double>& xi,
                           Vector<double>& V)
		{	
			unsigned cell_interaction = 0;
			//Resize the vector of strains
			V.resize(this->dim());
			for(unsigned i=0; i<this->dim(); i++){
				V[i] = 0.0;
			}

			if(external_element_pt(cell_interaction, ipt) != nullptr){
				V[0] = dynamic_cast<EXT_CELL_ELEMENT*>(external_element_pt(cell_interaction, ipt))
					->get_interpolated_active_stress(external_element_local_coord(cell_interaction, ipt));
			}
		}

	   //!!!!!Dies when this is uncommented
		void anisotropic_matrix(const unsigned& ipt,
								const Vector<double> &s,
								const Vector<double>& xi,
								DenseMatrix<double>& A) override
		{
			A.resize(this->dim(), this->dim());
			//If there is an external cell element then get the anisotropic data from it
			unsigned cell_interaction = 0;
			DiffAugmentedCell<EXT_CELL_ELEMENT>* ext_element_pt = dynamic_cast<DiffAugmentedCell<EXT_CELL_ELEMENT>*>(external_element_pt(cell_interaction, ipt));
			
			if(ext_element_pt != nullptr){
				ext_element_pt->get_interpolated_preferential_vectors(external_element_local_coord(cell_interaction, ipt),A);
			}
			//Otherwise perform the default fill in
			else{
				if(this->Anisotropic_matrix_fct_pt==0){
					// std::cout << "boom" << std::endl;
					A.resize(this->dim(),this->dim());
					for(unsigned i=0; i<this->dim(); i++){
						for(unsigned j=0; j<this->dim(); j++){
							A(i,j) = 0.0;
						}
					}
				}
				//or use a matrix fct pt if one exists
				else{
					(*this->Anisotropic_matrix_fct_pt)(ipt, s, xi, A);
				}
			}
		}


		///\short Compute the element's residual vector and the Jacobian matrix.
		/// Jacobian is computed by finite-differencing
		void fill_in_contribution_to_jacobian(Vector<double> &residuals, 
												DenseMatrix<double> &jacobian)
		{
			// ElementWithExternalElement::fill_in_contribution_to_jacobian(residuals,jacobian);
			SOLID_ELEMENT::fill_in_contribution_to_jacobian(residuals,jacobian);
			// ElementWithExternalElement::fill_in_jacobian_from_external_interaction_by_fd(residuals,jacobian);
		}

		/// Add the element's contribution to its residuals vector,
		/// jacobian matrix and mass matrix
		void fill_in_contribution_to_jacobian_and_mass_matrix(Vector<double> &residuals,
																DenseMatrix<double> &jacobian,
																DenseMatrix<double> &mass_matrix)
		{
			//Call the standard (Broken) function
			//which will prevent these elements from being used
			//in eigenproblems until replaced.
			FiniteElement::fill_in_contribution_to_jacobian_and_mass_matrix(residuals,jacobian,mass_matrix);
		}
	};

} //end of namespace

#endif