//LIC// ====================================================================
//LIC// This file contains component_multiphysics elements, elements which are
//LIC//	themselves useless but occupy a domain in a multi-discretised multi-
//LIC//	physics element.


//LIC// This file contains the multi domain expansion for 
//LIC//	QStorageAugmentedCellElement and TStorageAugmentedCellElement
//LIC// which allows for them to be used in multi-domain discretisation problems
//LIC// along with anisotropic_solid element and monodomain_element each in
//LIC// their own distinctly discretised domains


//LIC// This file also contains the multi domain expansion for the monodomain
//LIC// element which allows for it to be used in multi-domain discretisation
//LIC// problems along with anisotropic_solid element and cell_interface_elements,
//LIC// each in their own distinctly discretised domains.
//LIC//
//LIC// This file also contains the refineable monodomain element with exeternal
//LIC// elements.


//LIC// This file contains the multi domain expansion for the anisotropic_solid
//LIC// element which allows for it to be used in multi-domain discretisation
//LIC// problems along with storage_augmented_cell_interface_element,
//LIC// each in their own distinctly discretised domains.
//LIC//
//LIC// This file also contains the refineable solid element with exeternal Q
//LIC// element.
//LIC// ====================================================================

#ifndef OOMPH_MULTI_DOMAIN_CARDIAC_TISSUE_SUB_ELEMENTS
#define OOMPH_MULTI_DOMAIN_CARDIAC_TISSUE_SUB_ELEMENTS

// Config header generated by autoconfig
#ifdef HAVE_CONFIG_H
  #include <oomph-lib-config.h>
#endif

//Generic for the element with external element
#include "generic.h"

//Include the storage_augmented_cell_elements header
#include "storage_augmented_cell_elements.h"

//Monodomain elements
#include "../monodomain/monodomain_elements.h"
#include "../monodomain/refineable_monodomain_elements.h"

//Solid elements for the external solid element for geometric data
#include "../anisotropic_solid/anisotropic_solid_elements.h"
#include "../anisotropic_solid/refineable_anisotropic_solid_elements.h"

//Cell interface elements (includes cell models)
#include "../cell_interface/cell_interface_elements.h"




namespace oomph{

	//========================================================================================================================================
	//========================================================================================================================================
	//Storage augmented cell elements with external mono and solid elements
	//========================================================================================================================================
	//========================================================================================================================================


	template<unsigned DIM, unsigned NUM_VARS, unsigned NNODE_1D>
	class QStorageAugmentedCellElementWithExternalMonoAndSolidElements	:
	public virtual QStorageAugmentedCellElement<DIM, NUM_VARS, NNODE_1D>,
	public virtual ElementWithExternalElement
	{
	public:
		QStorageAugmentedCellElementWithExternalMonoAndSolidElements()	:
		QStorageAugmentedCellElement<DIM, NUM_VARS, NNODE_1D>(),
		ElementWithExternalElement()
		{
			this->set_ninteraction(2);
		}

		void get_membrane_potential_CellInterface(const unsigned& ipt,
													const Vector<double>& s,
													const Vector<double>& x,
													double& V) const
		{
			const unsigned mono_interaction = 0;
			const unsigned solid_interaction = 1;

			const double interpolated_V = dynamic_cast<MonodomainEquations<DIM>*>
				(external_element_pt(mono_interaction, ipt))->interpolated_u_monodomain(external_element_local_coord(mono_interaction, ipt));

			V = interpolated_V;
		}

		//!!!!!HOW TO ADD EXTERNAL GEOMETRIC DATA FROM ANIS_SOLID ELEMENT


		///\short Compute the element's residual vector and the Jacobian matrix.
		/// Jacobian is computed by finite-differencing
		void fill_in_contribution_to_jacobian(Vector<double> &residuals, 
												DenseMatrix<double> &jacobian)
		{
			ElementWithExternalElement::fill_in_contribution_to_jacobian(residuals,jacobian);
		}

		/// Add the element's contribution to its residuals vector,
		/// jacobian matrix and mass matrix
		void fill_in_contribution_to_jacobian_and_mass_matrix(Vector<double> &residuals,
																DenseMatrix<double> &jacobian,
																DenseMatrix<double> &mass_matrix)
		{
			//Call the standard (Broken) function
			//which will prevent these elements from being used
			//in eigenproblems until replaced.
			FiniteElement::fill_in_contribution_to_jacobian_and_mass_matrix(residuals,jacobian,mass_matrix);
		}
	};

	//!!!!!Add TStorageAugmentedCellElementWithExternalMonoAndSolidElements































	//========================================================================================================================================
	//========================================================================================================================================
	//Monodomain with external cell and solid elements
	//========================================================================================================================================
	//========================================================================================================================================

	template<unsigned DIM, unsigned NNODE_1D>
	class QMonodomainElementWithExternalCellAndSolidElements	:
	public virtual QMonodomainElement<DIM, NNODE_1D>,
	public virtual ElementWithExternalElement
	{
	private:
		QMonodomainElementWithExternalCellAndSolidElements()	:
		QMonodomainElement<DIM, NNODE_1D>(),
		ElementWithExternalElement()
		{
			this->set_ninteraction(2);
		}

		void get_source_monodomain(const unsigned& ipt,
									const Vector<double>& x,
									double& source) const
		{
			//Get the interaction numbers
			const unsigned cell_interaction = 0;
			const unsigned solid_interaction = 1;

			//Zero the source
			source = 0.0;
			//Set the Vector to hold local coordinates
			Vector<double> s(DIM,0.0);
			//Assign values of s
			for(unsigned i=0;i<DIM;i++) s[i] = this->integral_pt()->knot(ipt,i);
			//If a source function has been set, use it
			if(QMonodomainElement<DIM, NNODE_1D>::Source_fct_pt!=0){
				//Get source strength
				(*QMonodomainElement<DIM, NNODE_1D>::Source_fct_pt)(x,source);
			}

			//Add the membrane current from the external cell interface element
			source += dynamic_cast<CellInterfaceEquations<DIM>*> //cast the external element
			(external_element_pt(cell_interaction, ipt))->			//get the external element pointer
				interpolated_membrane_current_CellInterface(external_element_local_coord(cell_interaction,ipt)); //call the membrane current function at the correct local coord
		}

		void get_diff_monodomain(const unsigned& ipt,
									const Vector<double> &s,
									const Vector<double>& x,
									DenseMatrix<double>& D) const
		{
			//Get the interaction numbers
			const unsigned cell_interaction = 0;
			const unsigned solid_interaction = 1;

			D = dynamic_cast<VectorWithDiffusionStorageEnrichmentEquations<DIM*(DIM+1)>*>
			(external_element_pt(cell_interaction, ipt))->
				get_interpolated_diffusion_matrix_augmented_cell(external_element_local_coord(cell_interaction,ipt));
		}

		//!!!!!HOW TO ADD EXTERNAL GEOMETRIC DATA FROM ANIS_SOLID ELEMENT


		///\short Compute the element's residual vector and the Jacobian matrix.
		/// Jacobian is computed by finite-differencing
		void fill_in_contribution_to_jacobian(Vector<double> &residuals, 
												DenseMatrix<double> &jacobian)
		{
			ElementWithExternalElement::fill_in_contribution_to_jacobian(residuals,jacobian);
		}

		/// Add the element's contribution to its residuals vector,
		/// jacobian matrix and mass matrix
		void fill_in_contribution_to_jacobian_and_mass_matrix(Vector<double> &residuals,
																DenseMatrix<double> &jacobian,
																DenseMatrix<double> &mass_matrix)
		{
			//Call the standard (Broken) function
			//which will prevent these elements from being used
			//in eigenproblems until replaced.
			FiniteElement::fill_in_contribution_to_jacobian_and_mass_matrix(residuals,jacobian,mass_matrix);
		}
	};


	//!!!!!ADD TMonodomainElementWithExternalCellAndSolidElements

	template<unsigned DIM, unsigned NNODE_1D>
	class RefineableQMonodomainElementWithExternalCellAndSolidElements	:
	public virtual RefineableQMonodomainElement<DIM, NNODE_1D>,
	public virtual ElementWithExternalElement
	{
	private:
		RefineableQMonodomainElementWithExternalCellAndSolidElements()	:
		RefineableQMonodomainElement<DIM, NNODE_1D>(),
		ElementWithExternalElement()
		{
			this->set_ninteraction(2);
		}

		void get_source_monodomain(const unsigned& ipt,
									const Vector<double>& x,
									double& source) const
		{
			//Get the interaction numbers
			const unsigned cell_interaction = 0;
			const unsigned solid_interaction = 1;

			//Zero the source
			source = 0.0;
			//Set the Vector to hold local coordinates
			Vector<double> s(DIM,0.0);
			//Assign values of s
			for(unsigned i=0;i<DIM;i++) s[i] = this->integral_pt()->knot(ipt,i);
			//If a source function has been set, use it
			if(RefineableQMonodomainElement<DIM, NNODE_1D>::Source_fct_pt!=0){
				//Get source strength
				(*RefineableQMonodomainElement<DIM, NNODE_1D>::Source_fct_pt)(x,source);
			}

			//Add the membrane current from the external cell interface element
			source += dynamic_cast<CellInterfaceEquations<DIM>*> //cast the external element
			(external_element_pt(cell_interaction, ipt))->			//get the external element pointer
				interpolated_membrane_current_CellInterface(external_element_local_coord(cell_interaction,ipt)); //call the membrane current function at the correct local coord
		}

		void get_diff_monodomain(const unsigned& ipt,
									const Vector<double> &s,
									const Vector<double>& x,
									DenseMatrix<double>& D) const
		{
			//Get the interaction numbers
			const unsigned cell_interaction = 0;
			const unsigned solid_interaction = 1;
			D = dynamic_cast<VectorWithDiffusionStorageEnrichmentEquations<DIM*(DIM+1)>*>
			(external_element_pt(cell_interaction, ipt))->
				get_interpolated_diffusion_matrix_augmented_cell(external_element_local_coord(cell_interaction,ipt));
		}

		//!!!!!HOW TO ADD EXTERNAL GEOMETRIC DATA FROM ANIS_SOLID ELEMENT


		///\short Compute the element's residual vector and the Jacobian matrix.
		/// Jacobian is computed by finite-differencing
		void fill_in_contribution_to_jacobian(Vector<double> &residuals, 
												DenseMatrix<double> &jacobian)
		{
			ElementWithExternalElement::fill_in_contribution_to_jacobian(residuals,jacobian);
		}

		/// Add the element's contribution to its residuals vector,
		/// jacobian matrix and mass matrix
		void fill_in_contribution_to_jacobian_and_mass_matrix(Vector<double> &residuals,
																DenseMatrix<double> &jacobian,
																DenseMatrix<double> &mass_matrix)
		{
			//Call the standard (Broken) function
			//which will prevent these elements from being used
			//in eigenproblems until replaced.
			FiniteElement::fill_in_contribution_to_jacobian_and_mass_matrix(residuals,jacobian,mass_matrix);
		}
	};





















	//========================================================================================================================================
	//========================================================================================================================================
	//Anisotropic solid with external augmented cell elements
	//========================================================================================================================================
	//========================================================================================================================================

	template<unsigned DIM, unsigned NNODE_1D>
	class QAnisotropicSolidElementWithExternalAugmentedCellElement	:
	public virtual QAnisotropicPVDElement<DIM, NNODE_1D>,
	public virtual ElementWithExternalElement
	{
	public:
		QAnisotropicSolidElementWithExternalAugmentedCellElement()	:
		QAnisotropicPVDElement<DIM, NNODE_1D>(),
		ElementWithExternalElement()
		{
			this->set_ninteraction(1);
		}

		void describe_local_dofs(std::ostream &out, const std::string &current_string) const
		{
			QAnisotropicPVDElement<DIM, NNODE_1D>::describe_local_dofs(out, current_string);
		}

		void anisotropic_matrix(const unsigned& ipt,
								const Vector<double> &s,
								const Vector<double>& xi,
								const DenseMatrix<double> &g,
								const DenseMatrix<double> &G,
								DenseMatrix<double>& A)
		{
			unsigned cell_interaction = 0;
			A = dynamic_cast<VectorWithDiffusionStorageEnrichmentEquations<DIM*(DIM+1)>*>
				(external_element_pt(cell_interaction, ipt))->get_interpolated_fibre_orientation_augmented_cell(external_element_local_coord(cell_interaction, ipt));
		}

		void anisotropic_vector(const unsigned& ipt,
								const Vector<double> &s,
								const Vector<double>& xi,
								const DenseMatrix<double> &g, 
								const DenseMatrix<double> &G,
								Vector<double>& lambda) const
		{
			unsigned cell_interaction = 0;
			lambda.resize(1);
			lambda[0] = dynamic_cast<CellInterfaceEquations<DIM>*>
			(external_element_pt(cell_interaction, ipt))->get_interpolated_cell_active_strain(external_element_local_coord(cell_interaction, ipt));
		}


		///\short Compute the element's residual vector and the Jacobian matrix.
		/// Jacobian is computed by finite-differencing
		void fill_in_contribution_to_jacobian(Vector<double> &residuals, 
												DenseMatrix<double> &jacobian)
		{
			ElementWithExternalElement::fill_in_contribution_to_jacobian(residuals,jacobian);
		}

		/// Add the element's contribution to its residuals vector,
		/// jacobian matrix and mass matrix
		void fill_in_contribution_to_jacobian_and_mass_matrix(Vector<double> &residuals,
																DenseMatrix<double> &jacobian,
																DenseMatrix<double> &mass_matrix)
		{
			//Call the standard (Broken) function
			//which will prevent these elements from being used
			//in eigenproblems until replaced.
			FiniteElement::fill_in_contribution_to_jacobian_and_mass_matrix(residuals,jacobian,mass_matrix);
		}
	};

	//!!!!!ADD TAnisotropicSolidElementWithExternalAugmentedCellElement

	template<unsigned DIM, unsigned NNODE_1D>
	class RefineableQAnisotropicSolidElementWithExternalAugmentedCellElement	:
	public virtual RefineableQAnisotropicPVDElement<DIM, NNODE_1D>,
	public virtual ElementWithExternalElement
	{
	public:
		RefineableQAnisotropicSolidElementWithExternalAugmentedCellElement()	:
		RefineableQAnisotropicPVDElement<DIM, NNODE_1D>(),
		ElementWithExternalElement()
		{
			this->set_ninteraction(1);
		}

		void describe_local_dofs(std::ostream &out, const std::string &current_string) const
		{
			RefineableQAnisotropicPVDElement<DIM, NNODE_1D>::describe_local_dofs(out, current_string);
		}

		void anisotropic_matrix(const unsigned& ipt,
								const Vector<double> &s,
								const Vector<double>& xi,
								const DenseMatrix<double> &g,
								const DenseMatrix<double> &G,
								DenseMatrix<double>& A)
		{
			unsigned cell_interaction = 0;
			A = dynamic_cast<VectorWithDiffusionStorageEnrichmentEquations<DIM*(DIM+1)>*>
				(external_element_pt(cell_interaction, ipt))->get_interpolated_fibre_orientation_augmented_cell(external_element_local_coord(cell_interaction, ipt));
		}

		void anisotropic_vector(const unsigned& ipt,
								const Vector<double> &s,
								const Vector<double>& xi,
								const DenseMatrix<double> &g, 
								const DenseMatrix<double> &G,
								Vector<double>& lambda) const
		{
			unsigned cell_interaction = 0;
			lambda.resize(1);
			lambda[0] = dynamic_cast<CellInterfaceEquations<DIM>*>
			(external_element_pt(cell_interaction, ipt))->get_interpolated_cell_active_strain(external_element_local_coord(cell_interaction, ipt));
		}


		///\short Compute the element's residual vector and the Jacobian matrix.
		/// Jacobian is computed by finite-differencing
		void fill_in_contribution_to_jacobian(Vector<double> &residuals, 
												DenseMatrix<double> &jacobian)
		{
			ElementWithExternalElement::fill_in_contribution_to_jacobian(residuals,jacobian);
		}

		/// Add the element's contribution to its residuals vector,
		/// jacobian matrix and mass matrix
		void fill_in_contribution_to_jacobian_and_mass_matrix(Vector<double> &residuals,
																DenseMatrix<double> &jacobian,
																DenseMatrix<double> &mass_matrix)
		{
			//Call the standard (Broken) function
			//which will prevent these elements from being used
			//in eigenproblems until replaced.
			FiniteElement::fill_in_contribution_to_jacobian_and_mass_matrix(residuals,jacobian,mass_matrix);
		}
	};


} //end of namespace

#endif