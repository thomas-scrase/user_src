//LIC// ====================================================================
//LIC// Contains elements which allow cell elements, mono elements, and 
//LIC// Anisotropic Solid elements to communicate with eachother when they
//LIC// exist in separate domain discretisations.
//LIC// Cell elements are always upgraded to DiffAugmented<CELL_ELEMENT>
//LIC//  in order to ensure that get_diff / get_preferential_vectors
//LIC//  functions are implemented properly. This is a pretty safe default method
//LIC//  to use since fibre/sheet aligment data is usually described at the
//LIC//  location of cells in tissue scan data.
//LIC// ====================================================================

//!!!!! Add class type of external elements to template class for the following elements
//		This will mean each of the following can be used with refineable and non-refineable external
//		elements. Obviously do not add class type parameter for external cell elements since these
//		cannot be refineable

#ifndef OOMPH_MULTI_DOMAIN_CARDIAC_TISSUE_SUB_ELEMENTS
#define OOMPH_MULTI_DOMAIN_CARDIAC_TISSUE_SUB_ELEMENTS

// Config header generated by autoconfig
#ifdef HAVE_CONFIG_H
  #include <oomph-lib-config.h>
#endif

//Generic for the element with external element
// #include "generic.h"

//Include the storage_augmented_cell_elements header
#include "../toms_utilities/diff_augmented_cell_wrapper.h"

//Monodomain elements
#include "../cell_membrane_potential/cell_membrane_potential_elements.h"

//Solid elements for the external solid element for geometric data
#include "../anisotropic_solid/anisotropic_solid_elements.h"
#include "../anisotropic_solid/refineable_anisotropic_solid_elements.h"

//Cell interface elements (includes cell models)
#include "../cell_interface/cell_interface_elements.h"



namespace oomph{

	//========================================================================================================================================
	//========================================================================================================================================
	//Storage augmented cell element with external membrane potential element
	//========================================================================================================================================
	//========================================================================================================================================
	template<class CELL_ELEMENT, class EXT_MEMBRANE_POTENTIAL_ELEMENT>
	class CellElementWithExternalMembranePotentialElement	:
	public virtual DiffAugmentedCell<CELL_ELEMENT>,
	public virtual ElementWithExternalElement
	{
	public:
		CellElementWithExternalMembranePotentialElement()	:
		DiffAugmentedCell<CELL_ELEMENT>(),
		ElementWithExternalElement()
		{
			std::cout << "setting ninteraction to 1:\n\t External Membrane Potential Element" << std::endl;
			this->set_ninteraction(1);
			std::cout << "set" << std::endl;
		}

		void get_membrane_potential_CellInterface(const unsigned& ipt,
													const Vector<double>& s,
													const Vector<double>& x,
													double& V) const
		{
			const unsigned mono_interaction = 0;

			if(external_element_pt(mono_interaction,ipt)){
					V = dynamic_cast<EXT_MEMBRANE_POTENTIAL_ELEMENT*>(external_element_pt(mono_interaction, ipt))->
							interpolated_vm_BaseCellMembranePotential(external_element_local_coord(mono_interaction, ipt));
			}
		}

		///\short Compute the element's residual vector and the Jacobian matrix.
		/// Jacobian is computed by finite-differencing
		void fill_in_contribution_to_jacobian(Vector<double> &residuals, 
												DenseMatrix<double> &jacobian)
		{	
			DiffAugmentedCell<CELL_ELEMENT>::fill_in_contribution_to_jacobian(residuals,jacobian);
			// Fill in contribution from external elements
			this->fill_in_jacobian_from_external_interaction_by_fd(residuals,jacobian);
		}

		/// Add the element's contribution to its residuals vector,
		/// jacobian matrix and mass matrix
		void fill_in_contribution_to_jacobian_and_mass_matrix(Vector<double> &residuals,
																DenseMatrix<double> &jacobian,
																DenseMatrix<double> &mass_matrix)
		{
			//Call the standard (Broken) function
			//which will prevent these elements from being used
			//in eigenproblems until replaced.
			FiniteElement::fill_in_contribution_to_jacobian_and_mass_matrix(residuals,jacobian,mass_matrix);
		}
	};


	//========================================================================================================================================
	//========================================================================================================================================
	//Storage augmented cell elements with external mono and solid elements
	//========================================================================================================================================
	//========================================================================================================================================
	template<class CELL_ELEMENT, class EXT_MEMBRANE_POTENTIAL_ELEMENT, class EXT_SOLID_ELEMENT>
	class CellElementWithExternalMembranePotentialAndSolidElements	:
	public virtual DiffAugmentedCell<CELL_ELEMENT>,
	public virtual ElementWithExternalElement
	{
	public:
		CellElementWithExternalMembranePotentialAndSolidElements()	:
		DiffAugmentedCell<CELL_ELEMENT>(),
		ElementWithExternalElement()
		{
			std::cout << "setting ninteraction to 2:\n\tExternal Membrane Potential Element\n\tExternal Solid Element" << std::endl;
			this->set_ninteraction(2);
			std::cout << "set" << std::endl;
		}

		void get_membrane_potential_CellInterface(const unsigned& ipt,
													const Vector<double>& s,
													const Vector<double>& x,
													double& V) const
		{
			const unsigned mono_interaction = 0;
			const unsigned solid_interaction = 1;

			if(external_element_pt(mono_interaction,ipt)){
					V = dynamic_cast<EXT_MEMBRANE_POTENTIAL_ELEMENT*>(external_element_pt(mono_interaction, ipt))->
							interpolated_vm_BaseCellMembranePotential(external_element_local_coord(mono_interaction, ipt));
			}
		}

		//!!!!!HOW TO ADD EXTERNAL GEOMETRIC DATA FROM ANIS_SOLID ELEMENT


		///\short Compute the element's residual vector and the Jacobian matrix.
		/// Jacobian is computed by finite-differencing
		void fill_in_contribution_to_jacobian(Vector<double> &residuals, 
												DenseMatrix<double> &jacobian)
		{	
			// ElementWithExternalElement::fill_in_contribution_to_jacobian(residuals,jacobian);
			DiffAugmentedCell<CELL_ELEMENT>::fill_in_contribution_to_jacobian(residuals,jacobian);
			// Fill in contribution from external elements
			this->fill_in_jacobian_from_external_interaction_by_fd(residuals,jacobian);
		}

		/// Add the element's contribution to its residuals vector,
		/// jacobian matrix and mass matrix
		void fill_in_contribution_to_jacobian_and_mass_matrix(Vector<double> &residuals,
																DenseMatrix<double> &jacobian,
																DenseMatrix<double> &mass_matrix)
		{
			//Call the standard (Broken) function
			//which will prevent these elements from being used
			//in eigenproblems until replaced.
			FiniteElement::fill_in_contribution_to_jacobian_and_mass_matrix(residuals,jacobian,mass_matrix);
		}
	};



	//========================================================================================================================================
	//========================================================================================================================================
	//Membrane potential element with external cell element
	//========================================================================================================================================
	//========================================================================================================================================
	template<class MEMBRANE_POTENTIAL_ELEMENT, class EXT_CELL_ELEMENT>
	class MembranePotentialElementWithExternalCellElement	:
	public virtual MEMBRANE_POTENTIAL_ELEMENT,
	public virtual ElementWithExternalElement
	{
	public:
		MembranePotentialElementWithExternalCellElement()	:
		MEMBRANE_POTENTIAL_ELEMENT(),
		ElementWithExternalElement()
		{
			this->set_ninteraction(1);
		}

		void get_source_BaseCellMembranePotential(const unsigned& ipt,
									const Vector<double>& x,
									double& source) const
		{
			//Get the interaction numbers
			const unsigned cell_interaction = 0;

			//Zero the source
			source = 0.0;
			//Set the Vector to hold local coordinates
			Vector<double> s(MEMBRANE_POTENTIAL_ELEMENT::dim(),0.0);
			//Assign values of s
			for(unsigned i=0;i<MEMBRANE_POTENTIAL_ELEMENT::dim();i++) s[i] = this->integral_pt()->knot(ipt,i);

			//If a source function has been set, use it
			if(MEMBRANE_POTENTIAL_ELEMENT::Source_fct_pt!=0){
				//Get source strength
				(*MEMBRANE_POTENTIAL_ELEMENT::Source_fct_pt)(x,source);				
			}



			//Add the membrane current from the external cell interface element
			source += dynamic_cast< DiffAugmentedCell<EXT_CELL_ELEMENT>*> //cast the external element
			(external_element_pt(cell_interaction, ipt))->			//get the external element pointer
				interpolated_membrane_current_CellInterface(
					external_element_local_coord(cell_interaction,ipt)); //call the membrane current function at the correct local coord
			// std::cout << source << std::endl;
		}

		void get_diff_monodomain(const unsigned& ipt,
									const Vector<double> &s,
									const Vector<double>& x,
									DenseMatrix<double>& D) const
		{
			//Get the interaction numbers
			const unsigned cell_interaction = 0;
			const unsigned solid_interaction = 1;

			dynamic_cast<DiffAugmentedCell<EXT_CELL_ELEMENT>*>
			(external_element_pt(cell_interaction, ipt))->
				get_interpolated_diffusion_matrix(external_element_local_coord(cell_interaction,ipt), D);
		}


		///\short Compute the element's residual vector and the Jacobian matrix.
		/// Jacobian is computed by finite-differencing
		void fill_in_contribution_to_jacobian(Vector<double> &residuals, 
												DenseMatrix<double> &jacobian)
		{
			MEMBRANE_POTENTIAL_ELEMENT::fill_in_contribution_to_jacobian(residuals,jacobian);
			this->fill_in_jacobian_from_external_interaction_by_fd(residuals,jacobian);
		}

		/// Add the element's contribution to its residuals vector,
		/// jacobian matrix and mass matrix
		void fill_in_contribution_to_jacobian_and_mass_matrix(Vector<double> &residuals,
																DenseMatrix<double> &jacobian,
																DenseMatrix<double> &mass_matrix)
		{
			//Call the standard (Broken) function
			//which will prevent these elements from being used
			//in eigenproblems until replaced.
			FiniteElement::fill_in_contribution_to_jacobian_and_mass_matrix(residuals,jacobian,mass_matrix);
		}
	};



	//========================================================================================================================================
	//========================================================================================================================================
	//Membrane potential element with external cell and solid elements
	//========================================================================================================================================
	//========================================================================================================================================
	template<class MEMBRANE_POTENTIAL_ELEMENT, class EXT_CELL_ELEMENT, class EXT_SOLID_ELEMENT>
	class MembranePotentialElementWithExternalCellAndSolidElements	:
	public virtual MEMBRANE_POTENTIAL_ELEMENT,
	public virtual ElementWithExternalElement
	{
	public:
		MembranePotentialElementWithExternalCellAndSolidElements()	:
		MEMBRANE_POTENTIAL_ELEMENT(),
		ElementWithExternalElement()
		{
			this->set_ninteraction(2);
		}

		void get_source_BaseCellMembranePotential(const unsigned& ipt,
									const Vector<double>& x,
									double& source) const
		{
			//Get the interaction numbers
			const unsigned cell_interaction = 0;
			const unsigned solid_interaction = 1;

			//Zero the source
			source = 0.0;
			//Set the Vector to hold local coordinates
			Vector<double> s(MEMBRANE_POTENTIAL_ELEMENT::dim(),0.0);
			//Assign values of s
			for(unsigned i=0;i<MEMBRANE_POTENTIAL_ELEMENT::dim();i++) s[i] = this->integral_pt()->knot(ipt,i);

			//If a source function has been set, use it
			if(MEMBRANE_POTENTIAL_ELEMENT::Source_fct_pt!=0){
				//Get source strength
				(*MEMBRANE_POTENTIAL_ELEMENT::Source_fct_pt)(x,source);				
			}



			//Add the membrane current from the external cell interface element
			source += dynamic_cast<DiffAugmentedCell<EXT_CELL_ELEMENT>*> //cast the external element
			(external_element_pt(cell_interaction, ipt))->			//get the external element pointer
				interpolated_membrane_current_CellInterface(
					external_element_local_coord(cell_interaction,ipt)); //call the membrane current function at the correct local coord
			// std::cout << source << std::endl;
		}

		void get_diff_monodomain(const unsigned& ipt,
									const Vector<double> &s,
									const Vector<double>& x,
									DenseMatrix<double>& D) const
		{
			//Get the interaction numbers
			const unsigned cell_interaction = 0;
			const unsigned solid_interaction = 1;

			D = dynamic_cast<DiffAugmentedCell<EXT_CELL_ELEMENT>*>
			(external_element_pt(cell_interaction, ipt))->
				get_interpolated_diffusion_matrix_augmented_cell(external_element_local_coord(cell_interaction,ipt));
		}

		//!!!!!HOW TO ADD EXTERNAL GEOMETRIC DATA FROM ANIS_SOLID ELEMENT


		///\short Compute the element's residual vector and the Jacobian matrix.
		/// Jacobian is computed by finite-differencing
		void fill_in_contribution_to_jacobian(Vector<double> &residuals, 
												DenseMatrix<double> &jacobian)
		{
			MEMBRANE_POTENTIAL_ELEMENT::fill_in_contribution_to_jacobian(residuals,jacobian);
			this->fill_in_jacobian_from_external_interaction_by_fd(residuals,jacobian);
		}

		/// Add the element's contribution to its residuals vector,
		/// jacobian matrix and mass matrix
		void fill_in_contribution_to_jacobian_and_mass_matrix(Vector<double> &residuals,
																DenseMatrix<double> &jacobian,
																DenseMatrix<double> &mass_matrix)
		{
			//Call the standard (Broken) function
			//which will prevent these elements from being used
			//in eigenproblems until replaced.
			FiniteElement::fill_in_contribution_to_jacobian_and_mass_matrix(residuals,jacobian,mass_matrix);
		}
	};



	//========================================================================================================================================
	//========================================================================================================================================
	//Anisotropic solid with external augmented cell elements
	//========================================================================================================================================
	//========================================================================================================================================

	template<class SOLID_ELEMENT, class EXT_CELL_ELEMENT>
	class SolidElementWithExternalCellElement	:
	public virtual SOLID_ELEMENT,
	public virtual ElementWithExternalElement
	{
	public:
		SolidElementWithExternalCellElement()	:
		SOLID_ELEMENT(),
		ElementWithExternalElement()
		{
			this->set_ninteraction(2);
		}

		void describe_local_dofs(std::ostream &out, const std::string &current_string) const
		{
			SOLID_ELEMENT::describe_local_dofs(out, current_string);
		}

		void anisotropic_matrix(const unsigned& ipt,
								const Vector<double> &s,
								const Vector<double>& xi,
								const DenseMatrix<double> &g,
								const DenseMatrix<double> &G,
								DenseMatrix<double>& A)
		{
			unsigned cell_interaction = 0;
			A = dynamic_cast<DiffAugmentedCell<EXT_CELL_ELEMENT>*>
				(external_element_pt(cell_interaction, ipt))->get_interpolated_fibre_orientation_augmented_cell(external_element_local_coord(cell_interaction, ipt));
		}

		void anisotropic_vector(const unsigned& ipt,
								const Vector<double> &s,
								const Vector<double>& xi,
								const DenseMatrix<double> &g, 
								const DenseMatrix<double> &G,
								Vector<double>& lambda) const
		{
			unsigned cell_interaction = 0;
			lambda.resize(1);
			lambda[0] = dynamic_cast<DiffAugmentedCell<EXT_CELL_ELEMENT>*>
			(external_element_pt(cell_interaction, ipt))->get_interpolated_cell_active_strain(external_element_local_coord(cell_interaction, ipt));
		}


		///\short Compute the element's residual vector and the Jacobian matrix.
		/// Jacobian is computed by finite-differencing
		void fill_in_contribution_to_jacobian(Vector<double> &residuals, 
												DenseMatrix<double> &jacobian)
		{
			SOLID_ELEMENT::fill_in_contribution_to_jacobian(residuals,jacobian);
			this->fill_in_jacobian_from_external_interaction_by_fd(residuals,jacobian);
		}

		/// Add the element's contribution to its residuals vector,
		/// jacobian matrix and mass matrix
		void fill_in_contribution_to_jacobian_and_mass_matrix(Vector<double> &residuals,
																DenseMatrix<double> &jacobian,
																DenseMatrix<double> &mass_matrix)
		{
			//Call the standard (Broken) function
			//which will prevent these elements from being used
			//in eigenproblems until replaced.
			FiniteElement::fill_in_contribution_to_jacobian_and_mass_matrix(residuals,jacobian,mass_matrix);
		}
	};

} //end of namespace

#endif