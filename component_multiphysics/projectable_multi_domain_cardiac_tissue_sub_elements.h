#ifndef OOMPH_PROJECTABLE_MULTI_DOMAIN_CARDIAC_TISSUE_SUB_ELEMENTS
#define OOMPH_PROJECTABLE_MULTI_DOMAIN_CARDIAC_TISSUE_SUB_ELEMENTS

// Config header generated by autoconfig
#ifdef HAVE_CONFIG_H
  #include <oomph-lib-config.h>
#endif

//Include the storage_augmented_cell_elements header
#include "../toms_utilities/diff_augmented_cell_wrapper.h"

//For the custom integration scheme
#include "../toms_utilities/toms_integral.h"

//Monodomain elements
#include "../cell_membrane_potential/cell_membrane_potential_elements.h"

//Solid elements for the external solid element for geometric data
#include "../anisotropic_solid/anisotropic_solid_elements.h"
#include "../anisotropic_solid/refineable_anisotropic_solid_elements.h"

//Cell interface elements (includes cell models)
#include "../cell_interface/cell_interface_elements.h"

#include "../generic/projection.h"


namespace oomph{


	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//Nodes inside an external element take the value inside the element at that point. Nodes not inside an external element interpolate
	//	the value of nodes which do lie in external elements. Solves for the interpolation weights of nodes inside external elements
	//Solves to minimise the difference between actual value inside external elements at local integral points and the value interpolated from
	//	nodes in this element. Contributions to this integral only exist where the meshes overlap so rapid changes at boundaries should be
	// avoided in this way.
	//By solving for interpolation weights within the element general data can be interpolated, e.g. stress tensor, fibre alignment vectors, e.t.c

	// //!!!!! If the element lies entirely outside of the external mesh, then take value from macro element nodes?
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


	//Upgrades a mono element to have membrane current
	//	be projected onto it.
	//Adds storage for membrane current interpolation weights,
	//	and functions to suitably interpolate it within the element.
	template<class BASE_MEMBRANE_POTENTIAL_ELEMENT, class EXT_CELL_ELEMENT>
	class MonoElementWithExternalInterpolatedMembraneCurrent :
		public virtual BASE_MEMBRANE_POTENTIAL_ELEMENT,
		public virtual ElementWithExternalElement
	{
	public:
		MonoElementWithExternalInterpolatedMembraneCurrent()	:
		BASE_MEMBRANE_POTENTIAL_ELEMENT()
		{

			//set the integration scheme to a suitable one which includes integration points at the nodes of the element
			unsigned nnode1d = this->nnode_1d();
			unsigned dim = this->dim();
			unsigned n_node = this->nnode();
			switch(dim){
				case 1:	{
							switch(nnode1d){
								case 2:	{
											this->set_integration_scheme(new GaussWithNodes<1,2>);
											ipt_not_at_nodes = 2;
											break;
								}
								case 3:	{
											this->set_integration_scheme(new GaussWithNodes<1,3>);
											ipt_not_at_nodes = 3;
											break;
								}
								case 4:	{
											this->set_integration_scheme(new GaussWithNodes<1,4>);
											ipt_not_at_nodes = 4;
											break;
								}
								default:throw OomphLibError(
								        "A suitable integration scheme with the underlying elements nnode_1d and dim has not been implemented yet.",
								        OOMPH_CURRENT_FUNCTION, OOMPH_EXCEPTION_LOCATION);
							}
				}
				case 2: {
							switch(nnode1d){
								case 2: {
											this->set_integration_scheme(new GaussWithNodes<2,2>);
											ipt_not_at_nodes = 4;
											break;
								}
								case 3: {
											this->set_integration_scheme(new GaussWithNodes<2,3>);
											ipt_not_at_nodes = 4;
											break;
								}
								case 4: {
											this->set_integration_scheme(new GaussWithNodes<2,4>);
											ipt_not_at_nodes = 4;
											break;
								}
								default:throw OomphLibError(
								        "A suitable integration scheme with the underlying elements nnode_1d and dim has not been implemented yet.",
								        OOMPH_CURRENT_FUNCTION, OOMPH_EXCEPTION_LOCATION);
							}
				}
				case 3: {
							switch(nnode1d){
								case 2: {
											this->set_integration_scheme(new GaussWithNodes<3,2>);
											ipt_not_at_nodes = 8;
											break;
								}
								case 3: {
											this->set_integration_scheme(new GaussWithNodes<3,3>);
											ipt_not_at_nodes = 27;
											break;
								}
								case 4: {
											this->set_integration_scheme(new GaussWithNodes<3,4>);
											ipt_not_at_nodes = 64;
											break;
								}
								default:throw OomphLibError(
								        "A suitable integration scheme with the underlying elements nnode_1d and dim has not been implemented yet.",
								        OOMPH_CURRENT_FUNCTION, OOMPH_EXCEPTION_LOCATION);
							}
				}
			}

			//Add internal_data_pt for potential difference interpolation weights
			Projected_interpolation_weights_membrane_current_index = this->add_internal_data(new Data(n_node*n_node), true);
			for(unsigned i=0; i < n_node; i++){
				//immediately pin the weight associated with the node itself
				this->internal_data_pt(Projected_interpolation_weights_membrane_current_index)->pin(i*n_node + i);
				for(unsigned j=0; j < n_node; j++){
					this->internal_data_pt(Projected_interpolation_weights_membrane_current_index)->set_value(i*n_node + j, 0.0);
				}
			}

			//Set the index for the external interaction with the cell mesh
			external_cell_mesh_interaction_index = this->ninteraction();
			//Increase the number of interactions by 1
			this->set_ninteraction(this->ninteraction()+1);
		}

		//internal local equation for the ith interpolation weight for nth node
		inline int interpolation_weight_local_eqn(const unsigned &n, const unsigned &i)const
			{return this->internal_local_eqn(Projected_interpolation_weights_membrane_current_index, n*this->nnode() + i);}


		// get the interpolation weight associated with the nth local node and ith external node
		inline double interpolation_weight_external_membrane_current(const unsigned &n, const unsigned &i) const
			{return this->internal_data_pt(Projected_interpolation_weights_membrane_current_index)->value(n*this->nnode() + i);}

		inline void unpin_all_interpolation_weights() const
		{
			unsigned n_node = this->nnode();
			for(unsigned l=0; l < n_node; l++){
				for(unsigned l1=0; l1 < n_node; l1++){
					this->internal_data_pt(Projected_interpolation_weights_membrane_current_index)->unpin(l*n_node + l1);
				}
			}
		}
	
		inline void pin_redundant_interpolation_weights() const
		{
			//if all the nodes are not inside external elements then we pin all node interpolating weights
			unsigned n_node = this->nnode();
			unsigned ipt_node;
			unsigned ipt_node_1;
			
			//initially unpin all the weights
			this->unpin_all_interpolation_weights();

			//loop over the nodes
			for(unsigned l=0; l<n_node; l++){
				//immediately pin the weight associated with the node
				this->internal_data_pt(Projected_interpolation_weights_membrane_current_index)->pin(l*n_node + l);
				//get the integral point associated with the node
				ipt_node = ipt_at_node(l);
				DiffAugmentedCell<EXT_CELL_ELEMENT>* ext_elmt_pt = dynamic_cast<DiffAugmentedCell<EXT_CELL_ELEMENT>*>(external_element_pt(external_cell_mesh_interaction_index, ipt_node));
				//loop over the other nodes in the element
				for(unsigned l1=0; l1 < n_node; l1++){
					//get the external element associated with that node
					ipt_node_1 = ipt_at_node(l1);
					DiffAugmentedCell<EXT_CELL_ELEMENT>* ext_elmt_pt_1 = dynamic_cast<DiffAugmentedCell<EXT_CELL_ELEMENT>*>(external_element_pt(external_cell_mesh_interaction_index, ipt_node_1));
					//If the first node is not associated wtih an external element pin the other nodes weight associated with it
					if(!ext_elmt_pt){this->internal_data_pt(Projected_interpolation_weights_membrane_current_index)->pin(l1*n_node + l);}

					//If the second node is not associated wtih an external element pin the first nodes weight associated with it
					if(!ext_elmt_pt){this->internal_data_pt(Projected_interpolation_weights_membrane_current_index)->pin(l*n_node + l1);}
				}
			}
		}

		//return the ipt associated with node n
		inline unsigned ipt_at_node(const unsigned &n) const
		{return ipt_not_at_nodes + n;}

		inline double stuitably_interpolated_membrane_current_at_node(const unsigned& n) const {
			//get the itegral point of the node
			unsigned ipt_node = ipt_at_node(n);
			//The external element the node is within
			DiffAugmentedCell<EXT_CELL_ELEMENT>* ext_elmt_pt = dynamic_cast<DiffAugmentedCell<EXT_CELL_ELEMENT>*>(external_element_pt(external_cell_mesh_interaction_index, ipt_node));
			//if there is an external element then return the value in that element at that point
			if(ext_elmt_pt!=0){
				return ext_elmt_pt->interpolated_membrane_current_CellInterface(external_element_local_coord(external_cell_mesh_interaction_index,ipt_node));
			}

			//otherwise, loop over the nodes in this element and get their contribution using the weights,
			//	we skip the node if it does not have an external element or if it is this node

			//the thing we are calculating
			double membrane_current=0.0;

			for(unsigned l=0; l < this->nnode(); l++){
				ipt_node = ipt_at_node(l);
				ext_elmt_pt = dynamic_cast<DiffAugmentedCell<EXT_CELL_ELEMENT>*>(external_element_pt(external_cell_mesh_interaction_index, ipt_node));
				//if the node we are looping over has no external element or it is this node, skip it.
				if(l==n  || !ext_elmt_pt)	continue;
				//otherwise we want to add the external value at this node to our interpolated value
				membrane_current += ext_elmt_pt->interpolated_membrane_current_CellInterface(external_element_local_coord(external_cell_mesh_interaction_index,ipt_node))*
										interpolation_weight_external_membrane_current(n, l);
			}

			return membrane_current;
		}

		//used in residual
		//		Does not take into account if the point is in an external element or not
		inline double interpolated_external_membrane_current(const Vector<double>& s) const {
			//Number of nodes
			const unsigned n_node = this->nnode();
			Shape psi(n_node);
			this->shape(s, psi);
			double I = 0.0;
			//Loop over the nodes in this element
			for(unsigned l=0; l<n_node; l++){
				I += stuitably_interpolated_membrane_current_at_node(l)*psi[l];
			}
			return I;
		}

		//used in get_source_monodomain
		//		If the point is in an external element then we take the value directly from that element
		//		otherwise we use the itnerpolated value from the nodes and projected nodes
		inline double external_membrane_current_at_integral_point(const unsigned& ipt) const {
			//The external element the ipt is within
			DiffAugmentedCell<EXT_CELL_ELEMENT>* ext_elmt_pt = dynamic_cast<DiffAugmentedCell<EXT_CELL_ELEMENT>*>(external_element_pt(external_cell_mesh_interaction_index, ipt));
			//if there is an external element then return the value in that element at that point
			if(ext_elmt_pt!=0){
				return ext_elmt_pt->interpolated_membrane_current_CellInterface(external_element_local_coord(external_cell_mesh_interaction_index,ipt));
			}
			//Number of nodes
			const unsigned n_node = this->nnode();
			Shape psi(n_node);
			this->shape_at_knot(ipt, psi);
			double I = 0.0;
			//Loop over the nodes in this element
			for(unsigned l=0; l<n_node; l++){
				I += stuitably_interpolated_membrane_current_at_node(l)*psi[l];
			}
			return I;
		}

		//Overload source monodomain to get membrane current part of source from
		// internal_data pt rather than an external element
		void get_source_monodomain(const unsigned& ipt,
									const Vector<double>& x,
									double& source) const
		{
			//Things common to all integral points
			unsigned n_dim=this->dim();

			//Zero the source
			source = 0.0;

			//Get contribution from source function
			if(BASE_MEMBRANE_POTENTIAL_ELEMENT::Source_fct_pt!=0){
				//Get source strength
				(*BASE_MEMBRANE_POTENTIAL_ELEMENT::Source_fct_pt)(x,source);
			}

			//add the source from the external cell element at the integral point
			source += this->external_membrane_current_at_integral_point(ipt);
		}

		//	projection from a member function rather than nodal data
		void residual_for_projection_of_membrane_current(Vector<double> &residuals, 
					                                      DenseMatrix<double> &jacobian, 
					                                      const unsigned& flag)
		{	
			//Things common to all integral points
			unsigned n_dim=this->dim();

			//Allocate storage for local coordinates
			Vector<double> s(n_dim);

			//total interpolation weight used at the point
			// double total_interp_weights;

			//Set the value of n_intpt
 			const unsigned n_intpt = this->integral_pt()->nweight();

 			unsigned ipt_node;
			
			//Number of nodes
			const unsigned n_node = this->nnode();
			//Number of positional dofs
			const unsigned n_position_type = this->nnodal_position_type();

			//Loop over the integration points
			for(unsigned ipt=0;ipt<n_intpt;ipt++)
			{
				// Get the local coordinates of Gauss point
				for(unsigned i=0;i<n_dim;i++) s[i] = this->integral_pt()->knot(ipt,i);

				// total_interp_weights = total_interpolation_weight_at_point(s);

				//Get the integral weight
				double w = this->integral_pt()->weight(ipt);

				if(w==0.0){continue;}

				//local shape function
				Shape psi(n_node);
				//A dummy shape derivative so we can get the jacobian
				DShape dpsidx(n_node, n_dim);
				double J = this->dshape_eulerian_at_knot(ipt,psi,dpsidx);

				double W = w*J;

				double interpolated_value_purely_projected = 0.0;
				double interpolated_value_direct_and_projected = 0.0;

				//Storage for the local equation and local unknown
				int eqn=0, unknown=0;

				//The external element and it's local coord and number of nodes
				Vector<double> other_s(n_dim);

				//get the cell_membrane_current from the projected representation
				interpolated_value_purely_projected = this->interpolated_external_membrane_current(s);
				//get the other cell membrane current directly if possible or using the projected representation if not
 				interpolated_value_direct_and_projected = this->external_membrane_current_at_integral_point(ipt);

 				//NOTE if the integration point lies inside and external element then both of these return the same value and the contriubution to the residual is zero

	 			//LOOP OVER LOCAL NODES
	 			for(unsigned l=0; l<n_node; l++){
		 			//get the itegral point of the node
					unsigned ipt_node = ipt_at_node(l);
					//The external element the node is in
					DiffAugmentedCell<EXT_CELL_ELEMENT>* ext_elmt_pt = dynamic_cast<DiffAugmentedCell<EXT_CELL_ELEMENT>*>(external_element_pt(external_cell_mesh_interaction_index, ipt_node));

		 			//IF THE NODE IS NOT INSIDE AN EXTERNAL ELEMENT THEN IT MUST USE THE PROJECTED REPRESENTATION
		 			if(ext_elmt_pt==0){
		 				//LOOP OVER INTERPOLATION WEIGHTS FOR THAT NODE
		 				for(unsigned l_var=0; l_var<n_node; l_var++){
		 					//get the equation number of that interpolation weight
		 					eqn = interpolation_weight_local_eqn(l, l_var);
		 					//if it isn't pinned
		 					if(eqn>=0){
		 						// std::cout << "No ext elmt " << eqn_number(eqn) << std::endl;

	 							//FILL IN RESIDUAL
			 					residuals[eqn] -= (interpolated_value_purely_projected - interpolated_value_direct_and_projected)*psi[l]*psi[l]*psi[l_var]*psi[l_var]*W;
			 					if(flag){
			 						throw OomphLibError(
					        			"Analytic calculate jacobian for MonoElementWithExternalInterpolatedMembraneCurrent has not been implemented yet.",
					        			OOMPH_CURRENT_FUNCTION, OOMPH_EXCEPTION_LOCATION);
				 				}
			 				}
			 			}
			 		}

			 		//IF THE NODE IS INSIDE AN EXTERNAL ELEMENT THEN IT DOES NOT USE THE PROJECTED REPRESENTATION
			 		//	AND WE DON'T CHANGE THE PROJECTION VARIABLES
		 			else{
						//LOOP OVER INTERPOLATION WEIGHTS FOR THAT NODE
		 				for(unsigned l_var=0; l_var<n_node; l_var++){
		 					eqn = interpolation_weight_local_eqn(l, l_var);
		 					if(eqn>=0){
		 						// std::cout << "node has ext elmt " << eqn_number(eqn) << std::endl;
	 							residuals[eqn] -= interpolation_weight_external_membrane_current(l,l_var)*psi[l]*W;
		 						if(flag){
		 							throw OomphLibError(
					        			"Analytic calculate jacobian for MonoElementWithExternalInterpolatedMembraneCurrent has not been implemented yet.",
					        			OOMPH_CURRENT_FUNCTION, OOMPH_EXCEPTION_LOCATION);
		 						}
		 					}
		 				}
		 			}

		 		}// end loop over nodes
			} // End loop over integration points
		}


		/// Add the element's contribution to its residual vector (wrapper)
		void fill_in_contribution_to_residuals(Vector<double> &residuals)
		{
		   	//Call the generic residuals function with flag set to 0 and using
		   	//a dummy matrix
			BASE_MEMBRANE_POTENTIAL_ELEMENT::fill_in_contribution_to_residuals(residuals);

			this->residual_for_projection_of_membrane_current(residuals,
															GeneralisedElement::Dummy_matrix,
															0);
		}

		void fill_in_contribution_to_jacobian(Vector<double> &residuals, 
												DenseMatrix<double> &jacobian)
		{	
			//Contribution from cell element
			// BASE_MEMBRANE_POTENTIAL_ELEMENT::fill_in_contribution_to_jacobian(residuals,
			// 													jacobian);
			// //Contribution from projecting to solid mesh
			// this->residual_for_projection_of_membrane_current(residuals,
			// 												jacobian,
			// 												1);

			FiniteElement::fill_in_contribution_to_jacobian(residuals,jacobian);
		}

	protected:
		unsigned Projected_interpolation_weights_membrane_current_index;
		
		unsigned external_cell_mesh_interaction_index;
	private:

		unsigned ipt_not_at_nodes;
	};







	//Upgrades a cell element to have membrane potential
	//	be projected onto it.
	//Adds storage for membrane potential interpolation weights,
	//	and functions to suitably interpolate it within the element.
	template<class BASE_CELL_ELEMENT, class EXT_MEMBRANE_POTENTIAL_ELEMENT>
	class CellElementWithExternalInterpolatedMembranePotential :
		public virtual BASE_CELL_ELEMENT,
		public virtual ElementWithExternalElement
	{
	public:
		CellElementWithExternalInterpolatedMembranePotential()	:
		BASE_CELL_ELEMENT()
		{	
			//set the integration scheme to a suitable one which includes integration points at the nodes of the element
			unsigned nnode1d = this->nnode_1d();
			unsigned dim = this->dim();
			unsigned n_node = this->nnode();
			//!!!!! Add handling of Q element and T element cases
			switch(dim){
				case 1:	{
							switch(nnode1d){
								case 2:	{
											this->set_integration_scheme(new GaussWithNodes<1,2>);
											ipt_not_at_nodes = 2;
											break;
								}
								case 3:	{
											this->set_integration_scheme(new GaussWithNodes<1,3>);
											ipt_not_at_nodes = 3;
											break;
								}
								case 4:	{
											this->set_integration_scheme(new GaussWithNodes<1,4>);
											ipt_not_at_nodes = 4;
											break;
								}
								default:	throw OomphLibError(
								        		"A suitable integration scheme with the underlying elements nnode_1d and dim has not been implemented yet.",
								        		OOMPH_CURRENT_FUNCTION, OOMPH_EXCEPTION_LOCATION);
							}
						}
				case 2: {
							switch(nnode1d){
								case 2: {
											this->set_integration_scheme(new GaussWithNodes<2,2>);
											ipt_not_at_nodes = 4;
											break;
								}
								case 3: {
											this->set_integration_scheme(new GaussWithNodes<2,3>);
											ipt_not_at_nodes = 9;
											break;
								}
								case 4: {
											this->set_integration_scheme(new GaussWithNodes<2,4>);
											ipt_not_at_nodes = 16;
											break;
								}
								default:throw OomphLibError(
								        "A suitable integration scheme with the underlying elements nnode_1d and dim has not been implemented yet.",
								        OOMPH_CURRENT_FUNCTION, OOMPH_EXCEPTION_LOCATION);
							}
						}
				case 3: {
							switch(nnode1d){
								case 2: {
											this->set_integration_scheme(new GaussWithNodes<3,2>);
											ipt_not_at_nodes = 8;
											break;
								}
								case 3: {
											this->set_integration_scheme(new GaussWithNodes<3,3>);
											ipt_not_at_nodes = 27;
											break;
								}
								case 4: {
											this->set_integration_scheme(new GaussWithNodes<3,4>);
											ipt_not_at_nodes = 64;
											break;
								}
								default:throw OomphLibError(
								        "A suitable integration scheme with the underlying elements nnode_1d and dim has not been implemented yet.",
								        OOMPH_CURRENT_FUNCTION, OOMPH_EXCEPTION_LOCATION);
							}
						}
			}
		

		

			//Add internal_data_pt for potential difference interpolation weights
			Projected_interpolation_weights_membrane_potential_index = this->add_internal_data(new Data((n_node*n_node)), true);
			for(unsigned i=0; i < n_node; i++){
				//immediately pin the weight associated with the node itself
				this->internal_data_pt(Projected_interpolation_weights_membrane_potential_index)->pin(i*n_node + i);
				for(unsigned j=0; j < n_node; j++){
					this->internal_data_pt(Projected_interpolation_weights_membrane_potential_index)->set_value(i*n_node + j, 0.0);
				}
			}


			//Set the index for the external interaction with the cell mesh
			external_mono_mesh_interaction_index = this->ninteraction();
			//Increase the number of interactions by 1
			this->set_ninteraction(this->ninteraction()+1);
		}

		//internal local equation for the ith interpolation weight for nth node
		inline int interpolation_weight_local_eqn(const unsigned &n, const unsigned &i)const
			{return this->internal_local_eqn(Projected_interpolation_weights_membrane_potential_index, n*this->nnode() + i);}


		// get the interpolation weight associated with the nth local node and ith external node
		inline double interpolation_weight_external_membrane_potential(const unsigned &n, const unsigned &i) const
		{
			return this->internal_data_pt(Projected_interpolation_weights_membrane_potential_index)->value(n*this->nnode() + i);
		}

		inline void unpin_all_interpolation_weights() const
		{
			unsigned n_node = this->nnode();
			for(unsigned l=0; l < n_node; l++){
				for(unsigned l1=0; l1 < n_node; l1++){
					this->internal_data_pt(Projected_interpolation_weights_membrane_potential_index)->unpin(l*n_node + l1);
				}
			}
		}
		
		inline void pin_redundant_interpolation_weights() const
		{
			//if all the nodes are not inside external elements then we pin all node interpolating weights
			unsigned n_node = this->nnode();
			unsigned ipt_node;
			unsigned ipt_node_1;
			
			//initially unpin all the weights
			this->unpin_all_interpolation_weights();

			//loop over the nodes
			for(unsigned l=0; l<n_node; l++){
				//immediately pin the weight associated with the node
				this->internal_data_pt(Projected_interpolation_weights_membrane_potential_index)->pin(l*n_node + l);
				//get the integral point associated with the node
				ipt_node = ipt_at_node(l);
				EXT_MEMBRANE_POTENTIAL_ELEMENT* ext_elmt_pt = dynamic_cast<EXT_MEMBRANE_POTENTIAL_ELEMENT*>(external_element_pt(external_mono_mesh_interaction_index, ipt_node));
				//loop over the other nodes in the element
				for(unsigned l1=0; l1 < n_node; l1++){
					//get the external element associated with that node
					ipt_node_1 = ipt_at_node(l1);
					EXT_MEMBRANE_POTENTIAL_ELEMENT* ext_elmt_pt_1 = dynamic_cast<EXT_MEMBRANE_POTENTIAL_ELEMENT*>(external_element_pt(external_mono_mesh_interaction_index, ipt_node_1));
					//If the first node is not associated wtih an external element pin the other nodes weight associated with it
					if(!ext_elmt_pt){this->internal_data_pt(Projected_interpolation_weights_membrane_potential_index)->pin(l1*n_node + l);}

					//If the second node is not associated wtih an external element pin the first nodes weight associated with it
					if(!ext_elmt_pt){this->internal_data_pt(Projected_interpolation_weights_membrane_potential_index)->pin(l*n_node + l1);}
				}
			}
		}

		//return the ipt associated with node n
		inline unsigned ipt_at_node(const unsigned &n) const {
			return ipt_not_at_nodes + n;
		}

		inline double stuitably_interpolated_membrane_potential_at_node(const unsigned& n) const {
			//get the itegral point of the node
			unsigned ipt_node = ipt_at_node(n);
			//The external element the node is within
			EXT_MEMBRANE_POTENTIAL_ELEMENT* ext_elmt_pt = dynamic_cast<EXT_MEMBRANE_POTENTIAL_ELEMENT*>(external_element_pt(external_mono_mesh_interaction_index, ipt_node));
			//if there is an external element then return the value in that element at that point
			if(ext_elmt_pt!=0){
				return ext_elmt_pt->vm_index_BaseCellMembranePotential(external_element_local_coord(external_mono_mesh_interaction_index,ipt_node));
			}

			//otherwise, loop over the nodes in this element and get their contribution using the weights,
			//	we skip the node if it does not have an external element or if it is this node

			//the thing we are calculating
			double membrane_current=0.0;

			for(unsigned l=0; l < this->nnode(); l++){
				ipt_node = ipt_at_node(l);
				ext_elmt_pt = dynamic_cast<EXT_MEMBRANE_POTENTIAL_ELEMENT*>(external_element_pt(external_mono_mesh_interaction_index, ipt_node));
				//if the node we are looping over has no external element or it is this node, skip it.
				if(l==n  || !ext_elmt_pt)	continue;
				//otherwise we want to add the external value at this node to our interpolated value
				membrane_current += ext_elmt_pt->vm_index_BaseCellMembranePotential(external_element_local_coord(external_mono_mesh_interaction_index,ipt_node))*
										interpolation_weight_external_membrane_potential(n, l);
			}

			return membrane_current;
		}

		//internal local equation for potential_difference
		inline double interpolated_external_membrane_potential(const Vector<double>& s) const
		{
			//Number of nodes
			const unsigned n_node = this->nnode();
			Shape psi(n_node);
			this->shape(s, psi);
			double I = 0.0;
			//Loop over the nodes in this element
			for(unsigned l=0; l<n_node; l++){
				I += stuitably_interpolated_membrane_potential_at_node(l)*psi[l];
			}
			return I;
		}


		//Overload source monodomain to get membrane potential part of source from
		// internal_data pt rather than an external element
		void get_membrane_potential_CellInterface(const unsigned& ipt,
													const Vector<double>& s,
													const Vector<double>& x,
													double& V) const
		{
			//Things common to all integral points
			unsigned n_dim=this->dim();

			//Zero the source
			V = 0.0;
			//Set the Vector to hold local coordinates
			// Vector<double> s(n_dim,0.0);
			//Assign values of s
			// for(unsigned i=0;i<n_dim;i++) s[i] = this->integral_pt()->knot(ipt,i);

			V = this->interpolated_external_membrane_potential(s);
		}

		//	projection from a member function rather than nodal data
		void residual_for_projection_of_membrane_potential(Vector<double> &residuals, 
					                                      DenseMatrix<double> &jacobian, 
					                                      const unsigned& flag)
		{	
			//Things common to all integral points
			unsigned n_dim=this->dim();

			//Allocate storage for local coordinates
			Vector<double> s(n_dim);

			//total interpolation weight used at the point
			// double total_interp_weights;

			//Set the value of n_intpt
 			const unsigned n_intpt = this->integral_pt()->nweight();

 			unsigned ipt_node;
			
			//Number of nodes
			const unsigned n_node = this->nnode();
			//Number of positional dofs
			const unsigned n_position_type = this->nnodal_position_type();

			//Loop over the integration points
			for(unsigned ipt=0;ipt<n_intpt;ipt++)
			{
				// Get the local coordinates of Gauss point
				for(unsigned i=0;i<n_dim;i++) s[i] = this->integral_pt()->knot(ipt,i);

				// total_interp_weights = total_interpolation_weight_at_point(s);

				//Get the integral weight
				double w = this->integral_pt()->weight(ipt);

				if(w==0.0){continue;}

				//local shape function
				Shape psi(n_node);
				//A dummy shape derivative so we can get the jacobian
				DShape dpsidx(n_node, n_dim);
				double J = this->dshape_eulerian_at_knot(ipt,psi,dpsidx);

				double W = w*J;

				double interpolated_value_purely_projected = 0.0;
				double interpolated_value_direct_and_projected = 0.0;

				//Storage for the local equation and local unknown
				int eqn=0, unknown=0;

				//The external element and it's local coord and number of nodes
				Vector<double> other_s(n_dim);



				//get the cell_membrane_current from the projected representation
				interpolated_value_purely_projected = this->interpolated_external_membrane_potential(s);
				//get the other cell membrane current directly if possible or using the projected representation if not
 				interpolated_value_direct_and_projected = this->stuitably_interpolated_membrane_potential_at_node(ipt);

 				//NOTE if the integration point lies inside and external element then both of these return the same value and the contriubution to the residual is zero



	 			//LOOP OVER LOCAL NODES
	 			for(unsigned l=0; l<n_node; l++){
		 			//get the itegral point of the node
					unsigned ipt_node = ipt_at_node(l);
					//The external element the node is in
					EXT_MEMBRANE_POTENTIAL_ELEMENT* ext_elmt_pt = dynamic_cast<EXT_MEMBRANE_POTENTIAL_ELEMENT*>(external_element_pt(external_mono_mesh_interaction_index, ipt_node));

		 			//IF THE NODE IS NOT INSIDE AN EXTERNAL ELEMENT THEN IT MUST USE THE PROJECTED REPRESENTATION
		 			if(ext_elmt_pt==0){
		 				//LOOP OVER INTERPOLATION WEIGHTS FOR THAT NODE
		 				for(unsigned l_var=0; l_var<n_node; l_var++){
		 					//get the equation number of that interpolation weight
		 					eqn = interpolation_weight_local_eqn(l, l_var);
		 					//if it isn't pinned
		 					if(eqn>=0){
	 							//FILL IN RESIDUAL
			 					residuals[eqn] -= (interpolated_value_purely_projected - interpolated_value_direct_and_projected)*psi[l]*W;
			 					if(flag){
			 						throw OomphLibError(
					        			"Analytic calculate jacobian for CellElementWithExternalInterpolatedMembranePotential has not been implemented yet.",
					        			OOMPH_CURRENT_FUNCTION, OOMPH_EXCEPTION_LOCATION);
				 				}
			 				}
			 			}
			 		}

			 		//IF THE NODE IS INSIDE AN EXTERNAL ELEMENT THEN IT DOES NOT USE THE PROJECTED REPRESENTATION
			 		//	AND WE DON'T CHANGE THE PROJECTION VARIABLES
		 			else{
						//LOOP OVER INTERPOLATION WEIGHTS FOR THAT NODE
		 				for(unsigned l_var=0; l_var<n_node; l_var++){
		 					eqn = interpolation_weight_local_eqn(l, l_var);
		 					if(eqn>=0){
	 							residuals[eqn] -= interpolation_weight_external_membrane_potential(l,l_var)*psi[l]*W;
		 						if(flag){
		 							throw OomphLibError(
					        			"Analytic calculate jacobian for CellElementWithExternalInterpolatedMembranePotential has not been implemented yet.",
					        			OOMPH_CURRENT_FUNCTION, OOMPH_EXCEPTION_LOCATION);
		 						}
		 					}
		 				}
		 			}

		 		}// end loop over nodes
			} // End loop over integration points
		}


		/// Add the element's contribution to its residual vector (wrapper)
		void fill_in_contribution_to_residuals(Vector<double> &residuals)
		{
		   	//Call the generic residuals function with flag set to 0 and using
		   	//a dummy matrix
			BASE_CELL_ELEMENT::fill_in_contribution_to_residuals(residuals);

			this->residual_for_projection_of_membrane_potential(residuals,
															GeneralisedElement::Dummy_matrix,
															0);
		}

		void fill_in_contribution_to_jacobian(Vector<double> &residuals, 
												DenseMatrix<double> &jacobian)
		{	
			// //Contribution from cell element
			// BASE_CELL_ELEMENT::fill_in_contribution_to_jacobian(residuals,
			// 													jacobian);
			// //Contribution from projecting to solid mesh
			// this->residual_for_projection_of_membrane_potential(residuals,
			// 												jacobian,
			// 												1);

			FiniteElement::fill_in_contribution_to_jacobian(residuals,jacobian);
		}

	protected:
		unsigned Projected_interpolation_weights_membrane_potential_index;
		
		unsigned external_mono_mesh_interaction_index;

	private:

		//The number of integration points which are not aligned with nodes.
		unsigned ipt_not_at_nodes;
	};

























































































	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//Solves for the value at each node and uses this value to interpolate within the element such that difference between projected value
	//	and value in external element is minimised.
	//	Deprecated because this can only work for scalars
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


	// //Upgrades a mono element to have membrane current
	// //	be projected onto it.
	// //Adds storage for membrane current,
	// //	and functions to suitably interpolate it within the element.
	// template<class BASE_MONO_ELEMENT, class EXT_CELL_ELEMENT>
	// class MonoElementWithProjectedInternalMembraneCurrentStorage :
	// 	public virtual BASE_MONO_ELEMENT,
	// 	public virtual ElementWithExternalElement
	// {
	// public:
	// 	MonoElementWithProjectedInternalMembraneCurrentStorage()	:
	// 	BASE_MONO_ELEMENT()
	// 	{
	// 		//Add internal_data_pt for potential difference, one data per node
	// 		Projected_membrane_current_internal_index = this->add_internal_data(new Data(this->nnode()), true);

	// 		//Set the index for the external interaction with the cell mesh
	// 		external_cell_mesh_interaction_index = this->ninteraction();
	// 		//Increase the number of interactions by 1
	// 		this->set_ninteraction(this->ninteraction()+1);
	// 	}

	// 	//internal local equation for potential_difference
	// 	inline unsigned membrane_current_local_eqn(const unsigned &n) const
	// 		{return this->internal_local_eqn(Projected_membrane_current_internal_index,n);}


	// 	// Perform suitable interpolation of internal_data_pt for V
	// 	inline double interpolate_internal_membrane_current(const Vector<double>& s) const
	// 	{
	// 		unsigned n_node = this->nnode();
	// 		Shape psi(n_node);
	// 		this->shape(s, psi);

	// 		double I = 0.0;
	// 		for(unsigned l=0; l < n_node; l++){
	// 			I += this->internal_data_pt(Projected_membrane_current_internal_index)->value(l)*psi[l];
	// 		}
	// 		return I;
	// 	}


	// 	//Overload source monodomain to get membrane current part of source from
	// 	// internal_data pt rather than an external element
	// 	void get_source_monodomain(const unsigned& ipt,
	// 								const Vector<double>& x,
	// 								double& source) const
	// 	{
	// 		//Things common to all integral points
	// 		unsigned n_dim=this->dim();

	// 		//Zero the source
	// 		source = 0.0;
	// 		//Set the Vector to hold local coordinates
	// 		Vector<double> s(n_dim,0.0);
	// 		//Assign values of s
	// 		for(unsigned i=0;i<n_dim;i++) s[i] = this->integral_pt()->knot(ipt,i);

	// 		if(BASE_MONO_ELEMENT::Source_fct_pt!=0){
	// 			//Get source strength
	// 			(*BASE_MONO_ELEMENT::Source_fct_pt)(x,source);
	// 		}

	// 		source += this->interpolate_internal_membrane_current(s);
	// 	}

	// 	//	projection from a member function rather than nodal data
	// 	void residual_for_projection_of_membrane_current(Vector<double> &residuals, 
	// 				                                      DenseMatrix<double> &jacobian, 
	// 				                                      const unsigned& flag)
	// 	{	
	// 		//Things common to all integral points
	// 		unsigned n_dim=this->dim();

	// 		//Allocate storage for local coordinates
	// 		Vector<double> s(n_dim);

	// 		//Set the value of n_intpt
 // 			const unsigned n_intpt = this->integral_pt()->nweight();
			
	// 		//Number of nodes
	// 		const unsigned n_node = this->nnode();
	// 		//Number of positional dofs
	// 		const unsigned n_position_type = this->nnodal_position_type();

	// 		//Loop over the integration points
	// 		for(unsigned ipt=0;ipt<n_intpt;ipt++)
	// 		{
	// 			//Things common to projecting cell membrane current and cell active strain

	// 			// Get the local coordinates of Gauss point
	// 			for(unsigned i=0;i<n_dim;i++) s[i] = this->integral_pt()->knot(ipt,i);

	// 			//Get the integral weight
	// 			double w = this->integral_pt()->weight(ipt);

	// 			//local shape function
	// 			Shape psi(n_node);
	// 			//A dummy shape derivative so we can get the jacobian
	// 			DShape dpsidx(n_node, n_dim);
	// 			double J = this->dshape_eulerian_at_knot(ipt,psi,dpsidx);

	// 			double W = w*J;

	// 			double interpolated_value_proj = 0.0;
	// 			double interpolated_value_bar = 0.0;

	// 			//Storage for the local equation and local unknown
	// 			int eqn=0, unknown=0;

	// 			//The external element and it's local coord and number of nodes
	// 			Vector<double> other_s(n_dim);

	// 			//Do project cell_membrane current
	// 			// Find same point in base mesh using external storage
	// 			FiniteElement* ext_elmt_pt = this->external_element_pt(external_cell_mesh_interaction_index,ipt);
	// 			EXT_CELL_ELEMENT* other_el_pt = dynamic_cast<EXT_CELL_ELEMENT*>(ext_elmt_pt);

	// 			if(other_el_pt!=0){
	// 				other_s=this->external_element_local_coord(external_cell_mesh_interaction_index,ipt);

	// 				//get the local cell membrane current at s
	// 				interpolated_value_proj = this->interpolate_internal_membrane_current(s);
	// 				//get the other cell membrane current at the other_s
	//  				interpolated_value_bar = other_el_pt->interpolated_membrane_current_CellInterface(other_s);
	//  			}

	// 			//loop over the nodes in this element
	// 			for(unsigned l=0; l<n_node; l++){
	// 				//get the equation number of the projected membrane current 
	// 				eqn = membrane_current_local_eqn(l);
	// 				//if it isn't a boundary
	// 				if(eqn >= 0){
	// 					residuals[eqn] -= (interpolated_value_proj - interpolated_value_bar)*psi[l]*W;
	// 					if(flag){
	// 						for(unsigned l2=0; l2<n_node; l2++){
	// 							unknown = membrane_current_local_eqn(l2);
	// 							if(unknown >= 0){
	// 								jacobian(eqn, unknown) -= psi[l2]*psi[l]*W;
	// 							}
	// 						}
	// 					}
	// 				}
	// 			}
	// 		} // End loop over integration points
	// 	}


	// 	/// Add the element's contribution to its residual vector (wrapper)
	// 	void fill_in_contribution_to_residuals(Vector<double> &residuals)
	// 	{
	// 	   	//Call the generic residuals function with flag set to 0 and using
	// 	   	//a dummy matrix
	// 		BASE_MONO_ELEMENT::fill_in_contribution_to_residuals(residuals);

	// 		this->residual_for_projection_of_membrane_current(residuals,
	// 														GeneralisedElement::Dummy_matrix,
	// 														0);
	// 	}

	// 	void fill_in_contribution_to_jacobian(Vector<double> &residuals, 
	// 											DenseMatrix<double> &jacobian)
	// 	{	
	// 		//Contribution from cell element
	// 		BASE_MONO_ELEMENT::fill_in_contribution_to_jacobian(residuals,
	// 															jacobian);
	// 		//Contribution from projecting to solid mesh
	// 		this->residual_for_projection_of_membrane_current(residuals,
	// 														jacobian,
	// 														1);
	// 	}

	// protected:
	// 	unsigned Projected_membrane_current_internal_index;

	// 	unsigned external_cell_mesh_interaction_index;
	// };










	// //Upgrades a cell interface element to have membrane potential
	// //	and mechanical stress to be projected onto it.
	// //Adds storage for membrane potential and mechanical stress,
	// //	and functions to suitably interpolate them within the element.
	// template<class BASE_CELL_ELEMENT, class EXT_MONO_ELEMENT>
	// class CellElementWithInternalProjectedMembranePotentialStorage :
	// 	public virtual BASE_CELL_ELEMENT,
	// 	public virtual ElementWithExternalElement
	// {
	// public:
	// 	CellElementWithInternalProjectedMembranePotentialStorage()	:
	// 	BASE_CELL_ELEMENT()
	// 	{
	// 		//Add internal_data_pt for potential difference, one data per node
	// 		Projected_potential_difference_internal_index 	= this->add_internal_data(new Data(this->nnode()), true);

	// 		//Set the index for the external interaction with the cell mesh
	// 		external_mono_mesh_interaction_index = this->ninteraction();
	// 		//Increase the number of interactions by 1
	// 		this->set_ninteraction(this->ninteraction()+1);
	// 	}


	// 	//internal local equation for potential_difference
	// 	inline unsigned potential_difference_local_eqn(const unsigned &n) const
	// 		{return this->internal_local_eqn(Projected_potential_difference_internal_index,n);}

	// 	// Perform suitable interpolation of internal_data_pt for V
	// 	inline double interpolate_internal_potential_difference(const Vector<double>& s) const
	// 	{
	// 		unsigned n_node = this->nnode();
	// 		Shape psi(n_node);
	// 		this->shape(s, psi);

	// 		double V=0.0;
	// 		for(unsigned l=0; l < n_node; l++){
	// 			V += this->internal_data_pt(Projected_potential_difference_internal_index)->value(l)*psi[l];
	// 		}
	// 		return V;
	// 	}

	// 	inline void set_internal_potential_difference(const double &value)
	// 	{
	// 		unsigned n_node = this->nnode();
	// 		for(unsigned l=0; l < n_node; l++){
	// 			this->internal_data_pt(Projected_potential_difference_internal_index)->set_value(l,value);
	// 		}
	// 	}

	// 	//Overload membrane potential to come from internal_data pt rather than external element
	// 	void get_membrane_potential_CellInterface(const unsigned& ipt,
	// 												const Vector<double>& s,
	// 												const Vector<double>& x,
	// 												double& V) const
	// 	{
	// 		V = interpolate_internal_potential_difference(s);
	// 	}

	// 	//	projection from a member function rather than nodal data
	// 	void residual_for_projection_of_membrane_potential(Vector<double> &residuals, 
	// 					                                      DenseMatrix<double> &jacobian, 
	// 					                                      const unsigned& flag)
	// 	{	
	// 		//Things common to all integral points
	// 		unsigned n_dim=this->dim();

	// 		//Allocate storage for local coordinates
	// 		Vector<double> s(n_dim);

	// 		//Set the value of n_intpt
 // 			const unsigned n_intpt = this->integral_pt()->nweight();
			
	// 		//Number of nodes
	// 		const unsigned n_node = this->nnode();
	// 		//Number of positional dofs
	// 		const unsigned n_position_type = this->nnodal_position_type();

	// 		//Loop over the integration points
	// 		for(unsigned ipt=0;ipt<n_intpt;ipt++)
	// 		{
	// 			//Things common to projecting cell membrane current and cell active strain

	// 			// Get the local coordinates of Gauss point
	// 			for(unsigned i=0;i<n_dim;i++) s[i] = this->integral_pt()->knot(ipt,i);

	// 			//Get the integral weight
	// 			double w = this->integral_pt()->weight(ipt);

	// 			//local shape function
	// 			Shape psi(n_node);
	// 			//A dummy shape derivative so we can get the jacobian
	// 			DShape dpsidx(n_node, n_dim);
	// 			double J = this->dshape_eulerian_at_knot(ipt,psi,dpsidx);

	// 			double W = w*J;

	// 			double interpolated_value_proj = 0.0;
	// 			double interpolated_value_bar = 0.0;

	// 			//Storage for the local equation and local unknown
	// 			int eqn=0, unknown=0;

	// 			//The external element and it's local coord and number of nodes
	// 			Vector<double> other_s(n_dim);

	// 			//Do project cell_membrane current
	// 			// Find same point in base mesh using external storage
	// 			FiniteElement* ext_elmt_pt = this->external_element_pt(external_mono_mesh_interaction_index,ipt);
	// 			EXT_MONO_ELEMENT* other_el_pt = dynamic_cast<EXT_MONO_ELEMENT*>(ext_elmt_pt);

	// 			if(other_el_pt!=0){
	// 				other_s=this->external_element_local_coord(external_mono_mesh_interaction_index,ipt);

	// 				//get the local cell membrane current at s
	// 				interpolated_value_proj = this->interpolate_internal_potential_difference(s);
	// 				//get the other cell membrane current at the other_s
	//  				interpolated_value_bar = other_el_pt->interpolated_u_monodomain(other_s);
	// 			}
	// 			//loop over the nodes in this element
	// 			for(unsigned l=0; l<n_node; l++){
	// 				//get the equation number of the projected membrane current 
	// 				eqn = potential_difference_local_eqn(l);
	// 				//if it isn't a boundary
	// 				if(eqn >= 0){
	// 					residuals[eqn] -= (interpolated_value_proj - interpolated_value_bar)*psi[l]*W;
	// 					if(flag){
	// 						for(unsigned l2=0; l2<n_node; l2++){
	// 							unknown = potential_difference_local_eqn(l2);
	// 							if(unknown >= 0){
	// 								jacobian(eqn, unknown) -= psi[l2]*psi[l]*W;
	// 							}
	// 						}
	// 					}
	// 				}

	// 			}
	// 		} // End loop over integration points
	// 	}


	// 	/// Add the element's contribution to its residual vector (wrapper)
	// 	void fill_in_contribution_to_residuals(Vector<double> &residuals)
	// 	{
	// 		BASE_CELL_ELEMENT::fill_in_contribution_to_residuals(residuals);

	// 		this->residual_for_projection_of_membrane_potential(residuals,
	// 															GeneralisedElement::Dummy_matrix,
	// 															0);
	// 	}

	// 	void fill_in_contribution_to_jacobian(Vector<double> &residuals, 
	// 											DenseMatrix<double> &jacobian)
	// 	{	
	// 		//Contribution from cell element
	// 		// BASE_CELL_ELEMENT::fill_in_contribution_to_jacobian(residuals,
	// 		// 													jacobian);
	// 		// //Contribution from projecting to solid mesh
	// 		// this->residual_for_projection_of_membrane_potential(residuals,
	// 		// 													jacobian,
	// 		// 													1);

	// 		FiniteElement::fill_in_contribution_to_jacobian(residuals,jacobian);


	// 	}


	// protected:
	// 	//The index of the internal data where membrane potential is stored
	// 	unsigned Projected_potential_difference_internal_index;

	// 	unsigned external_mono_mesh_interaction_index;
	// };



























	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//Interpolated to nodes from external element node is in, 'moves' node around inside the external element to achieve the best
	//	interpolation such that integral of difference between interpolated value and actual value is zero
	//Deprecated because overly complicated
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



	// //Upgrades a mono element to have membrane current
	// //	be projected onto it.
	// //Adds storage for membrane current interpolation weights,
	// //	and functions to suitably interpolate it within the element.
	// template<class BASE_MONO_ELEMENT, class EXT_CELL_ELEMENT>
	// class MonoElementWithExternalInterpolatedMembraneCurrent :
	// 	public virtual BASE_MONO_ELEMENT,
	// 	public virtual ElementWithExternalElement
	// {
	// public:
	// 	MonoElementWithExternalInterpolatedMembraneCurrent()	:
	// 	BASE_MONO_ELEMENT()
	// 	{

	// 		//set the integration scheme to a suitable one which includes integration points at the nodes of the element
	// 		unsigned nnode1d = this->nnode_1d();
	// 		unsigned dim = this->dim();
	// 		switch(dim){
	// 			case 1:	{
	// 						switch(nnode1d){
	// 							case 2:	{
	// 										this->set_integration_scheme(new GaussWithNodes<1,2>);
	// 										ipt_not_at_nodes = 2;
	// 										break;
	// 									}
	// 							case 3:	{
	// 										this->set_integration_scheme(new GaussWithNodes<1,3>);
	// 										ipt_not_at_nodes = 3;
	// 										break;
	// 									}
	// 							case 4:	{
	// 										this->set_integration_scheme(new GaussWithNodes<1,4>);
	// 										ipt_not_at_nodes = 4;
	// 										break;
	// 									}
	// 							default:throw OomphLibError(
	// 							        "A suitable integration scheme with the underlying elements nnode_1d and dim has not been implemented yet.",
	// 							        OOMPH_CURRENT_FUNCTION, OOMPH_EXCEPTION_LOCATION);
	// 						}
	// 					}
	// 		}

	// 		// build the slave element
	// 		slave_ext_cell_elmt_pt = new EXT_CELL_ELEMENT;

	// 		//Add internal_data_pt for potential difference interpolation weights
	// 		Projected_interpolation_weights_membrane_current_index = this->add_internal_data(new Data(this->nnode()*slave_ext_cell_elmt_pt->nnode()), true);
	// 		for(unsigned i=0; i < this->nnode(); i++){
	// 			for(unsigned j=0; j < slave_ext_cell_elmt_pt->nnode(); j++){
	// 				this->internal_data_pt(Projected_interpolation_weights_membrane_current_index)->set_value(i*slave_ext_cell_elmt_pt->nnode() + j, 1.0);
	// 			}
	// 		}

	// 		//Set the index for the external interaction with the cell mesh
	// 		external_cell_mesh_interaction_index = this->ninteraction();
	// 		//Increase the number of interactions by 1
	// 		this->set_ninteraction(this->ninteraction()+1);
	// 	}

	// 	//internal local equation for the ith interpolation weight for nth node
	// 	inline unsigned interpolation_weight_local_eqn(const unsigned &n, const unsigned &i)const
	// 		{return this->internal_local_eqn(Projected_interpolation_weights_membrane_current_index, n*slave_ext_cell_elmt_pt->nnode() + i);}


	// 	// get the interpolation weight associated with the nth local node and ith external node
	// 	inline double interpolation_weight_external_membrane_current(const unsigned &n, const unsigned &i) const
	// 	{
	// 		return this->internal_data_pt(Projected_interpolation_weights_membrane_current_index)->value(n*slave_ext_cell_elmt_pt->nnode() + i);
	// 	}

	// 	// // get the interpolation weight associated with the nth local node and ith external node
	// 	// inline unsigned interpolation_weight_external_membrane_current(const unsigned &n, const unsigned &i, const unsigned &t) const
	// 	// {
	// 	// 	return this->internal_data_pt(Projected_interpolation_weights_membrane_current_index)->value(t, n*slave_ext_cell_elmt_pt->nnode() + i);
	// 	// }
		

	// 	//return the ipt associated with node n
	// 	inline unsigned ipt_at_node(unsigned &n) const{
	// 		return ipt_not_at_nodes + n;
	// 	}

	// 	inline double total_interpolation_weight_at_point(const Vector<double>& s) const
	// 	{
	// 		//Number of nodes
	// 		const unsigned n_node = this->nnode();
	// 		Shape psi(n_node);
	// 		this->shape(s, psi);
	// 		unsigned ipt_node;
	// 		double total_interp_weights = 0.0;

	// 		for(unsigned l=0; l<this->nnode(); l++){
	// 			// std::cout << l << std::endl;
	// 			//get the ipt associated with node l
	// 			ipt_node = this->ipt_at_node(l);
	// 			//If the node lies in an external element
	// 			EXT_CELL_ELEMENT* ext_elmt_pt = dynamic_cast<EXT_CELL_ELEMENT*>(external_element_pt(external_cell_mesh_interaction_index, ipt_node));
	// 			//if the node lies in an external element and  then interpolate with it, using the interpolation weights stored in internal data
	// 			if(ext_elmt_pt!=0){
	// 				//add to total weights
	// 				total_interp_weights += psi[l];
	// 			}
	// 		}
	// 		return total_interp_weights;
	// 	}


	// 	//internal local equation for potential_difference
	// 	inline double interpolated_external_membrane_current(const Vector<double>& s) const
	// 	{
	// 		//Number of nodes
	// 		const unsigned n_node = this->nnode();
	// 		Shape psi(n_node);
	// 		this->shape(s, psi);
	// 		double I = 0.0;
	// 		double I_node;
	// 		unsigned ipt_node;
	// 		double total_interp_weights=0.0;

	// 		//Loop over the nodes in this element
	// 		for(unsigned l=0; l<this->nnode(); l++){
	// 			// std::cout << l << std::endl;
	// 			//get the ipt associated with node l
	// 			ipt_node = ipt_at_node(l);
	// 			//If the node lies in an external element
	// 			EXT_CELL_ELEMENT* ext_elmt_pt = dynamic_cast<EXT_CELL_ELEMENT*>(external_element_pt(external_cell_mesh_interaction_index, ipt_node));
	// 			//if the node lies in an external element and  then interpolate with it, using the interpolation weights stored in internal data
	// 			if(ext_elmt_pt!=0){
	// 				//then interpolate the value of membrane current in external element
	// 				//	using the weights we have calculated
	// 				I_node = 0.0;
	// 				//loop over the nodes in the external element
	// 				for(unsigned l1=0; l1<ext_elmt_pt->nnode(); l1 ++){
	// 					I_node += ext_elmt_pt->membrane_current_at_node_CellInterface(l1)*interpolation_weight_external_membrane_current(l,l1);
	// 								;
	// 				}
	// 				//add contribution from this node to the interpolated membrane current
	// 				I += I_node*psi[l];
	// 				//add to total weights used
	// 				total_interp_weights += psi[l];
	// 			}

	// 		}
	// 		//divide interpolated membrane current by total weights used
	// 		if(total_interp_weights > 1e-13){
	// 			I/=total_interp_weights;
	// 		}
	// 		return I;
	// 	}

	// 	//Overload source monodomain to get membrane current part of source from
	// 	// internal_data pt rather than an external element
	// 	void get_source_monodomain(const unsigned& ipt,
	// 								const Vector<double>& x,
	// 								double& source) const
	// 	{
	// 		//Things common to all integral points
	// 		unsigned n_dim=this->dim();

	// 		//Zero the source
	// 		source = 0.0;
	// 		//Set the Vector to hold local coordinates
	// 		Vector<double> s(n_dim,0.0);
	// 		//Assign values of s
	// 		for(unsigned i=0;i<n_dim;i++) s[i] = this->integral_pt()->knot(ipt,i);

	// 		if(BASE_MONO_ELEMENT::Source_fct_pt!=0){
	// 			//Get source strength
	// 			(*BASE_MONO_ELEMENT::Source_fct_pt)(x,source);
	// 		}

	// 		source += this->interpolated_external_membrane_current(s);
	// 	}

	// 	//	projection from a member function rather than nodal data
	// 	void residual_for_projection_of_membrane_current(Vector<double> &residuals, 
	// 				                                      DenseMatrix<double> &jacobian, 
	// 				                                      const unsigned& flag)
	// 	{	
	// 		//Things common to all integral points
	// 		unsigned n_dim=this->dim();

	// 		//Allocate storage for local coordinates
	// 		Vector<double> s(n_dim);

	// 		//total interpolation weight used at the point
	// 		double total_interp_weights;

	// 		//Set the value of n_intpt
 // 			const unsigned n_intpt = this->integral_pt()->nweight();

 // 			unsigned ipt_node;
			
	// 		//Number of nodes
	// 		const unsigned n_node = this->nnode();
	// 		//Number of positional dofs
	// 		const unsigned n_position_type = this->nnodal_position_type();

	// 		//Loop over the integration points
	// 		for(unsigned ipt=0;ipt<n_intpt;ipt++)
	// 		{
	// 			// Get the local coordinates of Gauss point
	// 			for(unsigned i=0;i<n_dim;i++) s[i] = this->integral_pt()->knot(ipt,i);

	// 			total_interp_weights = total_interpolation_weight_at_point(s);

	// 			//Get the integral weight
	// 			double w = this->integral_pt()->weight(ipt);

	// 			if(w==0.0){continue;}

	// 			//local shape function
	// 			Shape psi(n_node);
	// 			//A dummy shape derivative so we can get the jacobian
	// 			DShape dpsidx(n_node, n_dim);
	// 			double J = this->dshape_eulerian_at_knot(ipt,psi,dpsidx);

	// 			double W = w*J;

	// 			double interpolated_value_proj = 0.0;
	// 			double interpolated_value_bar = 0.0;

	// 			//Storage for the local equation and local unknown
	// 			int eqn=0, unknown=0;

	// 			//The external element and it's local coord and number of nodes
	// 			Vector<double> other_s(n_dim);

	// 			//Do project cell_membrane current
	// 			// Find same point in base mesh using external storage
	// 			FiniteElement* ext_elmt_pt = this->external_element_pt(external_cell_mesh_interaction_index,ipt);
	// 			EXT_CELL_ELEMENT* other_el_pt = dynamic_cast<EXT_CELL_ELEMENT*>(ext_elmt_pt);

	// 			if(other_el_pt!=0){
	// 				other_s=this->external_element_local_coord(external_cell_mesh_interaction_index,ipt);

	// 				//get the local cell membrane current at s
	// 				interpolated_value_proj = this->interpolated_external_membrane_current(s);
	// 				//get the other cell membrane current at the other_s
	//  				interpolated_value_bar = other_el_pt->interpolated_membrane_current_CellInterface(other_s);
	//  			}

	//  			//LOOP OVER LOCAL NODES
	//  			for(unsigned l=0; l<this->nnode(); l++){

	//  				// Get the data's timestepper
	// 			    // TimeStepper* time_stepper_pt= this->node_pt(l)->time_stepper_pt();
	// 			    // const unsigned n_time = time_stepper_pt->ntstorage();

	//  				// std::cout << "node: " << l  << std::endl;

	// 	 			//GET THE INTERPOLATION POINT THE NODE LIVES AT
	//  				ipt_node=this->ipt_at_node(l);

	// 	 			//GET THE EXTERNAL ELEMENT THE NODE IS AT
	//  				FiniteElement* ext_elmt_node_pt = this->external_element_pt(external_cell_mesh_interaction_index,ipt_node);
	//  				EXT_CELL_ELEMENT* other_el_node_pt = dynamic_cast<EXT_CELL_ELEMENT*>(ext_elmt_node_pt);

	// 	 			//IF THE NODE IS INSIDE AN EXTERNAL ELEMENT
	// 	 			if(other_el_node_pt!=0){
	// 	 				//LOOP OVER INTERPOLATION WEIGHTS FOR THAT NODE
	// 	 				for(unsigned l_ext_1=0; l_ext_1<other_el_node_pt->nnode(); l_ext_1++){
	// 	 					// std::cout << "first external node: " << l_ext_1 << std::endl;
	// 	 					eqn = interpolation_weight_local_eqn(l, l_ext_1);
	// 	 					if(eqn>=0){
	//  							//FILL IN RESIDUAL
	// 		 					residuals[eqn] -= (interpolated_value_proj - interpolated_value_bar)*psi[l]*W;
	// 		 					std::cout << eqn_number(eqn) << "\t" << residuals[eqn] << std::endl;
	// 		 					if(flag){
	// 		 						//loop over the other nodes in the element
	// 		 						for(unsigned l1=0; l1<this->nnode();l1++){
	// 		 							// std::cout << "second internal node: " << l1 << std::endl;
	// 		 							//GET THE EXTERNAL ELEMENT THE SECOND NODE IS AT
	// 					 				FiniteElement* ext_elmt_node_pt_2 = this->external_element_pt(external_cell_mesh_interaction_index,ipt_node);
	// 					 				EXT_CELL_ELEMENT* other_el_node_pt_2 = dynamic_cast<EXT_CELL_ELEMENT*>(ext_elmt_node_pt_2);


	// 			 						//LOOP OVER INTERPOLATION WEIGHTS
	// 					 				for(unsigned l_ext_2=0; l_ext_2<other_el_node_pt_2->nnode(); l_ext_2++){
	// 					 					// std::cout << "external node: " << l_ext_2 << std::endl;
	// 					 					unknown = interpolation_weight_local_eqn(l1, l_ext_2);
	// 					 					if(unknown>=0){
	// 				 							//FILL IN JACOBIAN !!!!! THIS MIGHT BE HORRIBLY WRONG
	// 				 							jacobian(eqn, unknown) -= other_el_node_pt_2->membrane_current_at_node_CellInterface(l_ext_2)*psi[l1]*psi[l]*W/total_interp_weights;
	// 				 						}
	// 				 					}
	// 				 				}
	// 			 				}
	// 		 				}
	// 		 			}
	// 		 		}

	// 		 		//if there is no external element then we set residual = 0 and jacobian = 1 on diagonal
	// 	 			else{
	// 					//LOOP OVER INTERPOLATION WEIGHTS FOR THAT NODE
	// 	 				for(unsigned l_ext_1=0; l_ext_1<slave_ext_cell_elmt_pt->nnode(); l_ext_1++){
	// 	 					eqn = interpolation_weight_local_eqn(l, l_ext_1);
	// 	 					this->internal_data_pt(Projected_interpolation_weights_membrane_current_index)->pin(l*slave_ext_cell_elmt_pt->nnode() + l_ext_1);
	// 	 					// std::cout << eqn_number(eqn) << std::endl;
	// 	 					if(eqn>=0){
	// 	 						// for(unsigned t=0;t<n_time;t++){
	// 					          //Since the data is purely passive we DON'T want it to change with the movement of the mesh
	// 					          // residuals[eqn] -= time_stepper_pt->weight(1,t)*interpolation_weight_external_membrane_current(l,l_ext_1,t)*psi[l]*W;
	// 	 							residuals[eqn] -= interpolation_weight_external_membrane_current(l,l_ext_1)*psi[l]*W;
	// 	 							std::cout << "NO extern elmt: " << eqn_number(eqn) << "\t" << residuals[eqn] << std::endl;
 //        						// }
	// 	 						if(flag){
	// 	 							//FILL IN JACOBIAN
	// 	 							jacobian(eqn, eqn) -= 1.0*W*psi[l]*psi[l];
	// 	 						}
	// 	 					}
	// 	 				}
	// 	 			}

	// 	 		}// end loop over nodes
	// 		} // End loop over integration points
	// 	}


	// 	/// Add the element's contribution to its residual vector (wrapper)
	// 	void fill_in_contribution_to_residuals(Vector<double> &residuals)
	// 	{
	// 	   	//Call the generic residuals function with flag set to 0 and using
	// 	   	//a dummy matrix
	// 		BASE_MONO_ELEMENT::fill_in_contribution_to_residuals(residuals);

	// 		this->residual_for_projection_of_membrane_current(residuals,
	// 														GeneralisedElement::Dummy_matrix,
	// 														0);
	// 	}

	// 	void fill_in_contribution_to_jacobian(Vector<double> &residuals, 
	// 											DenseMatrix<double> &jacobian)
	// 	{	
	// 		//Contribution from cell element
	// 		BASE_MONO_ELEMENT::fill_in_contribution_to_jacobian(residuals,
	// 															jacobian);
	// 		//Contribution from projecting to solid mesh
	// 		this->residual_for_projection_of_membrane_current(residuals,
	// 														jacobian,
	// 														1);
	// 	}

	// protected:
	// 	unsigned Projected_interpolation_weights_membrane_current_index;
		
	// 	unsigned external_cell_mesh_interaction_index;
	// private:
	// 	// slave element so we can get the number of nodes in the external element reliably
	// 	EXT_CELL_ELEMENT* slave_ext_cell_elmt_pt;

	// 	unsigned ipt_not_at_nodes;
	// };























	// //Upgrades a cell element to have membrane potential
	// //	be projected onto it.
	// //Adds storage for membrane potential interpolation weights,
	// //	and functions to suitably interpolate it within the element.
	// template<class BASE_CELL_ELEMENT, class EXT_MONO_ELEMENT>
	// class CellElementWithExternalInterpolatedMembranePotential :
	// 	public virtual BASE_CELL_ELEMENT,
	// 	public virtual ElementWithExternalElement
	// {
	// public:
	// 	CellElementWithExternalInterpolatedMembranePotential()	:
	// 	BASE_CELL_ELEMENT()
	// 	{	
	// 		//set the integration scheme to a suitable one which includes integration points at the nodes of the element
	// 		unsigned nnode1d = this->nnode_1d();
	// 		unsigned dim = this->dim();
	// 		//!!!!! Add handling of Q element and T element cases
	// 		switch(dim){
	// 			case 1:	{
	// 				switch(nnode1d){
	// 					case 2:	{
	// 								this->set_integration_scheme(new GaussWithNodes<1,2>);
	// 								ipt_not_at_nodes = 2;
	// 								break;
	// 							}
	// 					case 3:	{
	// 								this->set_integration_scheme(new GaussWithNodes<1,3>);
	// 								ipt_not_at_nodes = 3;
	// 								break;
	// 							}
	// 					case 4:	{
	// 								this->set_integration_scheme(new GaussWithNodes<1,4>);
	// 								ipt_not_at_nodes = 4;
	// 								break;
	// 							}
	// 					default:	throw OomphLibError(
	// 					        		"A suitable integration scheme with the underlying elements nnode_1d and dim has not been implemented yet.",
	// 					        		OOMPH_CURRENT_FUNCTION, OOMPH_EXCEPTION_LOCATION);
	// 				}
	// 			}
	// 		}
		
	// 		// build the slave element
	// 		slave_ext_mono_elmt_pt = new EXT_MONO_ELEMENT;
	// 		//Add internal_data_pt for potential difference interpolation weights
	// 		Projected_interpolation_weights_membrane_potential_index = this->add_internal_data(new Data((this->nnode()*slave_ext_mono_elmt_pt->nnode())), true);
	// 		for(unsigned i=0; i < this->nnode(); i++){
	// 			for(unsigned j=0; j < slave_ext_mono_elmt_pt->nnode(); j++){
	// 				this->internal_data_pt(Projected_interpolation_weights_membrane_potential_index)->set_value(i*slave_ext_mono_elmt_pt->nnode() + j, 1.0);
	// 			}
	// 		}


	// 		//Set the index for the external interaction with the cell mesh
	// 		external_mono_mesh_interaction_index = this->ninteraction();
	// 		//Increase the number of interactions by 1
	// 		this->set_ninteraction(this->ninteraction()+1);
	// 	}

	// 	~CellElementWithExternalInterpolatedMembranePotential()
	// 	{
	// 		delete slave_ext_mono_elmt_pt;
	// 	}

	// 	//internal local equation for the ith interpolation weight for nth node
	// 	inline unsigned interpolation_weight_local_eqn(const unsigned &n, const unsigned &i)const
	// 		{return this->internal_local_eqn(Projected_interpolation_weights_membrane_potential_index, n*slave_ext_mono_elmt_pt->nnode() + i);}


	// 	// get the interpolation weight associated with the nth local node and ith external node
	// 	inline double interpolation_weight_external_membrane_potential(const unsigned &n, const unsigned &i) const
	// 	{
	// 		return this->internal_data_pt(Projected_interpolation_weights_membrane_potential_index)->value(n*slave_ext_mono_elmt_pt->nnode() + i);
	// 	}

	// 	// // get the interpolation weight associated with the nth local node and ith external node
	// 	// inline double interpolation_weight_external_membrane_potential(const unsigned &n, const unsigned &i, const unsigned &t) const
	// 	// {
	// 	// 	return this->internal_data_pt(Projected_interpolation_weights_membrane_potential_index)->value(t, n*slave_ext_mono_elmt_pt->nnode() + i);
	// 	// }

		
	// 	//return the ipt associated with node n
	// 	inline unsigned ipt_at_node(unsigned &n) const {
	// 		return ipt_not_at_nodes + n;
	// 	}

	// 	inline double total_interpolation_weight_at_point(const Vector<double>& s) const
	// 	{
	// 		//Number of nodes
	// 		const unsigned n_node = this->nnode();
	// 		Shape psi(n_node);
	// 		this->shape(s, psi);
	// 		unsigned ipt_node;
	// 		double total_interp_weights = 0.0;

	// 		for(unsigned l=0; l<this->nnode(); l++){
	// 			// std::cout << l << std::endl;
	// 			//get the ipt associated with node l
	// 			ipt_node = this->ipt_at_node(l);
	// 			//If the node lies in an external element
	// 			EXT_MONO_ELEMENT* ext_elmt_pt = dynamic_cast<EXT_MONO_ELEMENT*>(external_element_pt(external_mono_mesh_interaction_index, ipt_node));
	// 			//if the node lies in an external element and  then interpolate with it, using the interpolation weights stored in internal data
	// 			if(ext_elmt_pt!=0){
	// 				//add to total weights
	// 				total_interp_weights += psi[l];
	// 			}
	// 		}
	// 		return total_interp_weights;
	// 	}


	// 	//internal local equation for potential_difference
	// 	inline double interpolated_external_membrane_potential(const Vector<double>& s) const
	// 	{
	// 		//Number of nodes
	// 		const unsigned n_node = this->nnode();
	// 		Shape psi(n_node);
	// 		this->shape(s, psi);
	// 		double I = 0.0;
	// 		double I_node;
	// 		unsigned ipt_node;
	// 		double total_interp_weights=0.0;

	// 		//Loop over the nodes in this element
	// 		for(unsigned l=0; l<this->nnode(); l++){
	// 			// std::cout << l << std::endl;
	// 			//get the ipt associated with node l
	// 			ipt_node = this->ipt_at_node(l);
	// 			//If the node lies in an external element
	// 			EXT_MONO_ELEMENT* ext_elmt_pt = dynamic_cast<EXT_MONO_ELEMENT*>(external_element_pt(external_mono_mesh_interaction_index, ipt_node));
	// 			unsigned ext_u_mono_index = ext_elmt_pt->u_index_monodomain();
	// 			//if the node lies in an external element and  then interpolate with it, using the interpolation weights stored in internal data
	// 			if(ext_elmt_pt!=0){
	// 				//then interpolate the value of membrane potential in external element
	// 				//	using the weights we have calculated
	// 				I_node = 0.0;
	// 				//loop over the nodes in the external element
	// 				for(unsigned l1=0; l1<ext_elmt_pt->nnode(); l1 ++){
	// 					I_node += ext_elmt_pt->nodal_value(l,ext_u_mono_index)*interpolation_weight_external_membrane_potential(l,l1);
	// 								;
	// 				}
	// 				//add contribution from this node to the interpolated membrane potential
	// 				I += I_node*psi[l];
	// 				//add to total weights used
	// 				total_interp_weights += psi[l];
	// 			}

	// 		}
	// 		//divide interpolated membrane potential by total weights used
	// 		if(total_interp_weights > 1e-13){
	// 			I/=total_interp_weights;
	// 		}
	// 		return I;
	// 	}


	// 	//Overload source monodomain to get membrane potential part of source from
	// 	// internal_data pt rather than an external element
	// 	void get_membrane_potential_CellInterface(const unsigned& ipt,
	// 												const Vector<double>& s,
	// 												const Vector<double>& x,
	// 												double& V) const
	// 	{
	// 		//Things common to all integral points
	// 		unsigned n_dim=this->dim();

	// 		//Zero the source
	// 		V = 0.0;
	// 		//Set the Vector to hold local coordinates
	// 		// Vector<double> s(n_dim,0.0);
	// 		//Assign values of s
	// 		// for(unsigned i=0;i<n_dim;i++) s[i] = this->integral_pt()->knot(ipt,i);

	// 		V = this->interpolated_external_membrane_potential(s);
	// 	}

	// 	//	projection from a member function rather than nodal data
	// 	void residual_for_projection_of_membrane_potential(Vector<double> &residuals, 
	// 				                                      DenseMatrix<double> &jacobian, 
	// 				                                      const unsigned& flag)
	// 	{	
	// 		//Things common to all integral points
	// 		unsigned n_dim=this->dim();

	// 		//Allocate storage for local coordinates
	// 		Vector<double> s(n_dim);

	// 		//total interpolation weight used at the point
	// 		double total_interp_weights;

	// 		//Set the value of n_intpt
 // 			const unsigned n_intpt = this->integral_pt()->nweight();

 // 			unsigned ipt_node;
			
	// 		//Number of nodes
	// 		const unsigned n_node = this->nnode();
	// 		//Number of positional dofs
	// 		const unsigned n_position_type = this->nnodal_position_type();

	// 		//Loop over the integration points
	// 		for(unsigned ipt=0;ipt<n_intpt;ipt++)
	// 		{
	// 			// Get the local coordinates of Gauss point
	// 			for(unsigned i=0;i<n_dim;i++) s[i] = this->integral_pt()->knot(ipt,i);

	// 			total_interp_weights = total_interpolation_weight_at_point(s);

	// 			//Get the integral weight
	// 			double w = this->integral_pt()->weight(ipt);

	// 			if(w==0.0){continue;}

	// 			//local shape function
	// 			Shape psi(n_node);
	// 			//A dummy shape derivative so we can get the jacobian
	// 			DShape dpsidx(n_node, n_dim);
	// 			double J = this->dshape_eulerian_at_knot(ipt,psi,dpsidx);

	// 			double W = w*J;

	// 			double interpolated_value_proj = 0.0;
	// 			double interpolated_value_bar = 0.0;

	// 			//Storage for the local equation and local unknown
	// 			int eqn=0, unknown=0;

	// 			//The external element and it's local coord and number of nodes
	// 			Vector<double> other_s(n_dim);

	// 			//Do project cell_membrane potential
	// 			// Find same point in base mesh using external storage
	// 			FiniteElement* ext_elmt_pt = this->external_element_pt(external_mono_mesh_interaction_index,ipt);
	// 			EXT_MONO_ELEMENT* other_el_pt = dynamic_cast<EXT_MONO_ELEMENT*>(ext_elmt_pt);

	// 			if(other_el_pt!=0){
	// 				other_s=this->external_element_local_coord(external_mono_mesh_interaction_index,ipt);

	// 				//get the local cell membrane potential at s
	// 				interpolated_value_proj = this->interpolated_external_membrane_potential(s);
	// 				//get the other cell membrane potential at the other_s
	//  				interpolated_value_bar = other_el_pt->interpolated_u_monodomain(other_s);
	//  			}

	//  			//LOOP OVER LOCAL NODES
	//  			for(unsigned l=0; l<this->nnode(); l++){

	//  				// Get the data's timestepper
	// 			    // TimeStepper* time_stepper_pt= this->node_pt(l)->time_stepper_pt();
	// 			    // const unsigned n_time = time_stepper_pt->ntstorage();

	// 	 			//GET THE INTERPOLATION POINT THE NODE LIVES AT
	//  				ipt_node=this->ipt_at_node(l);

	// 	 			//GET THE EXTERNAL ELEMENT THE NODE IS AT
	//  				FiniteElement* ext_elmt_node_pt = this->external_element_pt(external_mono_mesh_interaction_index,ipt_node);
	//  				EXT_MONO_ELEMENT* other_el_node_pt = dynamic_cast<EXT_MONO_ELEMENT*>(ext_elmt_node_pt);

	// 	 			//IF THE NODE IS INSIDE AN EXTERNAL ELEMENT
	// 	 			if(other_el_node_pt!=0){
	// 	 				//LOOP OVER INTERPOLATION WEIGHTS FOR THAT NODE
	// 	 				for(unsigned l_ext_1=0; l_ext_1<other_el_node_pt->nnode(); l_ext_1++){
	// 	 					eqn = interpolation_weight_local_eqn(l, l_ext_1);
	// 	 					if(eqn>=0){
	//  							//FILL IN RESIDUAL
	// 		 					residuals[eqn] -= (interpolated_value_proj - interpolated_value_bar)*psi[l]*W;
	// 		 					if(flag){
	// 		 						//loop over the other nodes in the element
	// 		 						for(unsigned l1=0; l1<this->nnode();l1++){

	// 		 							//GET THE EXTERNAL ELEMENT THE SECOND NODE IS AT
	// 					 				FiniteElement* ext_elmt_node_pt_2 = this->external_element_pt(external_mono_mesh_interaction_index,ipt_node);
	// 					 				EXT_MONO_ELEMENT* other_el_node_pt_2 = dynamic_cast<EXT_MONO_ELEMENT*>(ext_elmt_node_pt_2);
	// 					 				unsigned ext_u_mono_index = other_el_node_pt_2->u_index_monodomain();

	// 			 						//LOOP OVER INTERPOLATION WEIGHTS
	// 					 				for(unsigned l_ext_2=0; l_ext_2<other_el_node_pt_2->nnode(); l_ext_2++){
	// 					 					unknown = interpolation_weight_local_eqn(l1, l_ext_2);
	// 					 					if(unknown>=0){
	// 				 							//FILL IN JACOBIAN !!!!! THIS MIGHT BE HORRIBLY WRONG
	// 				 							jacobian(eqn, unknown) -= other_el_node_pt_2->nodal_value(l_ext_2,ext_u_mono_index)*psi[l1]*psi[l]*W/total_interp_weights;
	// 				 						}
	// 				 					}
	// 				 				}
	// 			 				}
	// 		 				}
	// 		 			}
	// 		 		}

	// 		 		//if there is no external element then we set residual = 0 and jacobian = 1 on diagonal
	// 	 			else{
	// 					//LOOP OVER INTERPOLATION WEIGHTS FOR THAT NODE
	// 	 				for(unsigned l_ext_1=0; l_ext_1<slave_ext_mono_elmt_pt->nnode(); l_ext_1++){
	// 	 					eqn = interpolation_weight_local_eqn(l, l_ext_1);
	// 	 					if(eqn>=0){
	// 	 						// for(unsigned t=0;t<n_time;t++){
	// 					          //Since the data is purely passive we DON'T want it to change with the movement of the mesh
	// 					          // residuals[eqn] -= time_stepper_pt->weight(1,t)*interpolation_weight_external_membrane_potential(l,index,t)*psi[l]*W;
	// 	 							residuals[eqn] -= this->interpolation_weight_external_membrane_potential(l,l_ext_1)*psi[l]*W;
 //        						// }
	// 	 						if(flag){
	// 	 							//FILL IN JACOBIAN
	// 	 							jacobian(eqn, eqn) -= 1.0;
	// 	 						}
	// 	 					}
	// 	 				}
	// 	 			}

	// 	 		}// end loop over nodes
	// 		} // End loop over integration points
	// 	}


	// 	/// Add the element's contribution to its residual vector (wrapper)
	// 	void fill_in_contribution_to_residuals(Vector<double> &residuals)
	// 	{
	// 	   	//Call the generic residuals function with flag set to 0 and using
	// 	   	//a dummy matrix
	// 		BASE_CELL_ELEMENT::fill_in_contribution_to_residuals(residuals);

	// 		this->residual_for_projection_of_membrane_potential(residuals,
	// 														GeneralisedElement::Dummy_matrix,
	// 														0);
	// 	}

	// 	void fill_in_contribution_to_jacobian(Vector<double> &residuals, 
	// 											DenseMatrix<double> &jacobian)
	// 	{	
	// 		//Contribution from cell element
	// 		BASE_CELL_ELEMENT::fill_in_contribution_to_jacobian(residuals,
	// 															jacobian);
	// 		//Contribution from projecting to solid mesh
	// 		this->residual_for_projection_of_membrane_potential(residuals,
	// 														jacobian,
	// 														1);
	// 	}

	// protected:
	// 	unsigned Projected_interpolation_weights_membrane_potential_index;
		
	// 	unsigned external_mono_mesh_interaction_index;

	// private:
	// 	// slave element so we can get the number of nodes in the external element reliably
	// 	EXT_MONO_ELEMENT* slave_ext_mono_elmt_pt;

	// 	//The number of integration points which are not aligned with nodes.
	// 	unsigned ipt_not_at_nodes;
	// };

















}

#endif