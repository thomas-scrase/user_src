//LIC// ====================================================================
//LIC// This file contains component_multiphysics elements, elements which are
//LIC//	themselves useless but occupy a domain in a multi-discretised multi-
//LIC//	physics element.
//LIC//
//LIC//
//LIC// This file contains the multi domain expansion for the anisotropic_solid
//LIC// element which allows for it to be used in multi-domain discretisation
//LIC// problems along with storage_augmented_cell_interface_element,
//LIC// each in their own distinctly discretised domains.
//LIC//
//LIC// This file also contains the refineable solid element with exeternal Q
//LIC// element.
//LIC// ====================================================================

#ifndef OOMPH_ANISOTROPIC_SOLID_EXTERNAL_AUGMENTED_CELL_ELEMENT
#define OOMPH_ANISOTROPIC_SOLID_EXTERNAL_AUGMENTED_CELL_ELEMENT

// Config header generated by autoconfig
#ifdef HAVE_CONFIG_H
  #include <oomph-lib-config.h>
#endif

//Generic for the element with external element
#include "generic.h"

//Solid elements for the external solid element for geometric data
#include "../anisotropic_solid/anisotropic_solid_elements.h"

//Monodomain elements
#include "../monodomain/monodomain_elements.h"

//Cell interface elements (includes cell models)
#include "../cell_interface/cell_interface_elements.h"

namespace oomph{

	template<unsigned DIM, unsigned NNODE_1D>
	class QAnisotropicSolidElementWithExternalAugmentedCellElement	:
	public virtual QAnisotropicPVDElement<DIM, NNODE_1D>,
	public virtual ElementWithExternalElement
	{
	public:
		QAnisotropicSolidElementWithExternalCellElement()	:
		QAnisotropicPVDElement<DIM, NNODE_1D>(),
		ElementWithExternalElement()
		{
			this->set_ninteraction(1);
		}

		void anisotropic_matrix(const unsigned& ipt,
								const Vector<double> &s,
								const Vector<double>& xi,
								const DenseMatrix<double> &g,
								const DenseMatrix<double> &G,
								DenseMatrix<double>& A)
		{
			unsigned cell_interaction = 0;
			A = dynamic_cast<VectorWithDiffusionStorageEnrichmentEquations<DIM*(DIM+1)>*>
				(external_element_pt(cell_interaction, ipt))->get_interpolated_fibre_orientation_augmented_cell(external_element_local_coord(cell_interaction, ipt));
		}

		void anisotropic_vector(const unsigned& ipt,
								const Vector<double> &s,
								const Vector<double>& xi,
								const DenseMatrix<double> &g, 
								const DenseMatrix<double> &G,
								Vector<double>& lambda) const
		{
			unsigned cell_interaction = 0;
			lambda.resize(1);
			lambda[0] = dynamic_cast<CellInterfaceEquations<DIM>*>
			(external_element_pt(cell_interaction, ipt))->get_interpolated_cell_active_strain(external_element_local_coord(cell_interaction, ipt));
		}


		///\short Compute the element's residual vector and the Jacobian matrix.
		/// Jacobian is computed by finite-differencing
		void fill_in_contribution_to_jacobian(Vector<double> &residuals, 
												DenseMatrix<double> &jacobian)
		{
			ElementWithExternalElement::fill_in_contribution_to_jacobian(residuals,jacobian);
		}

		/// Add the element's contribution to its residuals vector,
		/// jacobian matrix and mass matrix
		void fill_in_contribution_to_jacobian_and_mass_matrix(Vector<double> &residuals,
																DenseMatrix<double> &jacobian,
																DenseMatrix<double> &mass_matrix)
		{
			//Call the standard (Broken) function
			//which will prevent these elements from being used
			//in eigenproblems until replaced.
			FiniteElement::fill_in_contribution_to_jacobian_and_mass_matrix(residuals,jacobian,mass_matrix);
		}
	};

	template<unsigned DIM, unsigned NNODE_1D>
	class RefineableQAnisotropicSolidElementWithExternalAugmentedCellElement	:
	public virtual RefineableQAnisotropicPVDElement<DIM, NNODE_1D>,
	public virtual ElementWithExternalElement
	{
	public:
		QAnisotropicSolidElementWithExternalCellElement()	:
		RefineableQAnisotropicPVDElement<DIM, NNODE_1D>(),
		ElementWithExternalElement()
		{
			this->set_ninteraction(1);
		}

		void anisotropic_matrix(const unsigned& ipt,
								const Vector<double> &s,
								const Vector<double>& xi,
								const DenseMatrix<double> &g,
								const DenseMatrix<double> &G,
								DenseMatrix<double>& A)
		{
			unsigned cell_interaction = 0;
			A = dynamic_cast<VectorWithDiffusionStorageEnrichmentEquations<DIM*(DIM+1)>*>
				(external_element_pt(cell_interaction, ipt))->get_interpolated_fibre_orientation_augmented_cell(external_element_local_coord(cell_interaction, ipt));
		}

		void anisotropic_vector(const unsigned& ipt,
								const Vector<double> &s,
								const Vector<double>& xi,
								const DenseMatrix<double> &g, 
								const DenseMatrix<double> &G,
								Vector<double>& lambda) const
		{
			unsigned cell_interaction = 0;
			lambda.resize(1);
			lambda[0] = dynamic_cast<CellInterfaceEquations<DIM>*>
			(external_element_pt(cell_interaction, ipt))->get_interpolated_cell_active_strain(external_element_local_coord(cell_interaction, ipt));
		}


		///\short Compute the element's residual vector and the Jacobian matrix.
		/// Jacobian is computed by finite-differencing
		void fill_in_contribution_to_jacobian(Vector<double> &residuals, 
												DenseMatrix<double> &jacobian)
		{
			ElementWithExternalElement::fill_in_contribution_to_jacobian(residuals,jacobian);
		}

		/// Add the element's contribution to its residuals vector,
		/// jacobian matrix and mass matrix
		void fill_in_contribution_to_jacobian_and_mass_matrix(Vector<double> &residuals,
																DenseMatrix<double> &jacobian,
																DenseMatrix<double> &mass_matrix)
		{
			//Call the standard (Broken) function
			//which will prevent these elements from being used
			//in eigenproblems until replaced.
			FiniteElement::fill_in_contribution_to_jacobian_and_mass_matrix(residuals,jacobian,mass_matrix);
		}
	};
}

#endif