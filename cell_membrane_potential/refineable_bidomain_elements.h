//Header file for refineable Monodomain elements
#ifndef OOMPH_REFINEABLE_BIDOMAIN
#define OOMPH_REFINEABLE_BIDOMAIN

// Config header generated by autoconfig
#ifdef HAVE_CONFIG_H
  #include <oomph-lib-config.h>
#endif

//oomph-lib headers
#include "../generic/refineable_quad_element.h"
#include "../generic/refineable_brick_element.h"
#include "../generic/error_estimator.h"

#include "bidomain_elements.h"

namespace oomph
{
	template <unsigned DIM>
	class RefineableBidomainEquations :	public virtual BidomainEquations<DIM>,
										public virtual RefineableElement,
										public virtual ElementWithZ2ErrorEstimator
	{
	public:

		//empty constructor
		RefineableBidomainEquations()	:	BidomainEquations<DIM>(),
											RefineableElement(),
											ElementWithZ2ErrorEstimator()
		{	}

		/// Broken copy constructor
		RefineableBidomainEquations(
			const RefineableBidomainEquations<DIM>& dummy) 
		{ 
			BrokenCopy::broken_copy("RefineableBidomainEquations");
		}

		/// Broken assignment operator
		void operator=(const RefineableBidomainEquations<DIM>&) 
		{
			BrokenCopy::broken_assign(
			"RefineableBidomainEquations");
		}

		/// Number of 'flux' terms for Z2 error estimation 
 		unsigned num_Z2_flux_terms() {return DIM;}

 		/// \short Get 'flux' for Z2 error recovery:  
		/// Standard flux.from GeneralisedAdvectionDiffusion equations
		void get_Z2_flux(const Vector<double>& s, Vector<double>& flux)
		{this->get_flux(s,flux);}

		/// \short Get the function value u in Vector.
		/// Note: Given the generality of the interface (this function
		/// is usually called from black-box documentation or interpolation routines),
		/// the values Vector sets its own size in here.
		void get_interpolated_values(const Vector<double>&s,
									Vector<double>& values)
		{
			// Set size of Vector: u
			values.resize(2);

			//Find number of nodes
			const unsigned n_node = this->nnode();

			//Find the index at which the unknown is stored
			const unsigned vm_nodal_index = this->vm_index_BaseCellMembranePotential();
			const unsigned phie_nodal_index = this->phie_index_Bidomain();
			//Local shape function
			Shape psi(n_node);

			//Find values of shape function
			this->shape(s,psi);

			//Initialise value of vm and phi_e
			values[0] = 0.0;
			values[1] = 0.0;

			//Loop over the local nodes and sum
			for(unsigned l=0;l<n_node;l++){
				values[0] += this->nodal_value(l,vm_nodal_index)*psi[l];
				values[1] += this->nodal_value(l,phie_nodal_index)*psi[l];
			}
		}

		/// \short Get the function value u in Vector.
		/// Note: Given the generality of the interface (this function
		/// is usually called from black-box documentation or interpolation routines),
		/// the values Vector sets its own size in here.
		void get_interpolated_values(const unsigned& t,
									const Vector<double>&s,
									Vector<double>& values)
		{
			// Set size of Vector:
			values.resize(2);

			//Find out how many nodes there are
			const unsigned n_node = this->nnode();

			//Find the nodal index at which the unknown is stored
			const unsigned vm_nodal_index = this->vm_index_BaseCellMembranePotential();
			const unsigned phie_nodal_index = this->phie_index_Bidomain();

			// Shape functions
			Shape psi(n_node);

			//Find values of shape function
			this->shape(s,psi);

			//Initialise the value of u
			values[0] = 0.0;
			values[1] = 0.0;

			//Calculate value
			for(unsigned l=0;l<n_node;l++) 
			{
				values[0] += this->nodal_value(t,l,vm_nodal_index)*psi[l];
				values[1] += this->nodal_value(t,l,phie_nodal_index)*psi[l];
			}
		}

		///  Further build: Copy source function pointer from father element
		void further_build()
		{
			RefineableBidomainEquations<DIM>* cast_father_element_pt 
				= dynamic_cast<RefineableBidomainEquations<DIM>*>(this->father_element_pt());

			//Set the values of the pointers from the father
			this->Source_fct_pt = cast_father_element_pt->source_fct_pt();
			this->Intracellular_Conductivity_Fct_Pt = cast_father_element_pt->intracellular_conductivity_fct_pt();
			this->Extracellular_Conductivity_Fct_Pt = cast_father_element_pt->extracellular_conductivity_fct_pt();
			this->Cm_pt = cast_father_element_pt->cm_pt();

			//Set the ALE status
			this->ALE_is_disabled = cast_father_element_pt->ALE_is_disabled;
		}
 
 	protected:
 
		/// \short Add the element's contribution to the elemental residual vector 
		/// and/or Jacobian matrix 
		/// flag=1: compute both
		/// flag=0: compute only residual vector
		void fill_in_generic_residual_contribution_BaseCellMembranePotential(	Vector<double> &residuals,
																DenseMatrix<double> &jacobian, 
																DenseMatrix<double> &mass_matrix,
																unsigned flag); 
	};

	template<unsigned DIM, unsigned NNODE_1D>
	class RefineableQBidomainElement	:
	public	QBidomainElement<DIM, NNODE_1D>,
	public virtual RefineableBidomainEquations<DIM>,
	public virtual RefineableQElement<DIM>
	{
	public:
		RefineableQBidomainElement()	:
			RefineableElement(),
			RefineableBidomainEquations<DIM>(),
			RefineableQElement<DIM>(),
			QBidomainElement<DIM, NNODE_1D>()
			{	}

		/// Broken copy constructor
		RefineableQBidomainElement(
			const RefineableQBidomainElement<DIM,NNODE_1D>& dummy){ 
			BrokenCopy::broken_copy(
			"RefineableQBidomainElement");
		} 

		/// Broken assignment operator
		void operator=(const RefineableQBidomainElement<DIM,NNODE_1D>&){
			BrokenCopy::broken_assign(
			"RefineableQBidomainElement");
		}

		/// Number of continuously interpolated values: 1
		unsigned ncont_interpolated_values() const {return 1;}

		/// \short Number of vertex nodes in the element
		unsigned nvertex_node() const
		{return QBidomainElement<DIM,NNODE_1D>::nvertex_node();}

		/// \short Pointer to the j-th vertex node in the element
		Node* vertex_node_pt(const unsigned& j) const
		{return QBidomainElement<DIM,NNODE_1D>::vertex_node_pt(j);}

		/// Rebuild from sons: empty
		void rebuild_from_sons(Mesh* &mesh_pt) {}

		/// \short Order of recovery shape functions for Z2 error estimation:
		/// Same order as shape functions.
		unsigned nrecovery_order() {return (NNODE_1D-1);}

		///  \short Perform additional hanging node procedures for variables
		/// that are not interpolated by all nodes. Empty.
		void further_setup_hanging_nodes(){}
	};

	//=======================================================================
	/// Face geometry for the 
	/// RefineableQuadGeneralisedAdvectionDiffusionElement elements: The spatial 
	/// dimension of the face elements is one lower than that of the
	/// bulk element but they have the same number of points
	/// along their 1D edges.
	//=======================================================================
	template<unsigned DIM, unsigned NNODE_1D>
	class FaceGeometry<RefineableQBidomainElement<DIM,NNODE_1D> >: 
	public virtual QElement<DIM-1,NNODE_1D>
	{

	public:

		/// \short Constructor: Call the constructor for the
		/// appropriate lower-dimensional QElement
		FaceGeometry() : QElement<DIM-1,NNODE_1D>() {}

	};

	//=======================================================================
	/// Face geometry for the 1D QGeneralisedAdvectionDiffusion elements: Point elements
	//=======================================================================
	template<unsigned NNODE_1D>
	class FaceGeometry<RefineableQBidomainElement<1,NNODE_1D> >: 
	public virtual PointElement
	{

	public:

		/// \short Constructor: Call the constructor for the
		/// appropriate lower-dimensional QElement
		FaceGeometry() : PointElement() {}

	};

}

#endif