//LIC// ====================================================================
//LIC// This file contains the base equations for all Cell membrane potential
//LIC// equations and elements.
//LIC//  Contains all members common to both monodomain and bidomain equations
//LIC//====================================================================


//Header file for cell membrane potential elements
#ifndef OOMPH_CELL_MEMBRANE_POTENTIAL
#define OOMPH_CELL_MEMBRANE_POTENTIAL


// Config header generated by autoconfig
#ifdef HAVE_CONFIG_H
  #include <oomph-lib-config.h>
#endif

//OOMPH-LIB headers
#include "../generic/nodes.h"
#include "../generic/oomph_utilities.h"
#include "../generic/Qelements.h"
#include "../generic/Telements.h"
#include "../generic/error_estimator.h"
#include "../generic/oomph_utilities.h"

namespace oomph
{

static double Default_membrane_capacitance = 1.0;

//=============================================================
//Implements some functions needed by the cell model class. However the cell
// model class has (and should have) no concept of dimension
// therefore we need these functions implemented in a dimensionless way.
// Also provides a convenient place to implement some other functions
//=============================================================
class DimensionlessMembranePotentialEquationsBase : public virtual FiniteElement
{
public:
  //Update the value of membrane potential stored in the local node l according to some value. This is virtual
  // since in some implementations of this element the value stored is not actually the membrane potential
  virtual inline void update_nodal_membrane_potential_BaseCellMembranePotential(const unsigned &l, const double& vm)=0;

  //These are virtual since for toms method of operator splitting the nodal value actually represents the time integral
  // of the membrane potential - not the membrane potential itself
  //Get the membrane potential at the nth node
  virtual inline double get_nodal_membrane_potential_BaseCellMembranePotential(const unsigned &n) const =0;

  //Get the t-th history value of membrane potential at the nth node
  virtual inline double get_nodal_membrane_potential_BaseCellMembranePotential(const unsigned &t, const unsigned &n) const =0;

  virtual void assign_additional_initial_conditions(const unsigned &l)
  {
    throw OomphLibError(
    "Assign initial conditions has not been implemented yet",
    OOMPH_CURRENT_FUNCTION,
    OOMPH_EXCEPTION_LOCATION);
  }
  

  //Return the value of the equation from Gima and Rudy 2002 representing the pseudo ecg for the domain this element contains
  double integrate_ecg(const Vector<double>& xprime) const
  {
    // Initialise
    double sum = 0.0;

    const unsigned dim = this->dim();
    //Vector of local coordinates
    Vector<double> s(dim);

    //Find out how many nodes there are in the element
    const unsigned n_node = nnode();

    // //Find the index at which the concentration is stored
    // const unsigned vm_nodal_index = this->vm_index_BaseCellMembranePotential();

    //Allocate memory for the shape functions
    Shape psi(n_node);
    DShape dpsidx(n_node,dim);

    //Set the value of n_intpt
    const unsigned n_intpt = integral_pt()->nweight();

    //Loop over the integration points
    for(unsigned ipt=0;ipt<n_intpt;ipt++)
    {
      //Get the integral weight
      const double w = integral_pt()->weight(ipt);

      //Get the gradients
      (void)this->dshape_eulerian_at_knot(ipt,psi,dpsidx);
      
      //Memory for the membrane potential derivative, and the interpolated coordinat at the integral point
      Vector<double> interpolated_dvmdx(dim, 0.0); 
      Vector<double> interpolated_x(dim, 0.0);

      //Loop over the nodes
      for(unsigned l=0;l<n_node;l++)
      {
        for(unsigned i=0;i<dim;i++)//and the coordinates
        {
          //calculate the interpolated values
          interpolated_dvmdx[i] += get_nodal_membrane_potential_BaseCellMembranePotential(l)*dpsidx(l,i);
          interpolated_x[i] += this->raw_nodal_position(l,i)*psi(l);
        }
      }

      //Calculate the distance of the 
      double r = 0.0;
      for(unsigned i=0;i<dim;i++)
      {
        r += pow(interpolated_x[i]-xprime[i], 2.0);
      }
      //If the coordinate of the electrode is of a different dimension to ours we assume that we are aligned with the coordinate axes in the extra dimensions
      // and hence our coordinate in the y and z directions are zero
      if(xprime.size()>dim)
      {
        for(unsigned i=dim; i<xprime.size(); i++)
        {
          r += pow(xprime[i], 2.0);
        }
      }

      //Converse is handled
      if(dim>xprime.size())
      {
        for(unsigned i=xprime.size(); i<dim; i++)
        {
          r += pow(interpolated_x[i], 2.0);
        }
      }

      r = sqrt(r);
      

      double integrand_val = 0.0;
      for(unsigned i=0;i<dim;i++)
      {
        // integrand_val -= interpolated_dvmdx[i]*(interpolated_x[i] - xprime[i])/r;

        integrand_val += interpolated_dvmdx[i]*(interpolated_x[i] - xprime[i])/pow(r, 3.0);
      }

      // Get jacobian of mapping
      const double J=J_eulerian_at_knot(ipt);

      //Add the values to the sum
      sum += integrand_val*w*J;
    }
   //return the sum
   return sum;
  }  
};


//Base equations of all membrane potential equations classes
template <unsigned DIM>
class BaseCellMembranePotentialEquations : public virtual FiniteElement,
																						public virtual DimensionlessMembranePotentialEquationsBase
{
public:

	/// \short Function pointer to source function fct(x,f(x)) -- 
	/// x is a Vector! 
	typedef void (*BaseCellMembranePotentialSourceFctPt)
		(const Vector<double>& x, double& f);

	///short function pointer to vm predicted at node l.
	typedef double (*BaseCellMembranePotentialPredictedVmFctPt)
		(const unsigned& l);

	//change this to take s instead of x? (no functional change, just notation)
		/// \short Funciton pointer to a diffusivity function
		typedef void (*BaseCellMembranePotentialDiffFctPt)
		(const Vector<double> &x, DenseMatrix<double> &D);


	/// \short Constructor: Initialise the Source_fct_pt and Wind_fct_pt 
	/// to null and set (pointer to) Peclet number to default
	BaseCellMembranePotentialEquations() : Source_fct_pt(0),
																					Predicted_vm_fct_pt(0),
																					Integral_Iion_pt(0),
																					ALE_is_disabled(false),
																					ipt_not_at_nodes(0),
																					Diff_fct_pt(0)
	{
		//Set membrane capacitance to default
		Cm_pt = &Default_membrane_capacitance;
	}

	/// Broken copy constructor
	BaseCellMembranePotentialEquations(
	const BaseCellMembranePotentialEquations<DIM>& dummy) 
	{ 
		BrokenCopy::broken_copy("BaseCellMembranePotentialEquations");
	} 

	/// Broken assignment operator
	void operator=(const BaseCellMembranePotentialEquations&) 
	{
		BrokenCopy::broken_assign("BaseCellMembranePotentialEquations");
	}

	/// \short All cell_membrane_potential elements will have a storage value
	///        dedicated to membrane potential
	virtual inline unsigned vm_index_BaseCellMembranePotential() const {return 0;}

	//The next free index after this elements data
	virtual inline unsigned max_index_plus_one_BaseCellMembranePotential() const {return vm_index_BaseCellMembranePotential()+1;}

	//get the integration point associated with node n
	inline unsigned ipt_at_node(const unsigned &n) const {return ipt_not_at_nodes + n;}

  //Get the variable names, this has to be overridden in each implementation of the
  // equations
	virtual inline std::vector<std::string> get_variable_names_BaseCellMembranePotentialEquations() const
	{
		throw OomphLibError(
		"get_variable_names_BaseCellMembranePotentialEquations, this function has not been implemented yet",
		OOMPH_CURRENT_FUNCTION,
		OOMPH_EXCEPTION_LOCATION);
	}


	//Pin/unpin all membrane potential variables
	void pin_all_vars()
	{
		for(unsigned l=0; l<this->nnode(); l++)
		{
			for(unsigned i=vm_index_BaseCellMembranePotential(); i<max_index_plus_one_BaseCellMembranePotential();i++)
			{
				this->node_pt(l)->pin(i);
			}
		}
	}

	//Unpin all the membrane potential variables
	void unpin_all_vars()
	{
		for(unsigned l=0; l<this->nnode(); l++)
		{
			for(unsigned i=vm_index_BaseCellMembranePotential(); i<max_index_plus_one_BaseCellMembranePotential();i++)
			{
				this->node_pt(l)->unpin(i);
			}
		}
	}

	//get the interpolated membrane potential
	inline double get_interpolated_membrane_potential_BaseCellMembranePotential(const Vector<double>& s) const
	{
		const unsigned n_node = this->nnode();
		Shape psi(n_node);
		shape(s, psi);
		double val = 0.0;
		for(unsigned l=0; l<n_node; l++)
		{
			val += get_nodal_membrane_potential_BaseCellMembranePotential(l)*psi[l];
		}

		return val;
	}

	//By default we just set the value at the node
	inline void update_nodal_membrane_potential_BaseCellMembranePotential(const unsigned &l, const double& vm)
	{
		this->node_pt(l)->set_value(vm_index_BaseCellMembranePotential(), vm);
	}

	/// \short du/dt at local node n. 
	/// Uses suitably interpolated value for hanging nodes.
	double dvm_dt_BaseCellMembranePotential(const unsigned &n) const
	{
		// Get the data's timestepper
		TimeStepper* time_stepper_pt= this->node_pt(n)->time_stepper_pt();

		//Initialise dudt
		double dvmdt=0.0;
		//Loop over the timesteps, if there is a non Steady timestepper
		if (!time_stepper_pt->is_steady())
		{
			//Find the index at which the variable is stored
			const unsigned vm_nodal_index = vm_index_BaseCellMembranePotential();

			// Number of timsteps (past & present)
			const unsigned n_time = time_stepper_pt->ntstorage();

			for(unsigned t=0;t<n_time;t++)
			{
				dvmdt += time_stepper_pt->weight(1,t)*nodal_value(t,n,vm_nodal_index);
			}
		}
		return dvmdt;
	}

	/// \short d2u/dt2 at local node n. 
	/// Uses suitably interpolated value for hanging nodes.
	double d2vm_dt2_BaseCellMembranePotential(const unsigned &n) const
	{
		// Get the data's timestepper
		TimeStepper* time_stepper_pt= this->node_pt(n)->time_stepper_pt();

		//Initialise dudt
		double d2vmdt2=0.0;
		//Loop over the timesteps, if there is a non Steady timestepper
		if (!time_stepper_pt->is_steady())
		{
			//Find the index at which the variable is stored
			const unsigned vm_nodal_index = vm_index_BaseCellMembranePotential();

			// Number of timsteps (past & present)
			const unsigned n_time = time_stepper_pt->ntstorage();

			for(unsigned t=0;t<n_time;t++)
			{
				d2vmdt2 += time_stepper_pt->weight(2,t)*nodal_value(t,n,vm_nodal_index);
			}
		}
		return d2vmdt2;
	}


	/// Access function: Pointer to diffusion  function
	BaseCellMembranePotentialDiffFctPt& diff_fct_pt() 
	{return Diff_fct_pt;}

	/// Access function: Pointer to diffusion function. Const version
	BaseCellMembranePotentialDiffFctPt diff_fct_pt() const 
	{return Diff_fct_pt;}


	inline virtual void get_diff_BaseCellMembranePotential(const unsigned& ipt,
							                                            const Vector<double> &s,
							                                            const Vector<double>& x,
							                                            DenseMatrix<double>& D) const
		{
			//If no diff function has been set, return identity
			if(Diff_fct_pt==0){
				// oomph_info << "Not using fct pt" << std::endl;
				for(unsigned i=0; i<DIM; i++){
					for(unsigned j=0; j<DIM; j++){
						D(i,j) =  0.0;
					}
					D(i,i)  = 1.0;
				}
			}
			else{
				// Get diffusivity tensor from function
				(*Diff_fct_pt)(x,D);
			}
		}


	//Assign initial conditions of node l to be consistent with the provided value of membrane potential from
	// the cell model. For monodomain this is trivially setting the value to be that provided. However,
	// for bidomain equations a more involved solution may be required. However this may depend of spatial
	// derivatives which makes it more difficult.. how can this be incorporated?
	virtual void assign_initial_conditions_consistent_with_cell_model(const unsigned &l, const double& vm)
	{
		throw OomphLibError("Assign consistent initial conditions has not been implemented yet",
												OOMPH_CURRENT_FUNCTION,
												OOMPH_EXCEPTION_LOCATION);
	}


	/// \short Disable ALE, i.e. assert the mesh is not moving -- you do this
	/// at your own risk!
	void disable_ALE()
	{
		ALE_is_disabled=true;
	}


	/// \short (Re-)enable ALE, i.e. take possible mesh motion into account
	/// when evaluating the time-derivative. Note: By default, ALE is 
	/// enabled, at the expense of possibly creating unnecessary work 
	/// in problems where the mesh is, in fact, stationary. 
	void enable_ALE()
	{
		ALE_is_disabled=false;
	}


	/// Output with default number of plot points
	void output(std::ostream &outfile) 
	{
		unsigned nplot=5;
		output(outfile,nplot);
	}

	/// \short Output FE representation of soln: x,y,u or x,y,z,u at 
	/// nplot^DIM plot points
	void output(std::ostream &outfile, const unsigned &nplot)
	{
		//Vector of local coordinates
		Vector<double> s(DIM);

		// Tecplot header info
		outfile << tecplot_zone_string(nplot);

		const unsigned n_node = this->nnode();
		const unsigned vm_index = vm_index_BaseCellMembranePotential();
		Shape psi(n_node);
		DShape dpsidx(n_node,DIM);

		// Loop over plot points
		unsigned num_plot_points=nplot_points(nplot);
		for (unsigned iplot=0;iplot<num_plot_points;iplot++)
		{
			// Get local coordinates of plot point
			get_s_plot(iplot,nplot,s);

			// Get Eulerian coordinate of plot point
			Vector<double> x(DIM);
			interpolated_x(s,x);

			for(unsigned i=0;i<DIM;i++) {outfile << x[i] << " ";}
			outfile << get_interpolated_membrane_potential_BaseCellMembranePotential(s) << " ";

			//Get the gradients
			(void)this->dshape_eulerian(s,psi,dpsidx);
			Vector<double> interpolated_dvmdx(DIM,0.0);
			double dvmdt = 0.0;
			for(unsigned n=0;n<n_node;n++)
			{
				const double vm_ = this->nodal_value(n,vm_index);
				dvmdt += dvm_dt_BaseCellMembranePotential(n)*psi(n);
				for(unsigned i=0;i<DIM;i++)
				{
					interpolated_dvmdx[i] += vm_*dpsidx(n,i);
				}
			}

			outfile << dvmdt << " ";

			for(unsigned i=0;i<DIM;i++)
			{
				outfile << interpolated_dvmdx[i]  << " ";
			}

			outfile  << std::endl;
		}
		// Write tecplot footer (e.g. FE connectivity lists)
		write_tecplot_zone_footer(outfile,nplot);
	}


	/// C_style output with default number of plot points
	void output(FILE* file_pt)
	{
		unsigned n_plot=5;
		output(file_pt,n_plot);
	}

	/// \short C-style output FE representation of soln: x,y,u or x,y,z,u at 
	/// n_plot^DIM plot points
	void output(FILE* file_pt, const unsigned &n_plot)
	{
		//Vector of local coordinates
		Vector<double> s(DIM);

		// Tecplot header info
		fprintf(file_pt,"%s",tecplot_zone_string(n_plot).c_str());

		// Loop over plot points
		unsigned num_plot_points=nplot_points(n_plot);
		for (unsigned iplot=0;iplot<num_plot_points;iplot++)
		{
			// Get local coordinates of plot point
			get_s_plot(iplot,n_plot,s);

			for(unsigned i=0;i<DIM;i++) 
			{
				fprintf(file_pt,"%g ",interpolated_x(s,i));
			}

			fprintf(file_pt,"%g \n",get_interpolated_membrane_potential_BaseCellMembranePotential(s));
		}

		// Write tecplot footer (e.g. FE connectivity lists)
		write_tecplot_zone_footer(file_pt,n_plot);

	}


	/// Output exact soln: x,y,u_exact or x,y,z,u_exact at nplot^DIM plot points
	void output_fct(std::ostream &outfile, const unsigned &nplot, 
									FiniteElement::SteadyExactSolutionFctPt 
									exact_soln_pt)
	{
		//Vector of local coordinates
		Vector<double> s(DIM);

		// Vector for coordintes
		Vector<double> x(DIM);

		// Tecplot header info
		outfile << tecplot_zone_string(nplot);

		// Exact solution Vector (here a scalar)
		Vector<double> exact_soln(1);

		// Loop over plot points
		unsigned num_plot_points=nplot_points(nplot);

		for(unsigned iplot=0;iplot<num_plot_points;iplot++)
		{
			// Get local coordinates of plot point
			get_s_plot(iplot,nplot,s);

			// Get x position as Vector
			interpolated_x(s,x);

			// Get exact solution at this point
			(*exact_soln_pt)(x,exact_soln);

			//Output x,y,...,u_exact
			for(unsigned i=0;i<DIM;i++)
			{
				outfile << x[i] << " ";
			}
			outfile << exact_soln[0] << std::endl;  
		}

		// Write tecplot footer (e.g. FE connectivity lists)
		write_tecplot_zone_footer(outfile,nplot);
	}

	/// \short Output exact soln: x,y,u_exact or x,y,z,u_exact at 
	/// nplot^DIM plot points (dummy time-dependent version to 
	/// keep intel compiler happy)
	virtual void output_fct(std::ostream &outfile, const unsigned &nplot, const double& time, 
	FiniteElement::UnsteadyExactSolutionFctPt exact_soln_pt)
	{
		throw OomphLibError("There is no time-dependent output_fct() for Advection Diffusion elements",
												OOMPH_CURRENT_FUNCTION,
												OOMPH_EXCEPTION_LOCATION);
	}


	/// Get error against and norm of exact solution
	void compute_error(std::ostream &outfile, 
										FiniteElement::SteadyExactSolutionFctPt 
										exact_soln_pt, double& error, double& norm)
	{
		// Initialise
		error=0.0;
		norm=0.0;

		//Vector of local coordinates
		Vector<double> s(DIM);

		// Vector for coordintes
		Vector<double> x(DIM);

		//Find out how many nodes there are in the element
		unsigned n_node = nnode();

		Shape psi(n_node);

		//Set the value of n_intpt
		unsigned n_intpt = integral_pt()->nweight();

		// Tecplot header info
		outfile << "ZONE" << std::endl;

		// Exact solution Vector (here a scalar)
		Vector<double> exact_soln(1);

		//Loop over the integration points
		for(unsigned ipt=0;ipt<n_intpt;ipt++)
		{
			//Assign values of s
			for(unsigned i=0;i<DIM;i++)
			{
				s[i] = integral_pt()->knot(ipt,i);
			}

			//Get the integral weight
			double w = integral_pt()->weight(ipt);

			// Get jacobian of mapping
			double J=J_eulerian(s);

			//Premultiply the weights and the Jacobian
			double W = w*J;

			// Get x position as Vector
			interpolated_x(s,x);

			// Get FE function value
			double vm_fe=get_interpolated_membrane_potential_BaseCellMembranePotential(s);

			// Get exact solution at this point
			(*exact_soln_pt)(x,exact_soln);

			//Output x,y,...,error
			for(unsigned i=0;i<DIM;i++)
			{
				outfile << x[i] << " ";
			}
			outfile << exact_soln[0] << " " << exact_soln[0]-vm_fe << std::endl;  

			// Add to error and norm
			norm+=exact_soln[0]*exact_soln[0]*W;
			error+=(exact_soln[0]-vm_fe)*(exact_soln[0]-vm_fe)*W;
		}
	}


	/// Dummy, time dependent error checker
	void compute_error(std::ostream &outfile, 
										FiniteElement::UnsteadyExactSolutionFctPt 
										exact_soln_pt,
										const double& time, double& error, double& norm)
	{
	throw OomphLibError("No time-dependent compute_error() for Advection Diffusion elements",
											OOMPH_CURRENT_FUNCTION,
											OOMPH_EXCEPTION_LOCATION);
	}

	/// \short Integrate the concentration over the element
	double integrate_vm()
	{
		// Initialise
		double sum = 0.0;

		//Vector of local coordinates
		Vector<double> s(DIM);

		//Find out how many nodes there are in the element
		const unsigned n_node = nnode();

		//Find the index at which the concentration is stored
		const unsigned vm_nodal_index = this->vm_index_BaseCellMembranePotential();

		//Allocate memory for the shape functions
		Shape psi(n_node);

		//Set the value of n_intpt
		const unsigned n_intpt = integral_pt()->nweight();

		//Loop over the integration points
		for(unsigned ipt=0;ipt<n_intpt;ipt++)
		{
			//Get the integral weight
			const double w = integral_pt()->weight(ipt);

			//Get the shape functions
			this->shape_at_knot(ipt,psi);

			//Calculate the concentration
			double interpolated_vm = 0.0;
			for(unsigned l=0;l<n_node;l++) 
			{
				interpolated_vm += this->nodal_value(l,vm_nodal_index)*psi(l);
			}

			// Get jacobian of mapping
			const double J=J_eulerian_at_knot(ipt);

			//Add the values to the sum
			sum += interpolated_vm*w*J;
		}

		//return the sum
		return sum;
	}

	double integrate_vm() const
	{
		// Initialise
		double sum = 0.0;

		//Vector of local coordinates
		Vector<double> s(DIM);

		//Find out how many nodes there are in the element
		const unsigned n_node = nnode();

		//Find the index at which the concentration is stored
		const unsigned vm_nodal_index = this->vm_index_BaseCellMembranePotential();

		//Allocate memory for the shape functions
		Shape psi(n_node);

		//Set the value of n_intpt
		const unsigned n_intpt = integral_pt()->nweight();

		//Loop over the integration points
		for(unsigned ipt=0;ipt<n_intpt;ipt++)
		{
			//Get the integral weight
			const double w = integral_pt()->weight(ipt);

			//Get the shape functions
			this->shape_at_knot(ipt,psi);

			//Calculate the concentration
			double interpolated_vm = 0.0;
			for(unsigned l=0;l<n_node;l++)
			{
				interpolated_vm += this->nodal_value(l,vm_nodal_index)*psi(l);
			}

			// Get jacobian of mapping
			const double J=J_eulerian_at_knot(ipt);

			//Add the values to the sum
			sum += interpolated_vm*w*J;
		}

		//return the sum
		return sum;
	}


	/// Access function: Pointer to source function
	BaseCellMembranePotentialSourceFctPt& source_fct_pt() 
		{return Source_fct_pt;}

	/// Access function: Pointer to source function. Const version
	BaseCellMembranePotentialSourceFctPt source_fct_pt() const 
		{return Source_fct_pt;}


	//Pointer to the predicted membrane potential function
	BaseCellMembranePotentialPredictedVmFctPt& predicted_vm_fct_pt()
		{return Predicted_vm_fct_pt;}
	BaseCellMembranePotentialPredictedVmFctPt predicted_vm_fct_pt() const
		{return Predicted_vm_fct_pt;}


	// BaseCellMembranePotentialPredictedVmFctPt& integral_iion_pt()
	// 	{return Integral_Iion_pt;}
	// BaseCellMembranePotentialPredictedVmFctPt integral_iion_pt() const
	// 	{return Integral_Iion_pt;}


 /// membrane capacitance
 const double &cm() const {return *Cm_pt;}
 /// Pointer to membrane capacitance
 double* &cm_pt() {return Cm_pt;}

 /// \short Get source term at (Eulerian) position x. This function is
 /// virtual to allow overloading in multi-physics problems where
 /// the strength of the source function might be determined by
 /// another system of equations 
 inline virtual void get_source_BaseCellMembranePotential(const unsigned& ipt,
                                                          const Vector<double>& s,
                                                          const Vector<double>& x,
                                                          double& source) const
  {
   //If no source function has been set, return zero
   if(Source_fct_pt==0) {source = 0.0;}
   else
    {
     // Get source strength
     (*Source_fct_pt)(x,source);
    }
  }

  //Get the predicted vm at node l - used by strang splitting elements to get the value of vm
  // achieved through a segregated, decoupled cell solve step
  inline virtual double get_nodal_predicted_vm_BaseCellMembranePotential(const unsigned &l) const
  {
  	// throw OomphLibError(
		 //        "get_nodal_predicted_vm_BaseCellMembranePotential, this shouldn't be called in a multi-domain problem",
		 //        OOMPH_CURRENT_FUNCTION,
		 //        OOMPH_EXCEPTION_LOCATION);
   //If no source function has been set, return zero
   if(Predicted_vm_fct_pt==0) {return 0.0;}
   else
    {
     // Get source strength
     return (*Predicted_vm_fct_pt)(l);
    }
  }


  //Get the interpolated value of membrane potential as predicted by the cell model
  // Passes shape function to allow for call to non-overridden version of this func
  // without the need to re-compute shape functions
  virtual void get_interpolated_predicted_vm_and_dpredicted_vm_dx(double &interpolated_pred_vm, Vector<double> &interpolated_dpred_vm_dx, const Vector<double>& s, const unsigned& ipt, const Shape &psi, const DShape &dpsidx) const
  {
  	//Zero the data
		interpolated_pred_vm = 0.0;
		for(unsigned j=0;j<this->dim();j++)
		{
			interpolated_dpred_vm_dx[j] = 0.0;
		}
    
    const unsigned n_node = this->nnode();

    for(unsigned l=0;l<n_node;l++) 
    { 
      //We get the predicted vm value from the nodal predicted vm, in the cell mesh this will be
      // overridden by a call to the correct cell in the mesh.
      double pred_vm_value = this->get_nodal_predicted_vm_BaseCellMembranePotential(l);

      //Calculated interpolated value
      interpolated_pred_vm += pred_vm_value*psi(l);

      //Calculate interpolated spatial derivatives
      for(unsigned j=0;j<DIM;j++)
      {
        interpolated_dpred_vm_dx[j] += pred_vm_value*dpsidx(l,j);
      }
    }
  }


  // //Get the predicted vm at node l - used by strang splitting elements to get the value of vm
  // // achieved through a segregated, decoupled cell solve step
  // inline virtual double get_nodal_integral_iion_BaseCellMembranePotential(const unsigned &l) const
  // {
  //  //If no source function has been set, return zero
  //  if(Integral_Iion_pt==0) {return 0.0;}
  //  else
  //   {
  //    // Get source strength
  //    return (*Integral_Iion_pt)(l);
  //   }
  // }


  //get the nodal membrane capacitance
  inline virtual double get_nodal_cm_BaseCellMembranePotential(const unsigned &l) const
  {
   //If no source function has been set, return one
   if(Cm_pt==0) {return 1.0;}
   else
    {
     // Get the membrane potential
     return (*Cm_pt);
    }
  }


 /// Get flux: \f$\mbox{flux}[i] = \mbox{d}u / \mbox{d}x_i \f$
 void get_flux(const Vector<double>& s, Vector<double>& flux) const
  {
   //Find out how many nodes there are in the element
   unsigned n_node = nnode();
   
   //Get the nodal index at which the unknown is stored
   unsigned vm_nodal_index = vm_index_BaseCellMembranePotential();

   //Set up memory for the shape and test functions
   Shape psi(n_node);
   DShape dpsidx(n_node,DIM);
 
   //Call the derivatives of the shape and test functions
   dshape_eulerian(s,psi,dpsidx);
     
   //Initialise to zero
   for(unsigned j=0;j<DIM;j++) {flux[j] = 0.0;}
   
   // Loop over nodes
   for(unsigned l=0;l<n_node;l++) 
    {
     //Loop over derivative directions
     for(unsigned j=0;j<DIM;j++)
      {                               
       flux[j] += nodal_value(l,vm_nodal_index)*dpsidx(l,j);
      }
    }
  }

 
 /// Add the element's contribution to its residual vector (wrapper)
 void fill_in_contribution_to_residuals(Vector<double> &residuals)
  {
   //Call the generic residuals function with flag set to 0 and using
   //a dummy matrix
   fill_in_generic_residual_contribution_BaseCellMembranePotential(
    residuals,GeneralisedElement::Dummy_matrix,
    GeneralisedElement::Dummy_matrix,0);
  }

 
 /// \short Add the element's contribution to its residual vector and 
 /// the element Jacobian matrix (wrapper)
 void fill_in_contribution_to_jacobian(Vector<double> &residuals,
                                   DenseMatrix<double> &jacobian)
  {
   //Call the generic routine with the flag set to 1
   fill_in_generic_residual_contribution_BaseCellMembranePotential(residuals,jacobian,GeneralisedElement::Dummy_matrix,1);
  }
 

 /// Add the element's contribution to its residuals vector,
 /// jacobian matrix and mass matrix
 void fill_in_contribution_to_jacobian_and_mass_matrix(
  Vector<double> &residuals, DenseMatrix<double> &jacobian, 
  DenseMatrix<double> &mass_matrix)
  {
   //Call the generic routine with the flag set to 2
   fill_in_generic_residual_contribution_BaseCellMembranePotential(residuals,jacobian,mass_matrix,2);
  }

 //  /// Return FE representation of function value u(s) at local coordinate s
 // inline double interpolated_dvm_dt_BaseCellMembranePotential(const Vector<double> &s) const
 //  {
 //   //Find number of nodes
 //   unsigned n_node = nnode();

 //   //Get the nodal index at which the unknown is stored
 //   // unsigned vm_nodal_index = vm_index_BaseCellMembranePotential();

 //   //Local shape function
 //   Shape psi(n_node);

 //   //Find values of shape function
 //   shape(s,psi);

 //   //Initialise value of u
 //   double interpolated_vm = 0.0;

 //   //Loop over the local nodes and sum
 //   for(unsigned l=0;l<n_node;l++) 
 //    {
 //     interpolated_vm += dvm_dt_BaseCellMembranePotential(l)*psi[l];
 //    }

 //   return interpolated_vm;
 //  }


 /// \short Self-test: Return 0 for OK
 unsigned self_test()
 {

 bool passed=true;

 // Check lower-level stuff
 if (FiniteElement::self_test()!=0)
  {
   passed=false;
  }

 // Return verdict
 if (passed)
  {
   return 0;
  }
 else
  {
   return 1;
  }
   
}

protected:


 /// \short Shape/test functions and derivs w.r.t. to global coords at 
 /// local coord. s; return  Jacobian of mapping
 virtual double dshape_and_dtest_eulerian_BaseCellMembranePotential(const Vector<double> &s, 
                                                   Shape &psi, 
                                                   DShape &dpsidx, 
                                                   Shape &test, 
                                                   DShape &dtestdx) const=0;

 /// \short Shape/test functions and derivs w.r.t. to global coords at 
 /// integration point ipt; return  Jacobian of mapping
 virtual double dshape_and_dtest_eulerian_at_knot_BaseCellMembranePotential(
  const unsigned &ipt, 
  Shape &psi, 
  DShape &dpsidx,
  Shape &test, 
  DShape &dtestdx) 
  const=0;


  /// \short Shape/test functions and derivs w.r.t. to global coords at 
 /// local coord. s; return  Jacobian of mapping
 // virtual double d2shape_and_d2test_eulerian_BaseCellMembranePotential(const Vector<double> &s, 
 //                                                   Shape &psi, 
 //                                                   DShape &dpsidx, 
 //                                                   Shape &test, 
 //                                                   DShape &dtestdx) const=0;

 /// \short Shape/test functions and derivs w.r.t. to global coords at 
 /// integration point ipt; return  Jacobian of mapping
 virtual double d2shape_and_d2test_eulerian_at_knot_BaseCellMembranePotential(
  const unsigned &ipt, 
  Shape &psi, 
  DShape &dpsidx, 
  DShape &d2psidx,
  Shape &test, 
  DShape &dtestdx, 
  DShape &d2testdx) 
  const=0;

 /// \short Add the element's contribution to its residual vector only 
 /// (if flag=and/or element  Jacobian matrix 
 virtual void fill_in_generic_residual_contribution_BaseCellMembranePotential(
  Vector<double> &residuals, DenseMatrix<double> &jacobian, 
  DenseMatrix<double> &mass_matrix, unsigned flag)
 {
  throw OomphLibError(
    "BaseCellMembranePotential has no fill in residual function",
    OOMPH_CURRENT_FUNCTION,
    OOMPH_EXCEPTION_LOCATION);
 }
  
 /// Pointer to global capacitance
 double *Cm_pt;

 BaseCellMembranePotentialDiffFctPt Diff_fct_pt;
 
 /// Pointer to source function:
  BaseCellMembranePotentialSourceFctPt Source_fct_pt;
  
 BaseCellMembranePotentialPredictedVmFctPt Predicted_vm_fct_pt;

 BaseCellMembranePotentialPredictedVmFctPt Integral_Iion_pt;
 /// \short Boolean flag to indicate if ALE formulation is disabled when 
 /// time-derivatives are computed. Only set to false if you're sure
 /// that the mesh is stationary.
 bool ALE_is_disabled;

 //The number of integral points which are not additional ones placed at the nodes
  unsigned ipt_not_at_nodes;

  

  private:

 // /// Static default value for the membrane capacitance
 // static double Default_membrane_capacitance;
 
  
};

}

#endif
