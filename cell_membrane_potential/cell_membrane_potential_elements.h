//LIC// ====================================================================
//LIC// This file contains the base equations for all Cell membrane potential
//LIC// equations and elements.
//LIC//  Contains all members common to both monodomain and bidomain equations
//LIC//====================================================================


//Header file for cell membrane potential elements
#ifndef OOMPH_CELL_MEMBRANE_POTENTIAL
#define OOMPH_CELL_MEMBRANE_POTENTIAL


// Config header generated by autoconfig
#ifdef HAVE_CONFIG_H
  #include <oomph-lib-config.h>
#endif

//OOMPH-LIB headers
#include "../generic/nodes.h"
#include "../generic/oomph_utilities.h"
#include "../generic/Qelements.h"
#include "../generic/Telements.h"
#include "../generic/error_estimator.h"
#include "../generic/oomph_utilities.h"

namespace oomph
{

static double Default_membrane_capacitance = 1.0;
//=============================================================
/// \short A class for all elements that solve the Monodomain
/// equations in conservative form using isoparametric elements.
/// \f[ 
/// \frac{\partial}{\partial x_{i}}\left(
/// Pe w_{i}(x_{k}) u - D_{ij}(x_{k})\frac{\partial u}{\partial x_{j}}\right)
/// = f(x_{j})
/// \f] 
/// This contains the generic maths. Shape functions, geometric
/// mapping etc. must get implemented in derived class.
//=============================================================
template <unsigned DIM>
class BaseCellMembranePotentialEquations : public virtual FiniteElement
{
public:

 /// \short Function pointer to source function fct(x,f(x)) -- 
 /// x is a Vector! 
 typedef void (*BaseCellMembranePotentialSourceFctPt)
  (const Vector<double>& x, double& f);

///short function pointer to vm predicted at node l.
  typedef double (*BaseCellMembranePotentialPredictedVmFctPt)
  (const unsigned& l);
  

 /// \short Constructor: Initialise the Source_fct_pt and Wind_fct_pt 
 /// to null and set (pointer to) Peclet number to default
 BaseCellMembranePotentialEquations() : Source_fct_pt(0),
                                        Predicted_vm_pt(0),
                                        ALE_is_disabled(false)
  {
   //Set membrane capacitance to default
   Cm_pt = &Default_membrane_capacitance;
  }
 
 /// Broken copy constructor
 BaseCellMembranePotentialEquations(
  const BaseCellMembranePotentialEquations<DIM>& dummy) 
  { 
   BrokenCopy::broken_copy("BaseCellMembranePotentialEquations");
  } 
 
 /// Broken assignment operator
 void operator=(const BaseCellMembranePotentialEquations&) 
  {
   BrokenCopy::broken_assign("BaseCellMembranePotentialEquations");
  }

  virtual inline std::vector<std::string> get_variable_names() const = 0;

 /// \short All cell_membrane_potential elements will have a storage value
 ///        dedicated to membrane potential
 virtual inline unsigned vm_index_BaseCellMembranePotential() const {return 0;}

 //The next free index after this elements data
 virtual inline unsigned max_index_plus_one_BaseCellMembranePotential() const {return vm_index_BaseCellMembranePotential()+1;}


 //Pin/unpin all variables, used when performing segregated solving
  void pin_all_vars(){
    for(unsigned l=0; l<this->nnode(); l++){
      for(unsigned i=vm_index_BaseCellMembranePotential(); i<max_index_plus_one_BaseCellMembranePotential();i++){
        this->node_pt(l)->pin(i);
      }
    }
  }
  void unpin_all_vars(){
    for(unsigned l=0; l<this->nnode(); l++){
      for(unsigned i=vm_index_BaseCellMembranePotential(); i<max_index_plus_one_BaseCellMembranePotential();i++){
        this->node_pt(l)->unpin(i);
      }
    }
  }



 //Get the membrane potential at the nth node
 inline double get_nodal_membrane_potential_BaseCellMembranePotential(const unsigned &n) const
 {
  return this->get_nodal_membrane_potential_BaseCellMembranePotential(0, n);
 }

 //Get the t-th history value of membrane potential at the nth node
 inline double get_nodal_membrane_potential_BaseCellMembranePotential(const unsigned &t, const unsigned &n) const
 {
  return this->node_pt(n)->value(t, vm_index_BaseCellMembranePotential());
 }

 //get the interpolated membrane potential
 inline double get_interpolated_membrane_potential_BaseCellMembranePotential(const Vector<double>& s) const
 {
  const unsigned n_node = this->nnode();
  Shape psi(n_node);
  shape(s, psi);
  double val = 0.0;
  for(unsigned l=0; l<n_node; l++){
    val += get_nodal_membrane_potential_BaseCellMembranePotential(l)*psi[l];
  }
  return val;
 }

 /// \short du/dt at local node n. 
 /// Uses suitably interpolated value for hanging nodes.
 double dvm_dt_BaseCellMembranePotential(const unsigned &n) const
  {
   // Get the data's timestepper
   TimeStepper* time_stepper_pt= this->node_pt(n)->time_stepper_pt();

   //Initialise dudt
   double dvmdt=0.0;
   //Loop over the timesteps, if there is a non Steady timestepper
   if (!time_stepper_pt->is_steady())
    {
     //Find the index at which the variable is stored
     const unsigned vm_nodal_index = vm_index_BaseCellMembranePotential();

     // Number of timsteps (past & present)
     const unsigned n_time = time_stepper_pt->ntstorage();
     
     for(unsigned t=0;t<n_time;t++)
      {
       dvmdt += time_stepper_pt->weight(1,t)*nodal_value(t,n,vm_nodal_index);
      }
    }
   return dvmdt;
  }

  /// \short d2u/dt2 at local node n. 
 /// Uses suitably interpolated value for hanging nodes.
 double d2vm_dt2_BaseCellMembranePotential(const unsigned &n) const
  {
   // Get the data's timestepper
   TimeStepper* time_stepper_pt= this->node_pt(n)->time_stepper_pt();

   //Initialise dudt
   double d2vmdt2=0.0;
   //Loop over the timesteps, if there is a non Steady timestepper
   if (!time_stepper_pt->is_steady())
    {
     //Find the index at which the variable is stored
     const unsigned vm_nodal_index = vm_index_BaseCellMembranePotential();

     // Number of timsteps (past & present)
     const unsigned n_time = time_stepper_pt->ntstorage();
     
     for(unsigned t=0;t<n_time;t++)
      {
       d2vmdt2 += time_stepper_pt->weight(2,t)*nodal_value(t,n,vm_nodal_index);
      }
    }
   return d2vmdt2;
  }



  virtual void assign_additional_initial_conditions()
  {
    throw OomphLibError(
    "Assign initial conditions has not been implemented yet",
    OOMPH_CURRENT_FUNCTION,
    OOMPH_EXCEPTION_LOCATION);
  }
  

 /// \short Disable ALE, i.e. assert the mesh is not moving -- you do this
 /// at your own risk!
 void disable_ALE()
  {
   ALE_is_disabled=true;
  }


 /// \short (Re-)enable ALE, i.e. take possible mesh motion into account
 /// when evaluating the time-derivative. Note: By default, ALE is 
 /// enabled, at the expense of possibly creating unnecessary work 
 /// in problems where the mesh is, in fact, stationary. 
 void enable_ALE()
  {
   ALE_is_disabled=false;
  }


 /// Output with default number of plot points
 void output(std::ostream &outfile) 
  {
   unsigned nplot=5;
   output(outfile,nplot);
  }

 /// \short Output FE representation of soln: x,y,u or x,y,z,u at 
 /// nplot^DIM plot points
 void output(std::ostream &outfile, const unsigned &nplot)
 {
  //Vector of local coordinates
  Vector<double> s(DIM);

  // Tecplot header info
  outfile << tecplot_zone_string(nplot);

  const unsigned n_node = this->nnode();
  const unsigned vm_index = vm_index_BaseCellMembranePotential();
  Shape psi(n_node);
  DShape dpsidx(n_node,DIM);

  // Loop over plot points
  unsigned num_plot_points=nplot_points(nplot);
  for (unsigned iplot=0;iplot<num_plot_points;iplot++)
  {
    // Get local coordinates of plot point
    get_s_plot(iplot,nplot,s);

    // Get Eulerian coordinate of plot point
    Vector<double> x(DIM);
    interpolated_x(s,x);

    for(unsigned i=0;i<DIM;i++) {outfile << x[i] << " ";}
    outfile << interpolated_vm_BaseCellMembranePotential(s) << " ";

    //Get the gradients
    (void)this->dshape_eulerian(s,psi,dpsidx);
    Vector<double> interpolated_dvmdx(DIM,0.0);
    double dvmdt = 0.0;
    for(unsigned n=0;n<n_node;n++){
      const double vm_ = this->nodal_value(n,vm_index);
      dvmdt += dvm_dt_BaseCellMembranePotential(n)*psi(n);
      for(unsigned i=0;i<DIM;i++){interpolated_dvmdx[i] += vm_*dpsidx(n,i);}
    }

    outfile << dvmdt << " ";

    for(unsigned i=0;i<DIM;i++){outfile << interpolated_dvmdx[i]  << " ";}

    outfile  << std::endl;
  }
  // Write tecplot footer (e.g. FE connectivity lists)
  write_tecplot_zone_footer(outfile,nplot);
}


 /// C_style output with default number of plot points
 void output(FILE* file_pt)
  {
   unsigned n_plot=5;
   output(file_pt,n_plot);
  }

 /// \short C-style output FE representation of soln: x,y,u or x,y,z,u at 
 /// n_plot^DIM plot points
 void output(FILE* file_pt, const unsigned &n_plot)
 {
 //Vector of local coordinates
 Vector<double> s(DIM);
 
 // Tecplot header info
 fprintf(file_pt,"%s",tecplot_zone_string(n_plot).c_str());

 // Loop over plot points
 unsigned num_plot_points=nplot_points(n_plot);
 for (unsigned iplot=0;iplot<num_plot_points;iplot++)
  {
   
   // Get local coordinates of plot point
   get_s_plot(iplot,n_plot,s);
   
   for(unsigned i=0;i<DIM;i++) 
    {
     fprintf(file_pt,"%g ",interpolated_x(s,i));

    }
   fprintf(file_pt,"%g \n",interpolated_vm_BaseCellMembranePotential(s));
  }

 // Write tecplot footer (e.g. FE connectivity lists)
 write_tecplot_zone_footer(file_pt,n_plot);

}


 /// Output exact soln: x,y,u_exact or x,y,z,u_exact at nplot^DIM plot points
 void output_fct(std::ostream &outfile, const unsigned &nplot, 
                 FiniteElement::SteadyExactSolutionFctPt 
                 exact_soln_pt)
 {

   //Vector of local coordinates
   Vector<double> s(DIM);

   // Vector for coordintes
   Vector<double> x(DIM);

   // Tecplot header info
   outfile << tecplot_zone_string(nplot);
   
   // Exact solution Vector (here a scalar)
   Vector<double> exact_soln(1);

   // Loop over plot points
   unsigned num_plot_points=nplot_points(nplot);
   for (unsigned iplot=0;iplot<num_plot_points;iplot++)
    {
     
     // Get local coordinates of plot point
     get_s_plot(iplot,nplot,s);

     // Get x position as Vector
     interpolated_x(s,x);

     // Get exact solution at this point
     (*exact_soln_pt)(x,exact_soln);

     //Output x,y,...,u_exact
     for(unsigned i=0;i<DIM;i++)
      {
       outfile << x[i] << " ";
      }
     outfile << exact_soln[0] << std::endl;  
    }

   // Write tecplot footer (e.g. FE connectivity lists)
   write_tecplot_zone_footer(outfile,nplot);
   
  }

 /// \short Output exact soln: x,y,u_exact or x,y,z,u_exact at 
 /// nplot^DIM plot points (dummy time-dependent version to 
 /// keep intel compiler happy)
 virtual void output_fct(std::ostream &outfile, const unsigned &nplot,
                         const double& time, 
  FiniteElement::UnsteadyExactSolutionFctPt exact_soln_pt)
  {
   throw OomphLibError(
    "There is no time-dependent output_fct() for Advection Diffusion elements",
    OOMPH_CURRENT_FUNCTION,
    OOMPH_EXCEPTION_LOCATION);
  }


 /// Get error against and norm of exact solution
 void compute_error(std::ostream &outfile, 
                    FiniteElement::SteadyExactSolutionFctPt 
                    exact_soln_pt, double& error, double& norm)
 { 

 // Initialise
 error=0.0;
 norm=0.0;

 //Vector of local coordinates
 Vector<double> s(DIM);

 // Vector for coordintes
 Vector<double> x(DIM);

 //Find out how many nodes there are in the element
 unsigned n_node = nnode();

 Shape psi(n_node);

 //Set the value of n_intpt
 unsigned n_intpt = integral_pt()->nweight();
   
 // Tecplot header info
 outfile << "ZONE" << std::endl;
   
 // Exact solution Vector (here a scalar)
 Vector<double> exact_soln(1);

 //Loop over the integration points
 for(unsigned ipt=0;ipt<n_intpt;ipt++)
  {

   //Assign values of s
   for(unsigned i=0;i<DIM;i++)
    {
     s[i] = integral_pt()->knot(ipt,i);
    }

   //Get the integral weight
   double w = integral_pt()->weight(ipt);

   // Get jacobian of mapping
   double J=J_eulerian(s);

   //Premultiply the weights and the Jacobian
   double W = w*J;

   // Get x position as Vector
   interpolated_x(s,x);

   // Get FE function value
   double vm_fe=interpolated_vm_BaseCellMembranePotential(s);

   // Get exact solution at this point
   (*exact_soln_pt)(x,exact_soln);

   //Output x,y,...,error
   for(unsigned i=0;i<DIM;i++)
    {
     outfile << x[i] << " ";
    }
   outfile << exact_soln[0] << " " << exact_soln[0]-vm_fe << std::endl;  

   // Add to error and norm
   norm+=exact_soln[0]*exact_soln[0]*W;
   error+=(exact_soln[0]-vm_fe)*(exact_soln[0]-vm_fe)*W;

  }

}


 /// Dummy, time dependent error checker
 void compute_error(std::ostream &outfile, 
                    FiniteElement::UnsteadyExactSolutionFctPt 
                    exact_soln_pt,
                    const double& time, double& error, double& norm)
  {
   throw OomphLibError(
    "No time-dependent compute_error() for Advection Diffusion elements",
    OOMPH_CURRENT_FUNCTION,
    OOMPH_EXCEPTION_LOCATION);
  }

 /// \short Integrate the concentration over the element
 double integrate_vm()
 { 
 // Initialise
 double sum = 0.0;

 //Vector of local coordinates
 Vector<double> s(DIM);

 //Find out how many nodes there are in the element
 const unsigned n_node = nnode();

 //Find the index at which the concentration is stored
 const unsigned vm_nodal_index = this->vm_index_BaseCellMembranePotential();

 //Allocate memory for the shape functions
 Shape psi(n_node);

 //Set the value of n_intpt
 const unsigned n_intpt = integral_pt()->nweight();

 //Loop over the integration points
 for(unsigned ipt=0;ipt<n_intpt;ipt++)
  {
   //Get the integral weight
   const double w = integral_pt()->weight(ipt);
   
   //Get the shape functions
   this->shape_at_knot(ipt,psi);

   //Calculate the concentration
   double interpolated_vm = 0.0;
   for(unsigned l=0;l<n_node;l++) 
    {interpolated_vm += this->nodal_value(l,vm_nodal_index)*psi(l);}

   // Get jacobian of mapping
   const double J=J_eulerian_at_knot(ipt);

   //Add the values to the sum
   sum += interpolated_vm*w*J;
  }

 //return the sum
 return sum;
}

 double integrate_vm() const
 {
  // Initialise
  double sum = 0.0;

  //Vector of local coordinates
  Vector<double> s(DIM);

  //Find out how many nodes there are in the element
  const unsigned n_node = nnode();

  //Find the index at which the concentration is stored
  const unsigned vm_nodal_index = this->vm_index_BaseCellMembranePotential();

  //Allocate memory for the shape functions
  Shape psi(n_node);

  //Set the value of n_intpt
  const unsigned n_intpt = integral_pt()->nweight();

  //Loop over the integration points
  for(unsigned ipt=0;ipt<n_intpt;ipt++)
  {
    //Get the integral weight
    const double w = integral_pt()->weight(ipt);

    //Get the shape functions
    this->shape_at_knot(ipt,psi);

    //Calculate the concentration
    double interpolated_vm = 0.0;
    for(unsigned l=0;l<n_node;l++) {
      interpolated_vm += this->nodal_value(l,vm_nodal_index)*psi(l);
    }

    // Get jacobian of mapping
    const double J=J_eulerian_at_knot(ipt);

    //Add the values to the sum
    sum += interpolated_vm*w*J;
  }

 //return the sum
 return sum;
}


 /// Access function: Pointer to source function
 BaseCellMembranePotentialSourceFctPt& source_fct_pt() 
  {return Source_fct_pt;}
 
 /// Access function: Pointer to source function. Const version
 BaseCellMembranePotentialSourceFctPt source_fct_pt() const 
  {return Source_fct_pt;}


  BaseCellMembranePotentialPredictedVmFctPt& predicted_vm_pt()
  {return Predicted_vm_pt;}
  BaseCellMembranePotentialPredictedVmFctPt predicted_vm_pt() const
  {return Predicted_vm_pt;}


 /// membrane capacitance
 const double &cm() const {return *Cm_pt;}

 /// Pointer to membrane capacitance
 double* &cm_pt() {return Cm_pt;}

 /// \short Get source term at (Eulerian) position x. This function is
 /// virtual to allow overloading in multi-physics problems where
 /// the strength of the source function might be determined by
 /// another system of equations 
 inline virtual void get_source_BaseCellMembranePotential(const unsigned& ipt,
                                                          const Vector<double>& s,
                                                          const Vector<double>& x,
                                                          double& source) const
  {
   //If no source function has been set, return zero
   if(Source_fct_pt==0) {source = 0.0;}
   else
    {
     // Get source strength
     (*Source_fct_pt)(x,source);
    }
  }

  //Get the predicted vm at node l - used by strang splitting elements to get the value of vm
  // achieved through a segregated, decoupled cell solve step
  inline virtual double get_nodal_predicted_vm_BaseCellMembranePotential(const unsigned &l) const
  {
   //If no source function has been set, return zero
   if(Predicted_vm_pt==0) {return 0.0;}
   else
    {
     // Get source strength
     return (*Predicted_vm_pt)(l);
    }
  }


 /// Get flux: \f$\mbox{flux}[i] = \mbox{d}u / \mbox{d}x_i \f$
 void get_flux(const Vector<double>& s, Vector<double>& flux) const
  {
   //Find out how many nodes there are in the element
   unsigned n_node = nnode();
   
   //Get the nodal index at which the unknown is stored
   unsigned vm_nodal_index = vm_index_BaseCellMembranePotential();

   //Set up memory for the shape and test functions
   Shape psi(n_node);
   DShape dpsidx(n_node,DIM);
 
   //Call the derivatives of the shape and test functions
   dshape_eulerian(s,psi,dpsidx);
     
   //Initialise to zero
   for(unsigned j=0;j<DIM;j++) {flux[j] = 0.0;}
   
   // Loop over nodes
   for(unsigned l=0;l<n_node;l++) 
    {
     //Loop over derivative directions
     for(unsigned j=0;j<DIM;j++)
      {                               
       flux[j] += nodal_value(l,vm_nodal_index)*dpsidx(l,j);
      }
    }
  }

 
 /// Add the element's contribution to its residual vector (wrapper)
 void fill_in_contribution_to_residuals(Vector<double> &residuals)
  {
   //Call the generic residuals function with flag set to 0 and using
   //a dummy matrix
   fill_in_generic_residual_contribution_BaseCellMembranePotential(
    residuals,GeneralisedElement::Dummy_matrix,
    GeneralisedElement::Dummy_matrix,0);
  }

 
 /// \short Add the element's contribution to its residual vector and 
 /// the element Jacobian matrix (wrapper)
 void fill_in_contribution_to_jacobian(Vector<double> &residuals,
                                   DenseMatrix<double> &jacobian)
  {
   //Call the generic routine with the flag set to 1
   fill_in_generic_residual_contribution_BaseCellMembranePotential(
    residuals,jacobian,GeneralisedElement::Dummy_matrix,1);
  }
 

 /// Add the element's contribution to its residuals vector,
 /// jacobian matrix and mass matrix
 void fill_in_contribution_to_jacobian_and_mass_matrix(
  Vector<double> &residuals, DenseMatrix<double> &jacobian, 
  DenseMatrix<double> &mass_matrix)
  {
   //Call the generic routine with the flag set to 2
   fill_in_generic_residual_contribution_BaseCellMembranePotential(residuals,
                                                  jacobian,mass_matrix,2);
  }


 /// Return FE representation of function value u(s) at local coordinate s
 inline double interpolated_vm_BaseCellMembranePotential(const Vector<double> &s) const
  {
   //Find number of nodes
   unsigned n_node = nnode();

   //Get the nodal index at which the unknown is stored
   unsigned vm_nodal_index = vm_index_BaseCellMembranePotential();

   //Local shape function
   Shape psi(n_node);

   //Find values of shape function
   shape(s,psi);

   //Initialise value of u
   double interpolated_vm = 0.0;

   //Loop over the local nodes and sum
   for(unsigned l=0;l<n_node;l++) 
    {
     interpolated_vm += nodal_value(l,vm_nodal_index)*psi[l];
    }

   return interpolated_vm;
  }

  /// Return FE representation of function value u(s) at local coordinate s
 inline double interpolated_dvm_dt_BaseCellMembranePotential(const Vector<double> &s) const
  {
   //Find number of nodes
   unsigned n_node = nnode();

   //Get the nodal index at which the unknown is stored
   // unsigned vm_nodal_index = vm_index_BaseCellMembranePotential();

   //Local shape function
   Shape psi(n_node);

   //Find values of shape function
   shape(s,psi);

   //Initialise value of u
   double interpolated_vm = 0.0;

   //Loop over the local nodes and sum
   for(unsigned l=0;l<n_node;l++) 
    {
     interpolated_vm += dvm_dt_BaseCellMembranePotential(l)*psi[l];
    }

   return interpolated_vm;
  }


 /// \short Self-test: Return 0 for OK
 unsigned self_test()
 {

 bool passed=true;

 // Check lower-level stuff
 if (FiniteElement::self_test()!=0)
  {
   passed=false;
  }

 // Return verdict
 if (passed)
  {
   return 0;
  }
 else
  {
   return 1;
  }
   
}

protected:


 /// \short Shape/test functions and derivs w.r.t. to global coords at 
 /// local coord. s; return  Jacobian of mapping
 virtual double dshape_and_dtest_eulerian_BaseCellMembranePotential(const Vector<double> &s, 
                                                   Shape &psi, 
                                                   DShape &dpsidx, 
                                                   Shape &test, 
                                                   DShape &dtestdx) const=0;

 /// \short Shape/test functions and derivs w.r.t. to global coords at 
 /// integration point ipt; return  Jacobian of mapping
 virtual double dshape_and_dtest_eulerian_at_knot_BaseCellMembranePotential(
  const unsigned &ipt, 
  Shape &psi, 
  DShape &dpsidx,
  Shape &test, 
  DShape &dtestdx) 
  const=0;

 /// \short Add the element's contribution to its residual vector only 
 /// (if flag=and/or element  Jacobian matrix 
 virtual void fill_in_generic_residual_contribution_BaseCellMembranePotential(
  Vector<double> &residuals, DenseMatrix<double> &jacobian, 
  DenseMatrix<double> &mass_matrix, unsigned flag)
 {
  throw OomphLibError(
    "BaseCellMembranePotential has no fill in residual function",
    OOMPH_CURRENT_FUNCTION,
    OOMPH_EXCEPTION_LOCATION);
 }
  
 /// Pointer to global capacitance
 double *Cm_pt;

 /// Pointer to source function:
  BaseCellMembranePotentialSourceFctPt Source_fct_pt;
  
 BaseCellMembranePotentialPredictedVmFctPt Predicted_vm_pt;
 /// \short Boolean flag to indicate if ALE formulation is disabled when 
 /// time-derivatives are computed. Only set to false if you're sure
 /// that the mesh is stationary.
 bool ALE_is_disabled;

  private:

 // /// Static default value for the membrane capacitance
 // static double Default_membrane_capacitance;
 
  
};

}

#endif
