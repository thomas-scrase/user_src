//LIC// ====================================================================
//LIC// This file contains the base equations for all Cell membrane potential
//LIC// equations and elements.
//LIC//  Contains all members common to both monodomain and bidomain equations
//LIC//====================================================================


//Header file for cell membrane potential elements
#ifndef OOMPH_CELL_MEMBRANE_POTENTIAL
#define OOMPH_CELL_MEMBRANE_POTENTIAL


// Config header generated by autoconfig
#ifdef HAVE_CONFIG_H
  #include <oomph-lib-config.h>
#endif

//OOMPH-LIB headers
#include "../generic/nodes.h"
#include "../generic/oomph_utilities.h"
#include "../generic/Qelements.h"
#include "../generic/Telements.h"
#include "../generic/error_estimator.h"
#include "../generic/oomph_utilities.h"

namespace oomph
{

//=============================================================
/// \short A class for all elements that solve the Monodomain
/// equations in conservative form using isoparametric elements.
/// \f[ 
/// \frac{\partial}{\partial x_{i}}\left(
/// Pe w_{i}(x_{k}) u - D_{ij}(x_{k})\frac{\partial u}{\partial x_{j}}\right)
/// = f(x_{j})
/// \f] 
/// This contains the generic maths. Shape functions, geometric
/// mapping etc. must get implemented in derived class.
//=============================================================
template <unsigned DIM>
class BaseCellMembranePotentialEquations : public virtual FiniteElement
{
public:

 /// \short Function pointer to source function fct(x,f(x)) -- 
 /// x is a Vector! 
 typedef void (*BaseCellMembranePotentialSourceFctPt)
  (const Vector<double>& x, double& f);

  // \short function pointer to boundary source function fct(bounds, f(bounds)) --
  // bounds_of_node is a vector of the bounds the node exists on
  typedef void (*BaseCellMembranePotentialBoundarySourceFctPt)
  (std::set<unsigned>* &boundaries_pt, double& bound_source);
  

 /// \short Constructor: Initialise the Source_fct_pt and Wind_fct_pt 
 /// to null and set (pointer to) Peclet number to default
 BaseCellMembranePotentialEquations() : Source_fct_pt(0),
                                        Boundary_source_fct_pt(0),
                                        ALE_is_disabled(false)
  {
   //Set membrane capacitance to default
   Cm_pt = &Default_membrane_capacitance;
  }
 
 /// Broken copy constructor
 BaseCellMembranePotentialEquations(
  const BaseCellMembranePotentialEquations<DIM>& dummy) 
  { 
   BrokenCopy::broken_copy("BaseCellMembranePotentialEquations");
  } 
 
 /// Broken assignment operator
 void operator=(const BaseCellMembranePotentialEquations&) 
  {
   BrokenCopy::broken_assign("BaseCellMembranePotentialEquations");
  }

 /// \short All cell_membrane_potential elements will have a storage value
 ///        dedicated to membrane potential
 virtual inline unsigned vm_index_BaseCellMembranePotential() const {return 0;}

/// \short du/dt at local node n. 
 /// Uses suitably interpolated value for hanging nodes.
 double dvm_dt_BaseCellMembranePotential(const unsigned &n) const
  {
   // Get the data's timestepper
   TimeStepper* time_stepper_pt= this->node_pt(n)->time_stepper_pt();

   //Initialise dudt
   double dvmdt=0.0;
   //Loop over the timesteps, if there is a non Steady timestepper
   if (!time_stepper_pt->is_steady())
    {
     //Find the index at which the variable is stored
     const unsigned vm_nodal_index = vm_index_BaseCellMembranePotential();

     // Number of timsteps (past & present)
     const unsigned n_time = time_stepper_pt->ntstorage();
     
     for(unsigned t=0;t<n_time;t++)
      {
       dvmdt += time_stepper_pt->weight(1,t)*nodal_value(t,n,vm_nodal_index);
      }
    }
   return dvmdt;
  }


 /// \short Disable ALE, i.e. assert the mesh is not moving -- you do this
 /// at your own risk!
 void disable_ALE()
  {
   ALE_is_disabled=true;
  }


 /// \short (Re-)enable ALE, i.e. take possible mesh motion into account
 /// when evaluating the time-derivative. Note: By default, ALE is 
 /// enabled, at the expense of possibly creating unnecessary work 
 /// in problems where the mesh is, in fact, stationary. 
 void enable_ALE()
  {
   ALE_is_disabled=false;
  }


 /// Output with default number of plot points
 void output(std::ostream &outfile) 
  {
   unsigned nplot=5;
   output(outfile,nplot);
  }

 /// \short Output FE representation of soln: x,y,u or x,y,z,u at 
 /// nplot^DIM plot points
 void output(std::ostream &outfile, const unsigned &nplot);


 /// C_style output with default number of plot points
 void output(FILE* file_pt)
  {
   unsigned n_plot=5;
   output(file_pt,n_plot);
  }

 /// \short C-style output FE representation of soln: x,y,u or x,y,z,u at 
 /// n_plot^DIM plot points
 void output(FILE* file_pt, const unsigned &n_plot);


 /// Output exact soln: x,y,u_exact or x,y,z,u_exact at nplot^DIM plot points
 void output_fct(std::ostream &outfile, const unsigned &nplot, 
                 FiniteElement::SteadyExactSolutionFctPt 
                 exact_soln_pt);

 /// \short Output exact soln: x,y,u_exact or x,y,z,u_exact at 
 /// nplot^DIM plot points (dummy time-dependent version to 
 /// keep intel compiler happy)
 virtual void output_fct(std::ostream &outfile, const unsigned &nplot,
                         const double& time, 
  FiniteElement::UnsteadyExactSolutionFctPt exact_soln_pt)
  {
   throw OomphLibError(
    "There is no time-dependent output_fct() for Advection Diffusion elements",
    OOMPH_CURRENT_FUNCTION,
    OOMPH_EXCEPTION_LOCATION);
  }


 /// Get error against and norm of exact solution
 void compute_error(std::ostream &outfile, 
                    FiniteElement::SteadyExactSolutionFctPt 
                    exact_soln_pt, double& error, double& norm);


 /// Dummy, time dependent error checker
 void compute_error(std::ostream &outfile, 
                    FiniteElement::UnsteadyExactSolutionFctPt 
                    exact_soln_pt,
                    const double& time, double& error, double& norm)
  {
   throw OomphLibError(
    "No time-dependent compute_error() for Advection Diffusion elements",
    OOMPH_CURRENT_FUNCTION,
    OOMPH_EXCEPTION_LOCATION);
  }

 /// \short Integrate the concentration over the element
 double integrate_vm();
 double integrate_vm() const;


 /// Access function: Pointer to source function
 BaseCellMembranePotentialSourceFctPt& source_fct_pt() 
  {return Source_fct_pt;}
 
 /// Access function: Pointer to source function. Const version
 BaseCellMembranePotentialSourceFctPt source_fct_pt() const 
  {return Source_fct_pt;}



  /// Access function: Pointer to boundary source function
  BaseCellMembranePotentialBoundarySourceFctPt& boundary_source_fct_pt() 
    {return Boundary_source_fct_pt;}

  /// Access function: Pointer to boundary source function
  BaseCellMembranePotentialBoundarySourceFctPt boundary_source_fct_pt() const
    {return Boundary_source_fct_pt;}


 /// membrane capacitance
 const double &cm() const {return *Cm_pt;}

 /// Pointer to membrane capacitance
 double* &cm_pt() {return Cm_pt;}

 /// \short Get source term at (Eulerian) position x. This function is
 /// virtual to allow overloading in multi-physics problems where
 /// the strength of the source function might be determined by
 /// another system of equations 
 inline virtual void get_source_BaseCellMembranePotential(const unsigned& ipt,
                                                          const Vector<double>& x,
                                                          double& source) const
  {
   //If no source function has been set, return zero
   if(Source_fct_pt==0) {source = 0.0;}
   else
    {
     // Get source strength
     (*Source_fct_pt)(x,source);
    }
  }


 /// Get flux: \f$\mbox{flux}[i] = \mbox{d}u / \mbox{d}x_i \f$
 void get_flux(const Vector<double>& s, Vector<double>& flux) const
  {
   //Find out how many nodes there are in the element
   unsigned n_node = nnode();
   
   //Get the nodal index at which the unknown is stored
   unsigned vm_nodal_index = vm_index_BaseCellMembranePotential();

   //Set up memory for the shape and test functions
   Shape psi(n_node);
   DShape dpsidx(n_node,DIM);
 
   //Call the derivatives of the shape and test functions
   dshape_eulerian(s,psi,dpsidx);
     
   //Initialise to zero
   for(unsigned j=0;j<DIM;j++) {flux[j] = 0.0;}
   
   // Loop over nodes
   for(unsigned l=0;l<n_node;l++) 
    {
     //Loop over derivative directions
     for(unsigned j=0;j<DIM;j++)
      {                               
       flux[j] += nodal_value(l,vm_nodal_index)*dpsidx(l,j);
      }
    }
  }

 
 /// Add the element's contribution to its residual vector (wrapper)
 void fill_in_contribution_to_residuals(Vector<double> &residuals)
  {
   //Call the generic residuals function with flag set to 0 and using
   //a dummy matrix
   fill_in_generic_residual_contribution_BaseCellMembranePotential(
    residuals,GeneralisedElement::Dummy_matrix,
    GeneralisedElement::Dummy_matrix,0);
  }

 
 /// \short Add the element's contribution to its residual vector and 
 /// the element Jacobian matrix (wrapper)
 void fill_in_contribution_to_jacobian(Vector<double> &residuals,
                                   DenseMatrix<double> &jacobian)
  {
   //Call the generic routine with the flag set to 1
   fill_in_generic_residual_contribution_BaseCellMembranePotential(
    residuals,jacobian,GeneralisedElement::Dummy_matrix,1);
  }
 

 /// Add the element's contribution to its residuals vector,
 /// jacobian matrix and mass matrix
 void fill_in_contribution_to_jacobian_and_mass_matrix(
  Vector<double> &residuals, DenseMatrix<double> &jacobian, 
  DenseMatrix<double> &mass_matrix)
  {
   //Call the generic routine with the flag set to 2
   fill_in_generic_residual_contribution_BaseCellMembranePotential(residuals,
                                                  jacobian,mass_matrix,2);
  }


 /// Return FE representation of function value u(s) at local coordinate s
 inline double interpolated_vm_BaseCellMembranePotential(const Vector<double> &s) const
  {
   //Find number of nodes
   unsigned n_node = nnode();

   //Get the nodal index at which the unknown is stored
   unsigned vm_nodal_index = vm_index_BaseCellMembranePotential();

   //Local shape function
   Shape psi(n_node);

   //Find values of shape function
   shape(s,psi);

   //Initialise value of u
   double interpolated_vm = 0.0;

   //Loop over the local nodes and sum
   for(unsigned l=0;l<n_node;l++) 
    {
     interpolated_vm += nodal_value(l,vm_nodal_index)*psi[l];
    }

   return interpolated_vm;
  }


 /// \short Self-test: Return 0 for OK
 unsigned self_test();

protected:


 /// \short Shape/test functions and derivs w.r.t. to global coords at 
 /// local coord. s; return  Jacobian of mapping
 virtual double dshape_and_dtest_eulerian_BaseCellMembranePotential(const Vector<double> &s, 
                                                   Shape &psi, 
                                                   DShape &dpsidx, 
                                                   Shape &test, 
                                                   DShape &dtestdx) const=0;

 /// \short Shape/test functions and derivs w.r.t. to global coords at 
 /// integration point ipt; return  Jacobian of mapping
 virtual double dshape_and_dtest_eulerian_at_knot_BaseCellMembranePotential(
  const unsigned &ipt, 
  Shape &psi, 
  DShape &dpsidx,
  Shape &test, 
  DShape &dtestdx) 
  const=0;

 /// \short Add the element's contribution to its residual vector only 
 /// (if flag=and/or element  Jacobian matrix 
 virtual void fill_in_generic_residual_contribution_BaseCellMembranePotential(
  Vector<double> &residuals, DenseMatrix<double> &jacobian, 
  DenseMatrix<double> &mass_matrix, unsigned flag)
 {
  throw OomphLibError(
    "BaseCellMembranePotential has no fill in residual function",
    OOMPH_CURRENT_FUNCTION,
    OOMPH_EXCEPTION_LOCATION);
 }
  
 /// Pointer to global capacitance
 double *Cm_pt;

 /// Pointer to source function:
 BaseCellMembranePotentialSourceFctPt Source_fct_pt;
 /// Pointer to boundary source function
 BaseCellMembranePotentialBoundarySourceFctPt Boundary_source_fct_pt;

 /// \short Boolean flag to indicate if ALE formulation is disabled when 
 /// time-derivatives are computed. Only set to false if you're sure
 /// that the mesh is stationary.
 bool ALE_is_disabled;

  private:

 /// Static default value for the membrane capacitance
 static double Default_membrane_capacitance;
 
  
};

}

#endif
