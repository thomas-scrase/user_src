//Header file for refineable Monodomain elements
#ifndef OOMPH_REFINEABLE_MONODOMAIN
#define OOMPH_REFINEABLE_MONODOMAIN

// Config header generated by autoconfig
#ifdef HAVE_CONFIG_H
  #include <oomph-lib-config.h>
#endif

//oomph-lib headers
#include "../generic/refineable_quad_element.h"
#include "../generic/refineable_brick_element.h"
#include "../generic/error_estimator.h"

#include "monodomain_elements.h"

namespace oomph
{
	template <unsigned DIM>
	class RefineableMonodomainEquations :	public virtual MonodomainEquations<DIM>,
											public virtual RefineableElement,
											public virtual ElementWithZ2ErrorEstimator
	{
	public:

		//empty constructor
		RefineableMonodomainEquations()	:	MonodomainEquations<DIM>(),
											RefineableElement(),
											ElementWithZ2ErrorEstimator()
		{	}

		/// Broken copy constructor
		RefineableMonodomainEquations(
			const RefineableMonodomainEquations<DIM>& dummy) 
		{ 
			BrokenCopy::broken_copy("RefineableMonodomainEquations");
		}

		/// Broken assignment operator
		void operator=(const RefineableMonodomainEquations<DIM>&) 
		{
			BrokenCopy::broken_assign(
			"RefineableMonodomainEquations");
		}

		/// Number of 'flux' terms for Z2 error estimation 
 		unsigned num_Z2_flux_terms() {return DIM;}

 		/// \short Get 'flux' for Z2 error recovery:  
		/// Standard flux.from GeneralisedAdvectionDiffusion equations
		void get_Z2_flux(const Vector<double>& s, Vector<double>& flux)
		{this->get_flux(s,flux);}

		/// \short Get the function value u in Vector.
		/// Note: Given the generality of the interface (this function
		/// is usually called from black-box documentation or interpolation routines),
		/// the values Vector sets its own size in here.
		void get_interpolated_values(const Vector<double>&s,  Vector<double>& values)
		{
			// Set size of Vector: u
			values.resize(1);

			//Find number of nodes
			const unsigned n_node = this->nnode();

			//Find the index at which the unknown is stored
			const unsigned vm_nodal_index = this->vm_index_BaseCellMembranePotential();

			//Local shape function
			Shape psi(n_node);

			//Find values of shape function
			this->shape(s,psi);

			//Initialise value of u
			values[0] = 0.0;

			//Loop over the local nodes and sum
			for(unsigned l=0;l<n_node;l++){
				values[0] += this->nodal_value(l,vm_nodal_index)*psi[l];
			}
		}

		/// \short Get the function value u in Vector.
		/// Note: Given the generality of the interface (this function
		/// is usually called from black-box documentation or interpolation routines),
		/// the values Vector sets its own size in here.
		void get_interpolated_values(const unsigned& t, const Vector<double>&s, Vector<double>& values)
		{
			// Set size of Vector:
			values.resize(1);

			//Find out how many nodes there are
			const unsigned n_node = this->nnode();

			//Find the nodal index at which the unknown is stored
			const unsigned vm_nodal_index = this->vm_index_BaseCellMembranePotential();

			// Shape functions
			Shape psi(n_node);

			//Find values of shape function
			this->shape(s,psi);

			//Initialise the value of u
			values[0] = 0.0;

			//Calculate value
			for(unsigned l=0;l<n_node;l++) 
			{
				values[0] += this->nodal_value(t,l,vm_nodal_index)*psi[l]; 
			}
		}

		///  Further build: Copy source function pointer from father element
		void further_build()
		{
			RefineableMonodomainEquations<DIM>* cast_father_element_pt 
				= dynamic_cast<RefineableMonodomainEquations<DIM>*>(this->father_element_pt());

			//Set the values of the pointers from the father
			this->Source_fct_pt = cast_father_element_pt->source_fct_pt();
			this->Diff_fct_pt = cast_father_element_pt->diff_fct_pt();
			this->Cm_pt = cast_father_element_pt->cm_pt();

			//Set the ALE status
			this->ALE_is_disabled = cast_father_element_pt->ALE_is_disabled;
		}
 
 	protected:
 
		/// \short Add the element's contribution to the elemental residual vector 
		/// and/or Jacobian matrix 
		/// flag=1: compute both
		/// flag=0: compute only residual vector
		void fill_in_generic_residual_contribution_BaseCellMembranePotential(	Vector<double> &residuals,
																DenseMatrix<double> &jacobian, 
																DenseMatrix<double> &mass_matrix,
																unsigned flag); 
	};

	template<unsigned DIM, unsigned NNODE_1D>
	class RefineableQMonodomainElement	:
	public	QMonodomainElement<DIM, NNODE_1D>,
	public virtual RefineableMonodomainEquations<DIM>,
	public virtual RefineableQElement<DIM>
	{
	public:
		RefineableQMonodomainElement()	:
			RefineableElement(),
			RefineableMonodomainEquations<DIM>(),
			RefineableQElement<DIM>(),
			QMonodomainElement<DIM, NNODE_1D>()
			{	}

		/// Broken copy constructor
		RefineableQMonodomainElement(
			const RefineableQMonodomainElement<DIM,NNODE_1D>& dummy){ 
			BrokenCopy::broken_copy(
			"RefineableQMonodomainElement");
		} 

		/// Broken assignment operator
		void operator=(const RefineableQMonodomainElement<DIM,NNODE_1D>&){
			BrokenCopy::broken_assign(
			"RefineableQMonodomainElement");
		}

		/// Number of continuously interpolated values: 1
		unsigned ncont_interpolated_values() const {return 1;}

		/// \short Number of vertex nodes in the element
		unsigned nvertex_node() const
		{return QMonodomainElement<DIM,NNODE_1D>::nvertex_node();}

		/// \short Pointer to the j-th vertex node in the element
		Node* vertex_node_pt(const unsigned& j) const
		{return QMonodomainElement<DIM,NNODE_1D>::vertex_node_pt(j);}

		/// Rebuild from sons: empty
		void rebuild_from_sons(Mesh* &mesh_pt) {}

		/// \short Order of recovery shape functions for Z2 error estimation:
		/// Same order as shape functions.
		unsigned nrecovery_order() {return (NNODE_1D-1);}

		///  \short Perform additional hanging node procedures for variables
		/// that are not interpolated by all nodes. Empty.
		void further_setup_hanging_nodes(){}
	};

	//=======================================================================
	/// Face geometry for the 
	/// RefineableQuadGeneralisedAdvectionDiffusionElement elements: The spatial 
	/// dimension of the face elements is one lower than that of the
	/// bulk element but they have the same number of points
	/// along their 1D edges.
	//=======================================================================
	template<unsigned DIM, unsigned NNODE_1D>
	class FaceGeometry<RefineableQMonodomainElement<DIM,NNODE_1D> >: 
	public virtual QElement<DIM-1,NNODE_1D>
	{

	public:

		/// \short Constructor: Call the constructor for the
		/// appropriate lower-dimensional QElement
		FaceGeometry() : QElement<DIM-1,NNODE_1D>() {}

	};

	//=======================================================================
	/// Face geometry for the 1D QGeneralisedAdvectionDiffusion elements: Point elements
	//=======================================================================
	template<unsigned NNODE_1D>
	class FaceGeometry<RefineableQMonodomainElement<1,NNODE_1D> >: 
	public virtual PointElement
	{

	public:

		/// \short Constructor: Call the constructor for the
		/// appropriate lower-dimensional QElement
		FaceGeometry() : PointElement() {}

	};

}

#endif