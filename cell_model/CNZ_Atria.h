//LIC// ====================================================================
//LIC// Contains the CNZ Atrial cell model
//LIC// ====================================================================


#ifndef OOMPH_CNZ_ATRIA_HEADER
#define OOMPH_CNZ_ATRIA_HEADER

// Config header generated by autoconfig
#ifdef HAVE_CONFIG_H
  #include <oomph-lib-config.h>
#endif

#include "cell_model_base.h"

namespace oomph{

	//====================================================================
	//====================================================================
	//Begin the CNZ Cell model as inherited from Haibo Ni
	//====================================================================
	//====================================================================

	class CNZCell : public CellModelBase
	{
	public:

		//Defined in .cc file
		CNZCell();

		virtual ~CNZCell()	{}

		virtual double active_strain(CellState &state)
		{	
			//!!!!!
			// SLrest is set to 1.9 by default, in future this
			// should be changed to a fct returning a suitable value
			// to reflect cell and mut type

			// SLrest = 1.9;
			
			return (state.var(0,34) - get_SLrest()) / get_SLrest();
		}

		//====================================================================
		//Total membrane current at node
		//====================================================================
		inline double membrane_current(CellState &state)
		{
			//Calculate reversal potentials
	        ENa_reversal(state);
	        ECa_reversal(state);
	        EK_reversal(state);
	        EKf_reversal(state);
        	Enaf_reversal(state);
	        
	        //Calculate channel currents
	        INa_current(state);
	        IKr_current(state);
	        IKs_current(state);
	        ICaL_current(state);
	        IK1_current(state);
	        Iab_current(state);
	        IbK_current(state);
	        IbCa_current(state);
	        IbNa_current(state);
	        ICap_current(state);
	        INaCa_current(state);
	        INaK_current(state);
	        Ito_current(state);
	        IKur_current(state);
	        If_current(state);
	        ICaT_current(state);
	        IGap_current(state);
	        ISAC_current(state);
	        //get fibrosis currents
	        IK1f_current(state);
    		IbNaf_current(state);

	        return (state.ina() + state.ikr() + state.iks() + state.ical() + state.ik1() + state.iab()
	        	 + state.ibk() + state.ibca() + state.ibna() + state.icap() + state.inaca() + state.inak()
	        	 + state.ito() + state.ikur() /*+ state.if()*/ + state.icat() + state.igap()
	        	 + state.isac_na() + state.isac_ca() + state.isac_k()
	        	 /*+ state.ik1f()*/ + state.ibnaf()) / Cm;
	        	 //add fibrosis currents

			// //Calculate contribution from each channel
			// total_membrane_current 	= 	(	INa_current(state)
			// 							+	IKr_current(state)
			// 							+	IKs_current(state)
			// 							+	ICaL_current(state)
			// 							+	IK1_current(state)
			// 							+	Iab_current(state)			//!!!!! NO NERNST POTENTIAL USED IN CNZCell CODE
			// 							+	IbK_current(state)
			// 							+	IbCa_current(state)
			// 						    +	IbNa_current(state)
			// 						    +	ICap_current(state)		//!!!!! NO NERNST POTENTIAL USED IN CNZCell CODE
			// 						    +	INaCa_current(state)		//!!!!! NO NERNST POTENTIAL USED IN CNZCell CODE
			// 						    +	INaK_current(state)		//!!!!! NO NERNST POTENTIAL USED IN CNZCell CODE
			// 						    +	Ito_current(state)
			// 						    +	IKur_current(state)
			// 						    +	If_current(state)			//!!!!! NO NERNST POTENTIAL USED IN CNZCell CODE
			// 						    +	ICaT_current(state)		//!!!!! NO NERNST POTENTIAL USED IN CNZCell CODE
			// 							+	IGap_current(state)		//!!!!! NOT IMPLEMENTED YET
			// 							// +	ISAC_Na_current(node, Ext_conc, local_ind, cell_type, mut_type, fibrosis, Vm, ISAC_)
			// 							// +	ISAC_K_current(node, Ext_conc, local_ind, cell_type, mut_type, fibrosis, Vm, ISAC_)
			// 							// +	ISAC_Ca_current(node, Ext_conc, local_ind, cell_type, mut_type, fibrosis, Vm, ISAC_)
			// 							+	ISAC_ISAC(node, Ext_conc, local_ind, cell_type, mut_type, fibrosis, Vm, strain)
			// 							) / Cm;

			//Not dividing by the membrane capacitance. I am moving dependence on Cm to the monodomain element
		}

		//Fill in the generic residual and jacobian contribution for the cell variables associated with the node passed
		//	Defined in .cc
		void fill_in_generic_residual_contribution_cell_base(CellState &state,
															Vector<double> &residuals,
															DenseMatrix<double> &jacobian,
															unsigned flag);

		//The membrane capacitance
		double cm() const {return Cm;}
	
	protected:
		//====================================================================
		// The channel currents
		//	Calculates the current through each channel from the gating variables
		//		associated with the node
		//	Implemented as virtual to allow overloading for testing new channel models
		//		with minimal effort
		//====================================================================
		inline void INa_current(CellState &state);
		inline void IKr_current(CellState &state);
		inline void IKs_current(CellState &state);
		inline void ICaL_current(CellState &state);
		inline void IK1_current(CellState &state);
		inline void Iab_current(CellState &state);
		inline void IbK_current(CellState &state);
		inline void IbCa_current(CellState &state);
    	inline void IbNa_current(CellState &state);
    	inline void ICap_current(CellState &state);
    	inline void INaCa_current(CellState &state);
    	inline void INaK_current(CellState &state);
    	inline void Ito_current(CellState &state);
    	inline void IKur_current(CellState &state);
    	inline void If_current(CellState &state);
    	inline void ICaT_current(CellState &state);
    	inline void IGap_current(CellState &state);
    	
    	inline void IK1f_current(CellState &state);
    	inline void IbNaf_current(CellState &state);
    	inline void IKv_current(CellState &state);

    	inline void ISAC_current(CellState &state);
    	//The refersal potentials
    	inline void ENa_reversal(CellState &state);
		inline void EK_reversal(CellState &state);
		inline void ECa_reversal(CellState &state);
		inline void EKf_reversal(CellState &state);
		inline void Enaf_reversal(CellState &state);

    	//The channel residual functions
    	inline void INa_current_residual(const CellState &state, Vector<double> &residuals);
		inline void IKr_current_residual(const CellState &state, Vector<double> &residuals);
		inline void IKs_current_residual(const CellState &state, Vector<double> &residuals);
		inline void ICaL_current_residual(const CellState &state, Vector<double> &residuals);
		inline void IK1_current_residual(const CellState &state, Vector<double> &residuals);
		inline void Iab_current_residual(const CellState &state, Vector<double> &residuals);
		inline void IbK_current_residual(const CellState &state, Vector<double> &residuals);
		inline void IbCa_current_residual(const CellState &state, Vector<double> &residuals);
    	inline void IbNa_current_residual(const CellState &state, Vector<double> &residuals);
    	inline void ICap_current_residual(const CellState &state, Vector<double> &residuals);
    	inline void INaCa_current_residual(const CellState &state, Vector<double> &residuals);
    	inline void INaK_current_residual(const CellState &state, Vector<double> &residuals);
    	inline void Ito_current_residual(const CellState &state, Vector<double> &residuals);
    	inline void IKur_current_residual(const CellState &state, Vector<double> &residuals);
    	inline void If_current_residual(const CellState &state, Vector<double> &residuals);
    	inline void ICaT_current_residual(const CellState &state, Vector<double> &residuals);
    	inline void IGap_current_residual(const CellState &state, Vector<double> &residuals);
    	inline void ISAC_current_residual(const CellState &state, Vector<double> &residuals);


    	//The current residual functions
		inline void Ca_i_residual(const CellState &state, Vector<double> &residuals);
		inline void Na_i_residual(const CellState &state, Vector<double> &residuals);
		inline void K_i_residual(const CellState &state, Vector<double> &residuals);
		inline void Calcium_dynamics_residual(const CellState &state, Vector<double> &residuals);

		//Fibrosis residual
		inline void fibrosis_residuals(const CellState &state, Vector<double> &residuals);

		//Force model residuals
		inline void rice_force_model_residuals(const CellState &state, Vector<double> &residuals);

    	
    private:
		//====================================================================
		//====================================================================
		//The the local index of each variable:	purely to improve readability
		//====================================================================
		//====================================================================
		//!!!!! Rewrite these to just return a number
		//!!!!! Currently this daisy chains down the functions
		//!!!!!		incurring significant overhead for large index variables

		// inline unsigned m_index_CNZCell(){return 0;}
		// inline unsigned h_index_CNZCell(){return m_index_CNZCell()+1;}1
		// inline unsigned j_index_CNZCell(){return h_index_CNZCell()+1;}2
		// inline unsigned d_index_CNZCell(){return j_index_CNZCell()+1;}3
		// inline unsigned f_index_CNZCell(){return d_index_CNZCell()+1;}4
		// inline unsigned xr_index_CNZCell(){return f_index_CNZCell()+1;}5
		// inline unsigned xs_index_CNZCell(){return xr_index_CNZCell()+1;}6
		// inline unsigned nai_index_CNZCell(){return xs_index_CNZCell()+1;}7
		// inline unsigned cai_index_CNZCell(){return nai_index_CNZCell()+1;}8
		// inline unsigned ki_index_CNZCell(){return cai_index_CNZCell()+1;}9
		// inline unsigned fca_index_CNZCell(){return ki_index_CNZCell()+1;}10
		// inline unsigned itr_index_CNZCell(){return fca_index_CNZCell()+1;}11
		// inline unsigned its_index_CNZCell(){return itr_index_CNZCell()+1;}12
		// inline unsigned isusr_index_CNZCell(){return its_index_CNZCell()+1;}13
		// inline unsigned isuss_index_CNZCell(){return isusr_index_CNZCell()+1;}14
		// inline unsigned Cass_index_CNZCell(){return isuss_index_CNZCell()+1;}15
		// inline unsigned CaSR1_index_CNZCell(){return Cass_index_CNZCell()+1;}16
		// inline unsigned CaSR2_index_CNZCell(){return CaSR1_index_CNZCell()+1;}17
		// inline unsigned SERCACa_index_CNZCell(){return CaSR2_index_CNZCell()+1;}18
		// inline unsigned SERCACass_index_CNZCell(){return SERCACa_index_CNZCell()+1;}19
		// inline unsigned RyRoss_index_CNZCell(){return SERCACass_index_CNZCell()+1;}20
		// inline unsigned RyRcss_index_CNZCell(){return RyRoss_index_CNZCell()+1;}21
		// inline unsigned RyRass_index_CNZCell(){return RyRcss_index_CNZCell()+1;}22
		// inline unsigned RyRo3_index_CNZCell(){return RyRass_index_CNZCell()+1;}23
		// inline unsigned RyRc3_index_CNZCell(){return RyRo3_index_CNZCell()+1;}24
		// inline unsigned RyRa3_index_CNZCell(){return RyRc3_index_CNZCell()+1;}25

		// inline unsigned dd_index_CNZCell(){return RyRa3_index_CNZCell()+1;}26 //These are used in ICaT
		// inline unsigned ff_index_CNZCell(){return dd_index_CNZCell()+1;}27	//These are used in ICaT
		
		// inline unsigned CNZ_a_index_CNZCell(){return ff_index_CNZCell()+1;}28
		// inline unsigned CNZ_i_index_CNZCell(){return CNZ_a_index_CNZCell()+1;}29
		// inline unsigned If_y_index_CNZCell(){return CNZ_i_index_CNZCell()+1;}30

		// //Force model parameters
		// inline unsigned rice_N_index_CNZCell(){return If_y_index_CNZCell()+1;}31
		// inline unsigned rice_XBprer_index_CNZCell(){return rice_N_index_CNZCell()+1;}32
		// inline unsigned rice_XBpostr_index_CNZCell(){return rice_XBprer_index_CNZCell()+1;}33
		// inline unsigned rice_SL_index_CNZCell(){return rice_XBpostr_index_CNZCell()+1;}34
		// inline unsigned rice_xXBpostr_index_CNZCell(){return rice_SL_index_CNZCell()+1;}35
		// inline unsigned rice_xXBprer_index_CNZCell(){return rice_xXBpostr_index_CNZCell()+1;}36
		// inline unsigned rice_TRPNCaL_index_CNZCell(){return rice_xXBprer_index_CNZCell()+1;}37
		// inline unsigned rice_TRPNCaH_index_CNZCell(){return rice_TRPNCaL_index_CNZCell()+1;}38
		// inline unsigned intf_index_CNZCell(){return rice_TRPNCaH_index_CNZCell()+1;}39


		// inline unsigned rkv_index_CNZCell(){return ff_index_CNZCell()+1;} 40	//Associated with fibrosis
		// inline unsigned skv_index_CNZCell(){return rkv_index_CNZCell()+1;} 41	//Associated with fibrosis
		// inline unsigned kif_index_CNZCell(){return skv_index_CNZCell()+1;}42	//Associated with fibrosis
		// inline unsigned naif_index_CNZCell(){return kif_index_CNZCell()+1;}43	//Associated with fibrosis
		// inline unsigned Vmf_index_CNZCell(){return naif_index_CNZCell()+1;}44	//Associated with fibrosis


		// inline unsigned BA_index_CNZCell(){return If_y_index_CNZCell()+1;}45	//Not sure what these are for
		// inline unsigned BI_index_CNZCell(){return BA_index_CNZCell()+1;}46	//Not sure what these are for

		//========================================================================================================================================
		//========================================================================================================================================
		//========================================================================================================================================
		// Model constants and variables
		//========================================================================================================================================
		//========================================================================================================================================
		//========================================================================================================================================

		//====================================================================
		//====================================================================
		// Constants from CNZ_Constants.hpp from Haibo-Ni
		//====================================================================
		//====================================================================
		double CRN_vcell; /* um3 */
		double CRN_vi;
		double CRN_vup/*0.0552*vcell*/;
		double CRN_vrel/*0.0048*vcell*/;
		double T; /* 37 Celcius */
		double CRN_Tfac;
		double CRN_Csp; /* pF/cm2 */
		double F; /* coul/mmol */
		double R; /* J K-1 mol-1 */
		double FoRT;	/*	F/RT */
		double CRN_kb; /* mM */
		double CRN_nab; /* mM */
		double CRN_cab; /* mM */
		double CRN_nac;
		double CRN_cac;
		double CRN_kc;
		double CRN_gna; /* nS/pF */
		double CRN_gto; /* nS/pF */
		double CRN_gkr; /* nS/pF */
		double CRN_gks; /* nS/pF */
		double CRN_gcaL; /* nS/pF */
		double CRN_ErL; /* mV */
		double CRN_gk1; /* nS/pF */
		double CRN_gbna; /* nS/pF */
		double CRN_gbk;
		double CRN_gbca; /* nS/pF */
		double CRN_inakbar; /* pA/pF */
		double CRN_kmnai; /* mM */
		double CRN_kmko; /* mM */
		double CRN_icapbar; /* pA/pF */
		double CRN_kmcap; /* mM */
		double CRN_knacalr; /* pA/pF */
		double CRN_kmnalr; /* mM */
		double CRN_kmcalr; /* mM */
		double CRN_ksatlr;
		double CRN_gammalr;
		double CRN_trpnbar; /* mM */
		double CRN_cmdnbar; /* mM */
		double CRN_csqnbar; /* mM */
		double CRN_kmcsqn; /* mM */
		double CRN_kmcmdn; /* mM */
		double CRN_kmtrpn; /* mM */
		double CRN_grelbar; /* ms-1 */
		double CRN_kmup; /* mM */
		double CRN_iupbar; /* mM/ms */
		double CRN_caupmax; /* mM */
		double CRN_kupleak/*iupbar/caupmax*/; /* ms-1 */
		double CRN_tautr; /* ms */
		double CRN_gf_na;////0.10/* 0.09*/; /* nS/pF */
		double CRN_gf_k;
		double CRN_gf;//0.0752;
		double CRN_Ef; /* mV */
		double gcaT;
		double EcaT;
		double MAL_gto; //nS/pF **** in manuscript it is given in nS, so has been /100 here
		double MAL_gkur;
		double CNZ_gkur;
		// New parameters
		double  GONG_gto;
		double  gf;
		// KM model intracellular model parameters
		double Vss;
		double rjunct;
		double lcell;
		double dx;
		double Aj_nj;// = M_PI*rjunct*2*lcell*0.5; // atea between junct and non junct
		double xj_nj;// = 0.02/2 + dx/2; // diffusion distance from center to center of junct to first njunct
		double xj_nj_Nai;// = 0.02/2 + 2*dx; // diffusion distance from center of junct to center of njunct (between 2nd and 3rd njunct)
		double Vnonjunct3;
		double VSR3;
		double VSR4;
		double Vcytosol;
		double Vnonjunct_Nai;
		double BCa;
		double SLlow;
		double SLhigh;
		double KdBCa;
		double KdSLlow;
		double KdSLhigh;
		double CSQN;
		double KdCSQN;
		double BNa;
		double KdBNa;
		double DCa;// % µm2/s
		double DCaSR;//
		double DCaBm; //% µm2/s
		double DNa;
		double SERCAKmf;
		double SERCAKmr;
		double k4 ;// % pump rate
		double k3; //= k4 / SERCAKmr^2;
		double k1;// = 1000^2 * k4;
		double k2;// = k1 * SERCAKmf^2;
		double cpumps;
		double kSRleak;
		// Fibroblast stuff
		double Cmf; // pF
		double vif;//0.00000137;//0.00000000137; // um3  (from 0.00137 nL -> 0.00000137 nm3 -> 0.00000000137 um3
		double naof; //mM
		double kof; //mM
		double Cm;
		double GGAP;
		double FB_Ikv_shift;
		double FB_Gkv;
		//ISAC parameters
		//densities of the different ISAC types
		double ISAC_pNa;
		double ISAC_pK;
		double ISAC_pCa;
		double ISAC_total_Sca;
		//parameters
		double ISAC_Esac;
		double ISAC_Ke;
		double ISAC_strain_half;
		double ISAC_GSac;
		//Switch parameters from SingleCellParameters.cpp
		unsigned IKur_type_CNZ;


		//====================================================================
		//BEGIN Force model parameters
		double SLmax;// belus 2010. fig6, was 2.4;        //   (um) maximum sarcomere length
		double SLmin;//1.4;        //   (um) minimum sarcomere length
		double len_thin;//1.2;      //   (um) thin filament length
		double len_thick; // //1.65;     //   (um) thick filament length
		double len_hbare;      //   (um) length of bare portion of thick filament
		//   Temperature Dependence
		double Qkon;
		double Qkoff;
		// double Qkoff = 1.4;
		double Qkn_p;
		double Qkp_n;
		double Qfapp;
		// double Qgapp = 6.25;
		double Qgapp;
		double Qhf;
		double Qhb;
		double Qgxb;

		//   Ca binding to troponin
		double kon;    //   (1/[ms uM])
		double koffL; //   (1/ms)
		double koffH;  //   (1/ms)
		double perm50;      //   perm variable that controls n to p transition
		double nperm;       //     in Hill-like fashion
		double kn_p;     //   (1/ms)
		double kp_n;      //   (1/ms)
		double koffmod;        //   mod to change species

		//   Thin filament regulation and crossbridge cycling
		double fapp;   //   (1/ms) XB on rate
		double gapp;    //   (1/ms) XB off rate
		double gslmod;          //   controls SL effect on gapp
		double hf;  //   (1/ms) rate between pre-force and force states
		double hfmdc;          //
		double hb;   //   (1/ms) rate between pre-force and force states
		double hbmdc;          //
		double gxb;    //   (1/ms) ATP consuming transition rate
		double sigmap;          //   distortion dependence of STP using transition gxb
		double sigman;          //
		double xbmodsp;      //   mouse specific modification for XB cycling rates

		//   Mean strain of strongly-bound states
		double x_0;      //   (um) strain induced by head rotation
		double xPsi;          //   scaling factor balancing SL motion and XB cycling

		//   Normalized active a nd passive force

		double PCon_t;      //   (norm Force) passive force due to titin
		double PExp_t;         //     these apply to trabeculae and single cells only
		double SL_c;       //   (um) resting length for collagen
		double PCon_c;       //   (norm Force) passive force due to collagen
		double PExp_c;         //     these apply to trabeculae and single cells only

		//   Calculation of complete muscle response
		double massf;  //   ([norm Force ms^2]/um) muscle mass
		double visc;    //   ([norm Force ms]/um) muscle viscosity
		double KSE;          //   (norm Force/um) series elastic element
		double kxb;        //   (mN/mm^2) maximal force
		double Trop_conc;       //   (uM) troponin concentration
		double Temp;
		//END FORCE PARAMETERS
		//====================================================================


		//====================================================================
		//====================================================================
		// Variables dependent on mutation type or cell type
		//====================================================================
		//====================================================================
		//Order of application of parameter modifiers:
		//		+ Default
		//		+ Cell Type
		//		+ Mutation Type
		//		+ Atrial Fibrillation Type

		//====================================================================
		// Conductances
		//====================================================================
		//GNa
		inline double get_GNa(unsigned cell_type = 0, unsigned mut_type = 0) const {
			switch(cell_type){
				case 3:		return 1.3;
				case 4:		return 1.3;
				case 10:	return 0.06;
				case 11:	return 0.3;
			}
			return 1.0;
		}

		//GKr
		inline double get_GKr(unsigned cell_type = 0, unsigned mut_type = 0) const {
			switch(cell_type){
				case 5:		return 1.63;
				case 7:		return 1.6;
				case 8:		return 1.6;
				case 9:		return 2.4;
				case 10:	return 0.45;
				case 11:	return 2.75;
			}
			return 1.0;
		}

		//GKs
		inline double get_GKs(unsigned cell_type = 0, unsigned mut_type = 0) const {
			switch(cell_type){
				case 9:		return 1.5;
				case 10:	return 0.69;
				case 11:	return 2.0;
			}
			return 1.0;
		}

		//GCaL
		inline double get_GCaL(unsigned cell_type = 0, unsigned mut_type = 0) const {
			switch(cell_type){
				case 1:		return 0.94;
				case 2:		return 1.68;
				case 4:		return 0.4;
				case 5:		return 0.67;
				case 6:		return 2.32;
				case 9:		return 0.7;
				case 10:	return 0.68;
				case 11:	return 2.28;
			}
			return 1.0;
		}

		//GK1
		inline double get_GK1(unsigned cell_type = 0, unsigned mut_type = 0) const {
			switch(cell_type){
				case 6:		return 0.85;
				case 9:		return 0.62;
				case 10:	return 0.42;
				case 11:	return 0.3;
			}
			return 1.0;
		}

		//Gbca
		inline double get_Gbca(unsigned cell_type = 0, unsigned mut_type = 0) const {
			return 1.0;
		}

		//GCap
		inline double get_GCap(unsigned cell_type = 0, unsigned mut_type = 0) const {
			return 1.0;
		}

		//GNaCa
		inline double get_GNaCa(unsigned cell_type = 0, unsigned mut_type = 0) const {
			switch(cell_type){
				case 10:	return 0.5;
				case 11:	return 0.5;
			}
			return 1.0;
		}

		//Gto
		inline double get_Gto(unsigned cell_type = 0, unsigned mut_type = 0) const {
			switch(cell_type){
				case 2:		return 1.35;
				case 3:		return 0.53;
				case 4:		return 0.16;
				case 5:		return 0.6;
				case 6:		return 1.17;
				case 8:		return 0.53;
				case 9:		return 0.75;
				case 10:	return 0.4;
				case 11:	return 0.8;
			}
			return 1.0;
		}

		//GKur
		inline double get_GKur(unsigned cell_type = 0, unsigned mut_type = 0) const {
			double GKur_ = 1.0;
			switch(cell_type){
				case 4:		GKur_ = 0.667;
				case 8:		GKur_ = 0.8;
				case 10:	GKur_ = 0.26;
				case 11:	GKur_ = 0.26;
			}
			switch(mut_type){
				case 0:		return GKur_;
				case 1:		return 1.74186924;
				case 2:		return GKur_*1.286906;
				case 3:		return GKur_*1.388228;
				case 4: 	return GKur_*0.461283;
				case 5:		return GKur_*0.563448;
				case 6:		return GKur_*0.038593;
			}
		}

		//Gf
		inline double get_Gf(unsigned cell_type = 0, unsigned mut_type = 0) const {
			switch(cell_type){
				case 7:		return 1.0;
				case 8:		return 1.0;
				case 10:	return 4.4;
				case 11:	return 17.292;
			}
			return 0.4;
		}

		//GCaT
		inline double get_GCaT(unsigned cell_type = 0, unsigned mut_type = 0) const {
			switch(cell_type){
				case 10:	return 76.5;
				case 11:	return 76.5;
			}
			return 1.0;
		}

		//====================================================================
		//Miscellaneous channel parameters
		//====================================================================
		inline double get_IKur_c(unsigned cell_type = 0, unsigned mut_type = 0) const {
			switch(mut_type){
				case 1:		return 3.6887;
			}
			return 4.5128;
		}

		inline double get_IKur_x0(unsigned cell_type = 0, unsigned mut_type = 0) const {
			switch(mut_type){
				case 1:		return 2.84400335;
			}
			return 1.899769;
		}

		inline double get_Ikur_y0(unsigned cell_type = 0, unsigned mut_type = 0) const {
			switch(mut_type){
				case 1:		return 15.2672201;
			}
			return 20.5232;
		}

		//====================================================================
		// Potential Shifts
		//====================================================================

		//IK1_v_shift
		inline double get_IK1_v_shift(unsigned cell_type = 0, unsigned mut_type = 0) const {
			switch(cell_type){
				case 4:		return -6.0;
			}
			return 0.0;
		}

		//IKr_ac_shift
		inline double get_IKr_ac_shift(unsigned cell_type = 0, unsigned mut_type = 0){
			switch(cell_type){
				default:	return 0.0;
			}
			return 0.0;
		}

		//IKr_ac_grad
		inline double get_IKr_ac_grad(unsigned cell_type = 0, unsigned mut_type = 0) const {
			switch(cell_type){
				default:	return 1.0;
			}
			return 1.0;
		}

		//IKs_shift
		inline double get_IKs_shift(unsigned cell_type = 0, unsigned mut_type = 0) const {
			switch(cell_type){
				default:	return 0.0;
			}
			return 0.0;
		}

		inline double get_IKs_grad(unsigned cell_type = 0, unsigned mut_type = 0) const {
			switch(cell_type){
				default:	return 1.0;
			}
			return 1.0;
		}

		// Ikur
		inline double get_IKur_ac_shift(unsigned cell_type = 0, unsigned mut_type = 0) const {
			switch(cell_type){
				case 8:		{
					if(IKur_type_CNZ==0){
						return -14.0;
					}
				}
			}
			return 0.0;
		}

		inline double get_IKur_ac_grad(unsigned cell_type = 0, unsigned mut_type = 0) const {
			switch(cell_type){
				case 8:		{
					if(IKur_type_CNZ==0){
						return 2.1317;
					}
				}
			}
			return 1.0;
		}

		inline double get_IKur_inac_shift(unsigned cell_type = 0, unsigned mut_type = 0) const {
			double IKur_inac_shift = 0.0;
			switch(cell_type){
				case 8:		{if(IKur_type_CNZ==0){IKur_inac_shift = 25.0;}}
			}
			switch(mut_type){
				case 0:		return 0.0;
				case 1:		return -9.6150807654200001;
				case 2:		return -4.02829;
				case 3:		return -6.032311251379999;
				case 4:		return -5.012779270500001;
				case 5:		return -4.5454272743;
				case 6:		return 1.4151025432;
			}
		}

		inline double get_IKur_inac_grad(unsigned cell_type = 0, unsigned mut_type = 0) const {
			double IKur_inac_grad = 1.0;
			switch(cell_type){
				case 8:		{if(IKur_type_CNZ==0){IKur_inac_grad = 1.769;}}
			}
			switch(mut_type){
				case 0:		return 1.0;
				case 1:		return 0.80075124328979652;
				case 2:		return 0.940280253452448;
				case 3:		return 0.748490912918043;
				case 4:		return 0.781775743434569;
				case 5:		return 0.842432589996777;
				case 6:		return 0.687940393974062;
			}
		}

		inline double get_IKur_inac_mult(unsigned cell_type = 0, unsigned mut_type = 0) const {
			switch(mut_type){
				case 0:		return 1.0;
				case 1:		return 0.87254304449870279;
				case 2:		return 0.935206196986113;
				case 3:		return 0.874602534570044;
				case 4:		return 0.936476668495346;
				case 5:		return 1.174004519012284;
				case 6:		return 1.212942827258507;
			}
		}

		inline double get_IKur_inac_add(unsigned cell_type = 0, unsigned mut_type = 0) const {
			switch(mut_type){
				case 0:		return 0.0;
				case 1:		return 0.073931087206000057;
				case 2:		return 0.039197146604;
				case 3:		return 0.070656047487;
				case 4:		return 0.034583585385;
				case 5:		return -0.09291551303;
				case 6:		return -0.110508855073;
			}
		}

		inline double get_IKur_Vhchange(unsigned cell_type = 0, unsigned mut_type = 0) const {
			return 0.0;
		}

		inline double get_IKur_slope(unsigned cell_type = 0, unsigned mut_type = 0) const {
			return 1.0;
		}

		inline double get_IKur_timeconstants(unsigned cell_type = 0, unsigned mut_type = 0) const {
			return 1.0;
		}

		inline double get_IKur_cond(unsigned cell_type = 0, unsigned mut_type = 0) const {
			return 1.0;
		}

		//If
		inline double get_If_vshift(unsigned cell_type = 0, unsigned mut_type = 0) const {
			return 0.0;
		}

		inline double get_If_grad(unsigned cell_type = 0, unsigned mut_type = 0) const {
			switch(cell_type){
				case 0:		return 1.0;
				case 10:	return 1.1;
				case 11:	return 1.075;
			}
			return 1.0;
		}

		//====================================================================
		// Calcium Handling
		//====================================================================
		//fRyR
		inline double get_fRyR(unsigned cell_type = 0, unsigned mut_type = 0) const {
			return 0.0;
		}
		//fIRel
		inline double get_fIRel(unsigned cell_type = 0, unsigned mut_type = 0) const {
			return 1.0;
		}
		//GSR_leak
		inline double get_GSR_leak(unsigned cell_type = 0, unsigned mut_type = 0) const {
			return 1.0;
		}

		//BULK_CONST
		inline double get_BULK_CONST(unsigned cell_type = 0, unsigned mut_type = 0) const {
			switch(cell_type){
				case 1:		return 1.20;
				case 3:		return 1.5;
				case 4:		return 1.5;
				case 6:		return 1.6;
				case 10:	return 3.0;
				case 11:	return 3.0;
			}
			return 1.25;
		}

		//RyR
		inline double get_RyR(unsigned cell_type = 0, unsigned mut_type = 0) const {
			return 1.0;
		}

		//====================================================================
		//Force model
		//====================================================================
		inline double get_SLrest(unsigned cell_type = 0, unsigned mut_type = 0) const {
			return 1.9;
		}
		inline double get_SLset(unsigned cell_type = 0, unsigned mut_type = 0) const {
			return 1.9;
		}

		//========================================================================================================================================
		//========================================================================================================================================
		//========================================================================================================================================
		// End model constants and variables
		//========================================================================================================================================
		//========================================================================================================================================
		//========================================================================================================================================

	};

	//====================================================================
	//====================================================================
	// End CNZ Cell model as inherited by Haibo Ni
	//====================================================================
	//====================================================================

}

#endif