#ifndef OOMPH_TNNP_VENT_HEADER
#define OOMPH_TNNP_VENT_HEADER

// Config header generated by autoconfig
#ifdef HAVE_CONFIG_H
  #include <oomph-lib-config.h>
#endif


#include "cell_model_base.h"

namespace oomph{

	class TNNPVent : public CellModelBase
	{
	public:
		//Defined in .cc
		TNNPVent();

		virtual ~TNNPVent()	{};

		virtual inline double active_strain(CellState &state)
		{
			return 0.0;
		}


		//====================================================================
		//Total membrane current at node
		//====================================================================
		virtual inline double membrane_current(CellState &state)
		{
			//Provide necessary storage for data generated by the various member functions called when calculating
			//	residual and jacobian entries:
			// 14 Currents Ikr, Iks, Ik1, Ito, Ina, Ibna, Ical, Ibca, Inak, Inaca, Ipca, Ipk, Inal, Ikatp
			// 4 reversal currents ena, ek, eks, eca
			// For a total of 18
			state.resize_general_cell_model_data(18);
		
			//Call the reversal functions
			ENa_reversal(state);
			EK_reversal(state);
			EKs_reversal(state);
			ECa_reversal(state);

			//Calculate contribution from each channel
			IKr_current(state);
			IKs_current(state);
			IK1_current(state);
			Ito_current(state);
			INa_current(state);
			IbNa_current(state);
			ICaL_current(state);
			IbCa_current(state);
		    INaK_current(state);
		    INaCa_current(state);
		    IpCa_current(state);
		    IpK_current(state);
		    INaL_current(state);
		    IKATP_current(state);
			
			double temp = 0.0;
		    for(unsigned i=0; i<14; i++){
		    	temp += state.get_general_cell_model_data(i);
		    }
		    return temp;
		}

		virtual inline void custom_output(CellState &state, Vector<double> &output) override
		{
			//Intentionally does nothing
		}

		//Fill in the generic residual and jacobian contribution for the cell variables associated with the node passed
		//	Defined in .cc
		void fill_in_generic_residual_contribution_cell_base(CellState &state,
															Vector<double> &residuals,
															DenseMatrix<double> &jacobian,
															unsigned flag);

		inline void return_initial_membrane_potential(double &v, const unsigned &cell_type=0);
		//Return the initial condition for the nth variable and cell_typeth cell type
		inline bool return_initial_value(const unsigned &n, double &v, const unsigned &cell_type=0);

		//The membrane capacitance
		inline double cm(CellState &state) {return TTCell_CAPACITANCE;}

		//The cell model does not compute its own jacobian entries, it is done by finite differencing
		bool model_calculates_jacobian_entries() {return false;}
		//The number of variables used by the cell model
		unsigned Num_Variables() {return 25;}
		//The number of derivatives required by the cell model when calculating residuals
		unsigned required_derivatives() {return 1;}
		//The number of black box parameters required by the cell model: ab_index, is_index, rv_index
		unsigned required_black_box_parameters() {return 3;}
		//The model has default values for external ionic concentrations - this can be overloaded in
		//	studies where these are changed
		inline unsigned required_external_data() {return 0;}
		
		bool return_initial_state_variable(const unsigned &n, double &v, const unsigned &cell_type);


	protected:
		//====================================================================
		// The channel currents
		//	Calculates the current through each channel from the gating variables
		//		associated with the node
		//	Implemented as virtual to allow overloading for testing new channel models
		//		with minimal effort
		//====================================================================
		virtual inline void IKr_current(CellState &state) ;
		virtual inline void IKs_current(CellState &state) ;
		virtual inline void IK1_current(CellState &state) ;
		virtual inline void Ito_current(CellState &state) ;
		virtual inline void Isus_current(CellState &state) ;
		virtual inline void INa_current(CellState &state) ;
		virtual inline void IbNa_current(CellState &state) ;
		virtual inline void ICaL_current(CellState &state) ;
    	virtual inline void IbCa_current(CellState &state) ;
    	virtual inline void INaK_current(CellState &state) ;
    	virtual inline void INaCa_current(CellState &state) ;
    	virtual inline void IpCa_current(CellState &state) ;
    	virtual inline void IpK_current(CellState &state) ;
    	virtual inline void INaL_current(CellState &state) ;
    	virtual inline void IKATP_current(CellState &state) ;
    	virtual inline void If_current(CellState &state) ;

    	//The reversal potentials
    	virtual inline void ENa_reversal(CellState &state);
		virtual inline void EK_reversal(CellState &state);
		virtual inline void EKs_reversal(CellState &state);
		virtual inline void ECa_reversal(CellState &state);

		//The channel residual functions
		virtual inline void IKr_Markov_residual(CellState &state, Vector<double> &residuals) ;
		virtual inline void IKs_residual(CellState &state, Vector<double> &residuals) ;
		virtual inline void IK1_residual(CellState &state, Vector<double> &residuals) ;
		virtual inline void Ito_residual(CellState &state, Vector<double> &residuals) ;
		virtual inline void INa_residual(CellState &state, Vector<double> &residuals) ;
		virtual inline void IbNa_residual(CellState &state, Vector<double> &residuals) ;
		virtual inline void ICaL_residual(CellState &state, Vector<double> &residuals) ;
		virtual inline void IbCa_residual(CellState &state, Vector<double> &residuals) ;
		virtual inline void INaK_residual(CellState &state, Vector<double> &residuals) ;
		virtual inline void INaCa_residual(CellState &state, Vector<double> &residuals) ;
		virtual inline void IpCa_residual(CellState &state, Vector<double> &residuals) ;
		virtual inline void IpK_residual(CellState &state, Vector<double> &residuals) ;
		virtual inline void INaL_residual(CellState &state, Vector<double> &residuals) ;
		virtual inline void IKATP_residual(CellState &state, Vector<double> &residuals) ;

		//The current residual functions
		virtual inline void Ca_i_residual(CellState &state, Vector<double> &residuals) ;
		virtual inline void Na_i_residual(CellState &state, Vector<double> &residuals) ;
		virtual inline void K_i_residual(CellState &state, Vector<double> &residuals) ;


		// constants for Tent ventricle model
		double TTCell_Ko;
		double TTCell_Cao;
		double TTCell_Nao;
		double TTCell_Vc;
		double TTCell_Vsr;
		double TTCell_Vss;
		double TTCell_Bufc;
		double TTCell_Kbufc;
		double TTCell_Bufsr;
		double TTCell_Kbufsr;
		double TTCell_Bufss;
		double TTCell_Kbufss;
		double TTCell_Vmaxup;
		double TTCell_Kup;
		double TTCell_Vrel;
		double TTCell_k1_;
		double TTCell_k2_;
		double TTCell_k3;
		double TTCell_k4;
		double TTCell_EC;
		double TTCell_maxsr;
		double TTCell_minsr;
		double TTCell_Vleak;
		double TTCell_Vxfer;
		double TTCell_R;
		double TTCell_F;
		double TTCell_T;
		double TTCell_CAPACITANCE;
		double TTCell_pKNa;
		double TTCell_GbNa;
		double TTCell_KmK;
		double TTCell_KmNa;
		double TTCell_knak;
		double TTCell_GCaL;
		double TTCell_GbCa;
		double TTCell_knaca;
		double TTCell_KmNai;
		double TTCell_KmCa;
		double TTCell_ksat;
		double TTCell_n;
		double TTCell_GpCa;
		double TTCell_KpCa;
		double TTCell_GpK;

		double TTCell_RTONF;
		double TTCell_inverseVcF2;
		double TTCell_inverseVcF;
		double TTCell_inversevssF2;

	private:
		virtual inline double get_GNaL(CellState &state){
			switch(state.get_cell_type()){
				case 100 : return  0.0065;
				case 101 : return 0.0095;
				case 102 : return 0.0065;
				case 103 : return 0.0065;
				case 104 : return 0.0095;
				case 105 : return 0.0065;
				default : return 0.0;
			}
		}
		virtual inline double get_Gks(CellState &state){
			double Mfactor = 2.0;
			switch(state.get_cell_type()){
				case 100 : return  0.392 * 1.4;
				case 101 : return 0.098 * Mfactor;
				case 102 : return  0.392;
				case 103 : return 0.392 * 1.4 * (1.0 + 0.8 * state.get_black_box_nodal_parameters(2));
				case 104 : return 0.098 * Mfactor *  (1.0 + 0.8 * state.get_black_box_nodal_parameters(2));
				case 105 : return 0.392 * (1.0 + 0.8 * state.get_black_box_nodal_parameters(2));
				default : return 0.0;
			}
		}

		virtual inline double get_Gto(CellState &state){
			switch(state.get_cell_type()){
				case 100 : return  0.294;
				case 101 : return 0.294;
				case 102 : return  0.073;
				case 103 : return 0.294 * (1.0 + 0.8 * state.get_black_box_nodal_parameters(2));
				case 104 : return 0.294 * (1.0 + 0.8 * state.get_black_box_nodal_parameters(2));
				case 105 : return 0.073 * (1.0 + 0.8 * state.get_black_box_nodal_parameters(2));
				default : return 0.0;
			}
		}

		virtual inline double get_S_INF(CellState &state){
			double InAcTo_Vhalf_ABh = 0.0;
			double InAcTo_Vk_ABh = 1.0;
			switch(state.get_cell_type()){
				case 100 : return 1. / (1. + exp((state.get_vm() + 20 + InAcTo_Vhalf_ABh) / (5.0 * InAcTo_Vk_ABh)));
				case 101 : return 1. / (1. + exp((state.get_vm() + 20 + InAcTo_Vhalf_ABh) / (5.0 * InAcTo_Vk_ABh)));
				case 102 : return 1. / (1. + exp((state.get_vm() + 28 + InAcTo_Vhalf_ABh) / (5.0 * InAcTo_Vk_ABh)));
				case 103 : return 1. / (1. + exp((state.get_vm() + 20 + InAcTo_Vhalf_ABh) / (5.0 * InAcTo_Vk_ABh)));
				case 104 : return 1. / (1. + exp((state.get_vm() + 20 + InAcTo_Vhalf_ABh) / (5.0 * InAcTo_Vk_ABh)));
				case 105 : return 1. / (1. + exp((state.get_vm() + 28 + InAcTo_Vhalf_ABh) / (5.0 * InAcTo_Vk_ABh)));
				default : return 0.0;
			}
		}

		virtual inline double get_TAU_S(CellState &state){
			switch(state.get_cell_type()){
				case 100 : return 85.*exp(-(state.get_vm() + 45.) * (state.get_vm() + 45.) / 320.) + 5. / (1. + exp((state.get_vm() - 20.) / 5.)) + 3.;
				case 101 : return 85.0 * exp(-(state.get_vm() + 45.) * (state.get_vm() + 45.) / 320.) + 5. / (1. + exp((state.get_vm() - 20.) / 5.)) + 3.;
				case 102 : return 1000.*exp(-(state.get_vm() + 67) * (state.get_vm() + 67) / 1000.) + 8.;
				case 103 : return 85.*exp(-(state.get_vm() + 45.) * (state.get_vm() + 45.) / 320.) + 5. / (1. + exp((state.get_vm() - 20.) / 5.)) + 3.;
				case 104 : return 85.0 * exp(-(state.get_vm() + 45.) * (state.get_vm() + 45.) / 320.) + 5. / (1. + exp((state.get_vm() - 20.) / 5.)) + 3.;
				case 105 : return 1000.*exp(-(state.get_vm() + 67) * (state.get_vm() + 67) / 1000.) + 8.;
				default : return 0.0;
			}
		}

		virtual inline double get_R_INF(CellState &state){
			switch(state.get_cell_type()){
				case 100 : return 1. / (1. + exp((20 - state.get_vm()) / 6.));
				case 101 : return 1. / (1. + exp((20 - state.get_vm()) / 6.));
				case 102 : return 1. / (1. + exp((20 - state.get_vm()) / 6.));
				case 103 : return 1. / (1. + exp((20 - state.get_vm()) / 6.));
				case 104 : return 1. / (1. + exp((20 - state.get_vm()) / 6.));
				case 105 : return 1. / (1. + exp((20 - state.get_vm()) / 6.));
				default : return 0.0;
			}
		}

		virtual inline double get_TAU_R(CellState &state){
			switch(state.get_cell_type()){
				case 100 : return 9.5 * exp(-(state.get_vm() + 40.) * (state.get_vm() + 40.) / 1800.) + 0.8;
				case 101 : return 9.5 * exp(-(state.get_vm() + 40.) * (state.get_vm() + 40.) / 1800.) + 0.8;
				case 102 : return 9.5 * exp(-(state.get_vm() + 40.) * (state.get_vm() + 40.) / 1800.) + 0.8;
				case 103 : return 9.5 * exp(-(state.get_vm() + 40.) * (state.get_vm() + 40.) / 1800.) + 0.8;
				case 104 : return 9.5 * exp(-(state.get_vm() + 40.) * (state.get_vm() + 40.) / 1800.) + 0.8;
				case 105 : return 9.5 * exp(-(state.get_vm() + 40.) * (state.get_vm() + 40.) / 1800.) + 0.8;
				default : return 0.0;
			}
		}



		virtual inline double get_Ischemia_TTCell_Ko(CellState &state){
			return TTCell_Ko + state.get_black_box_nodal_parameters(1) * 5.4;
		}

		virtual inline double get_Acidosis_factor(CellState &state){
			return 1.0  - 0.2 * state.get_black_box_nodal_parameters(1);
		}
	};

}

#endif 