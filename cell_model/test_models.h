#ifndef OOMPH_EXAMPLE_CELL_MODEL_HEADER
#define OOMPH_EXAMPLE_CELL_MODEL_HEADER

// Config header generated by autoconfig
#ifdef HAVE_CONFIG_H
  #include <oomph-lib-config.h>
#endif

#include "cell_model_base.h"

namespace oomph{
	//========================================================================================================================================
	//Begin some example cell model classes to demonstrate implementation
	//========================================================================================================================================

	//====================================================================
	//====================================================================
	//Begin the Zero Cell model using default explicit timestepping:
	// an empty cell class for testing if things are working properly
	//====================================================================
	//====================================================================
	class ZeroCellExplicit	:	public CellModelBase
	{
	public:
		ZeroCellExplicit(){
			//what is the intrinsic timestep of the model? This will generally be found through careful
			//	analysis - choose a dt run a number of single cell simulations for various stimulus procedures
			// 	try halving the value of dt, if the value changes, keep going. Repeat until you get a dt
			//	for which a stable solution emerges
			Intrinsic_dt = 0.5;
		}

		//All cell types are compatible with this model
		bool compatible_cell_types(const unsigned& cell_type){return true;}

		//The membrane capacitance of this cell model
		double cm(CellState &state) {return 1.0;}

		void custom_output(CellState &state, Vector<double> &output) {
			//Intentionally returns nothing
		}

		//we just write out the explicit timestepping method, the default
		//	implementation of the base cell model class handles the residual
		//	and jacobian fill in procedure
		void explicit_timestep(CellState &state, Vector<double> &new_state){
			//dy/dt = -y*(y+1)
			//y = y - dt*y*(y+1)
			new_state[0] = new_state[0] - state.get_dt()*new_state[0]*(new_state[0]-1.0);

			//at the end of the explicit timestep function we inform the Cell state container
			//	what the membrane current and active strain are
			state.set_membrane_current(state.get_var(0,0));
			state.set_active_strain(pow(state.get_var(0,0),2.0));
		}

		//Return the initial membrane potential
		void return_initial_membrane_potential(double &v, const unsigned &cell_type=0){v=1.0;}
		//Return the initial conditions of the model
		bool return_initial_state_variable(const unsigned &n, double &v, const unsigned &cell_type=0){
			switch(n){
				case 0 : {
					v = 1.0;
					return true;
				}
				default : {
					return false;
				}
			}
		}

		//the model requires a single variable to be stored at each node
		inline unsigned required_nodal_variables(const unsigned &cell_type=0) {return 1;}
		//the model is explicit so doesn't require any derivatives, it approximates them for itself
		inline unsigned required_derivatives() {return 0;}
		//the model does not reuqire any extra black-box style nodal parameters
		inline unsigned required_black_box_parameters() {return 0;}
	};//end explicit zerocell


	//====================================================================
	//====================================================================
	//Begin the Zero Cell model using implicit timestepping:
	// an empty cell class for testing if things are working properly
	//====================================================================
	//====================================================================
	class ZeroCellImplicit	:	public CellModelBase
	{
	public:
		ZeroCellImplicit(){}

		//All cell types are compatible with this model
		bool compatible_cell_types(const unsigned& cell_type){return true;}
		//Return a sensible value
		double membrane_current(CellState &state) {return state.get_var(0,0);}
		//Return a sensbile value
		double active_strain(CellState &state) {return pow(state.get_var(0,0),2.0);}
		//The membrane capacitance of this cell model
		double cm(CellState &state) const {return 1.0;}
		//The custom output for the model, there's nothing special to output so it's left blank
		void custom_output(CellState &state, Vector<double> &output) {
			//Intentionally returns nothing
		}
		//The model is implicit. we therefore have to overload this function
		//	to calculate the residuals (and jacobian) analytically
		void fill_in_generic_residual_contribution_cell_base(CellState &state,
															Vector<double> &residuals,
															DenseMatrix<double> &jacobian,
															unsigned flag)
		{
			//R = dy/dt+y*(y+1)
			residuals[0] += state.get_var(1,0) + state.get_var(0,0)*(state.get_var(0,0)+1.0);
			if(flag){
				//J = w + 2*y + 1
				//where w is the coefficient of y in approximation of dy/dt
				jacobian(0, 0) += state.get_time_stepper_weight(1,0) + 2*state.get_var(0,0)+1.0;
			}
		}
		//Return the initial membrane potential
		void return_initial_membrane_potential(double &v, const unsigned &cell_type=0){v=1.0;}
		//Return the initial conditions of the model
		bool return_initial_state_variable(const unsigned &n, double &v, const unsigned &cell_type=0){
			switch(n){
				case 0 : {
					v = 1.0;
					return true;
				}
				default : {
					return false;
				}
			}
		}

		//the model is simple and so we allow it to calculate the jacobian analytically
		inline bool model_calculates_jacobian_entries() {return true;}
		//the model requires a single variable to be stored at each node
		inline unsigned required_nodal_variables(const unsigned &cell_type=0) {return 1;}
		//the model requires a single time derivative
		inline unsigned required_derivatives() {return 1;}
		//the model does not reuqire any extra black-box style nodal parameters
		inline unsigned required_black_box_parameters() {return 0;}
	};//end implicit zerocell






	//!!!!!Both fithughnagumo models are very stiff - work out why at some point
	
	//====================================================================
	//====================================================================
	//Begin the Explicit FitzHugh-Nagumo Cell model:
	// a deprecated cell class for testing if linking between the
	// monodomain elements and cell model interface elements
	// is working correctly, and for demonstrating cell model wrappers
	// used during modelling.
	//====================================================================
	//====================================================================
	class FitzHughNagumoExplicit	:	public CellModelBase
	{
	public:
		FitzHughNagumoExplicit() : CellModelBase()
		{
			Intrinsic_dt = 0.05;
		}

		bool compatible_cell_types(const unsigned& cell_type){return true;}

		//The membrane capacitance of this cell model
		double cm(CellState &state) const {return 1.0;}

		void custom_output(CellState &state, Vector<double> &output)
		{
			//Intentionally does nothing
		}

		//we just write out the explicit timestepping method, the default
		//	implementation of the base cell model class handles the residual
		//	and jacobian fill in procedure
		void explicit_timestep(CellState &state, Vector<double> &new_state){
			//In complicated cell models it might be useful to give variables meaningful names
			// before they are used
			double y = new_state[0];
			double vm = state.get_vm();

			// dy/dt = forcing_function
			// y = y + dt*forcing_function
			new_state[0] = y + state.get_dt()*variable_forcing_function(vm,new_state[0]);

			//set the values of membrane current and active strain
			state.set_membrane_current((potential_forcing_function(vm,new_state[0]))- new_state[0]);
			// state.set_membrane_current(0.0);
			state.set_active_strain(0.0);
		}

		//Return the initial membrane potential
		void return_initial_membrane_potential(double &v, const unsigned &cell_type=0){v=1.0;}

		bool return_initial_state_variable(const unsigned &n, double &v, const unsigned &cell_type=0){
			switch(n){
				case 0 : {
					v = 0.0;
					return true;
				}
				default : {
					return false;
				}
			}
		}


		//the model requires a single variable to be stored at each node
		inline unsigned required_nodal_variables(const unsigned &cell_type=0) {return 1;}
		//the model doesn't require any time derivatives of the variables, it's explicit and calculates them for itself
		inline unsigned required_derivatives() {return 0;}
		//the model does not reuqire any extra black-box style nodal parameters
		inline unsigned required_black_box_parameters() {return 0;}


		////Extra functions to compartmentalise the model:
		//// useful if a mutation affecting for example potential_forcing_function is modelled
		//// then a cell model class inheriting from this one can be written with very little effort
		virtual double potential_forcing_function(const double &Vm, const double &var) const
		{
			return -(Vm*(1.0-Vm*Vm/3.0)-var);
		}
		virtual double variable_forcing_function(const double &Vm, const double &var) const
		{
			double a = 0.7;
			double b = 0.8;
			double tau = 12.5;
			return (1/tau)*(Vm + a - b*var);
		}

	};//end implicit fitzhugh nagumo model


	//====================================================================
	//====================================================================
	//Begin the Implicit FitzHugh-Nagumo Cell model:
	// a deprecated cell class for testing if linking between the
	// monodomain elements and cell model interface elements
	// is working correctly, and for demonstrating cell model wrappers
	// used during modelling.
	//====================================================================
	//====================================================================
	//!!!!! change membrane current and active strain to call fill in residual and fill in residual to change membrane
	//		current and active strain in the cell state container
	class FitzHughNagumoImplicit	:	public CellModelBase
	{
	public:
		FitzHughNagumoImplicit() : CellModelBase() {	}

		bool compatible_cell_types(const unsigned& cell_type){return true;}

		//because we're writing an implicit method we need to overload membrane current
	 	double membrane_current(CellState &state)
		{
			return -(potential_forcing_function(state.get_vm()) - state.get_var(0,0));
		}

		//because we're writing an implicit method we need to overload active strain
		double active_strain(CellState &state) {return 0.0;}

		//The membrane capacitance of this cell model
		double cm(CellState &state) const {return 1.0;}

		//we overload the custom output but it does nothing
		void custom_output(CellState &state, Vector<double> &output)
		{
			//Intentionally does nothing
		}

		//since this is an implicit method we must overload this to calculate the residual
		//	and jacobian entries
		void fill_in_generic_residual_contribution_cell_base(CellState &state,
															Vector<double> &residuals,
															DenseMatrix<double> &jacobian,
															unsigned flag)
		{
			//In complicated cell models it might be useful to give variables meaningful names
			// before they are used
			double vm = state.get_vm();

			int var_ind = 0;
			residuals[0] += state.get_var(1,0) - variable_forcing_function(vm, state.get_var(0,0));
		}

		//Return the initial membrane potential
		void return_initial_membrane_potential(double &v, const unsigned &cell_type=0){v=1.0;}

		bool return_initial_state_variable(const unsigned &n, double &v, const unsigned &cell_type=0){
			switch(n){
				case 0 : {
					v = 0.0;
					return true;
				}
				default : {
					return false;
				}
			}
		}

		//the model depends on the variable forcing function below, since this can be overridden by the user
		//	it is difficult to write an analytic fill in for the jacobian, we therefore set this flag to false
		//	and the interface element will handle finite differencing for us.
		inline bool model_calculates_jacobian_entries() {return false;}
		//the model requires a single variable to be stored at each node
		inline unsigned required_nodal_variables(const unsigned &cell_type=0) {return 1;}
		//the model requires a single time derivative
		inline unsigned required_derivatives() {return 1;}
		//the model does not reuqire any extra black-box style nodal parameters
		inline unsigned required_black_box_parameters() {return 0;}


		////Extra functions to compartmentalise the model:
		//// useful if a mutation affecting for example potential_forcing_function is modelled
		//// then a cell model class inheriting from this one can be written with very little effort
		virtual double potential_forcing_function(const double &Vm) const
		{
			return Vm*(1.0-Vm*Vm/3.0);
		}
		virtual double variable_forcing_function(const double &Vm, const double &var) const
		{
			return 0.08*(Vm + 0.7 - 0.8*var);
		}


	};//end implicit fitzhugh nagumo model


	//========================================================================================================================================
	//End some example cell model classes to demonstrate implementation
	//========================================================================================================================================

}

#endif