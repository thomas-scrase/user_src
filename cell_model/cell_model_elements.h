//local_ind[i] contains the index for which the local_ind[i]th nodal value of node returns the ith cell variable
//This is needed because in multiphysics elements, the cell variables might be shifted to accommodate the other element variables



#ifndef OOMPH_CELL_MODEL_HEADER
#define OOMPH_CELL_MODEL_HEADER

// Config header generated by autoconfig
#ifdef HAVE_CONFIG_H
  #include <oomph-lib-config.h>
#endif

//OOMPH-LIB includes
#include "../generic/nodes.h"
#include "../generic/oomph_utilities.h"
#include "../generic/matrices.h"
#include "../generic/Qelements.h"
#include "../generic/Telements.h"

//define a sign and heaviside function for use in rice model
#define rice_sign(a) ((a) < (0.) ? (-1.0) : (1.0))
#define rice_heav(a) ((a) < (0.) ? (0.0) : (1.0))

namespace oomph{
	class CellModelBase
	{
	public:
		CellModelBase()	{}

		virtual ~CellModelBase()	{}

		inline double node_var_derivative(	Node* node,
											const unsigned &ind,
											const Vector<unsigned> &local_ind) const
		{
			TimeStepper* time_stepper_pt = node->time_stepper_pt();
			double dvardt=0.0;
			if(!time_stepper_pt->is_steady()){
				const unsigned n_time = time_stepper_pt->ntstorage();

				for(unsigned t=0;t<n_time;t++){
					dvardt += time_stepper_pt->weight(1,t)*node->value(t,local_ind[ind]);
				}
			}
			return dvardt;
		}

		inline double node_var(	Node* node,
								const unsigned &ind,
								const Vector<unsigned> &local_ind) const
		{
			return node->value(local_ind[ind]);
		}

		virtual inline double active_strain(	Node* node,
												const Vector<unsigned> &local_ind) const
		{
			std::string error_message =
		    "Active strain has not been implemented for this cell model yet.";
		    
		   throw OomphLibError(error_message,
		                       OOMPH_CURRENT_FUNCTION,
		                       OOMPH_EXCEPTION_LOCATION);
		   return 0.0;
		}

		virtual inline double membrane_current(	Node* node,
												const double& Vm,
												const double& strain,
												const Vector<double> &Ext_conc,
												const Vector<unsigned> &local_ind,
												const unsigned &cell_type,
												const unsigned &mut_type,
												const unsigned &fibrosis) const
		{
			std::string error_message =
		    "Membrane current has not been implemented for this cell model yet.";
		    
		   throw OomphLibError(error_message,
		                       OOMPH_CURRENT_FUNCTION,
		                       OOMPH_EXCEPTION_LOCATION);
		   return 0.0;
		}

		// Calculate the sub residual and sub jacobian objects
		virtual inline void fill_in_generic_residual_contribution_cell_base(Node* node,
																			const double& Vm,
																			const double& strain,
																			const Vector<double> &Ext_conc,
																			const Vector<unsigned> &local_ind,
																			const unsigned &cell_type,
																			const unsigned &mut_type,
																			const unsigned &fibrosis,
																			Vector<double> &residuals,
																			DenseMatrix<double> &jacobian,
																			unsigned flag)
		{
			throw OomphLibError("fill_in_generic_residual_contribution_cell_base has not been implemented for this cell model yet.",
		                       OOMPH_CURRENT_FUNCTION,
		                       OOMPH_EXCEPTION_LOCATION);
		}

		const unsigned Required_storage() const {
			// std::cout << "in CellModelBase Required_storage(): " << Required_Storage << std::endl;
			return Required_Storage;
		}

		// const unsigned &Required_derivatives() const {return *Required_derivatives;}

	protected:
		unsigned Required_Storage;

		// static const unsigned Required_derivatives;
	};

















	//====================================================================
	//====================================================================
	//Begin the Zero Cell model:
	// an empty cell class for testing if linking between the
	// monodomain elements and cell model interface elements
	// is working correctly.
	//====================================================================
	//====================================================================
	class ZeroCell	:	public CellModelBase
	{
	public:
		ZeroCell(){
			this->Required_Storage = 1;
		}

		virtual ~ZeroCell()	{}

		virtual double active_strain(	Node* node,
										const Vector<unsigned> &local_ind) const
		{
			return 0.0;
		}

		inline double membrane_current(	Node* node,
										const double& Vm,
										const double& strain,
										const Vector<double> &Ext_conc,
										const Vector<unsigned> &local_ind,
										const unsigned &cell_type,
										const unsigned &mut_type,
										const unsigned &fibrosis) const
		{
			//zero to not affect the monodomain solution
			return 1.0;
		}

		void fill_in_generic_residual_contribution_cell_base(	Node* node,
						const double& Vm,
						const double& strain,
						const Vector<double> &Ext_conc,
						const Vector<unsigned> &local_ind,
						const unsigned &cell_type,
						const unsigned &mut_type,
						const unsigned &fibrosis,
						Vector<double> &residuals,
						DenseMatrix<double> &jacobian,
						unsigned flag)
		{
			//some function which behaves
			int var_ind = 0;
			residuals[local_ind[var_ind]] += node_var_derivative(node, var_ind, local_ind) + node_var(node,var_ind,local_ind)*(node_var(node,var_ind,local_ind)+1.0);
			if(flag){
				jacobian(var_ind, var_ind) += node->time_stepper_pt()->weight(1,0) + 2*node_var(node,var_ind,local_ind)+1.0;
			}
		}

		double const cm() const {return 1.0;}
	};












	//====================================================================
	//====================================================================
	//Begin the FitzHugh-Nagumo Cell model:
	// a deprecated cell class for testing if linking between the
	// monodomain elements and cell model interface elements
	// is working correctly, and for demonstrating cell model wrappers
	// used during modelling.
	//====================================================================
	//====================================================================
	class FitzHughNagumo	:	public CellModelBase
	{
	public:
		FitzHughNagumo(){
			this->Required_Storage = 1;
		}

		virtual ~FitzHughNagumo()	{}

		virtual double active_strain(	Node* node,
										const Vector<unsigned> &local_ind) const
		{
			return 0.0;
		}

		inline virtual double potential_forcing_function(const double& Vm) const{
			return Vm*(1-Vm*Vm/3.0);
			// return 0.0;
		}

		inline virtual double variable_forcing_function(const double& Vm, const double& var) const{
			return 0.08*(Vm + 0.7 - 0.8*var);
			// return 10.0*(Vm - potential_scaling() + 0.7 - 0.8*var);
		}

		// The membrane current at the node
		inline double membrane_current(	Node* node,
										const double& Vm,
										const double& strain,
										const Vector<double> &Ext_conc,
										const Vector<unsigned> &local_ind,
										const unsigned &cell_type,
										const unsigned &mut_type,
										const unsigned &fibrosis) const
		{
			return -(potential_forcing_function(Vm) - node_var(node,0,local_ind));
		}

		void fill_in_generic_residual_contribution_cell_base(	Node* node,
						const double& Vm,
						const double& strain,
						const Vector<double> &Ext_conc,
						const Vector<unsigned> &local_ind,
						const unsigned &cell_type,
						const unsigned &mut_type,
						const unsigned &fibrosis,
						Vector<double> &residuals,
						DenseMatrix<double> &jacobian,
						unsigned flag)
		{
			//some function which behaves
			int var_ind = 0;
			residuals[local_ind[var_ind]] += node_var_derivative(node, var_ind, local_ind) - variable_forcing_function(Vm, node_var(node, var_ind, local_ind));
			if(flag){
				jacobian(var_ind, var_ind) += node->time_stepper_pt()->weight(1,0) + 2*node_var(node,var_ind,local_ind)+1.0;
			}
		}

		double const cm() const {return 1.0;}

		// double const potential_scaling() const {return -77.079842;}
	};



















	//====================================================================
	//====================================================================
	//Begin the CNZ Cell model as inherited from Haibo Ni
	//====================================================================
	//====================================================================

	class CNZCell : public CellModelBase
	{
	public:

		//Defined in .cc file
		CNZCell();

		virtual ~CNZCell()	{}

		virtual double active_strain(	Node* node,
										const Vector<unsigned> &local_ind) const
		{	
			//!!!!!
			// SLrest is set to 1.9 by default, in future this
			// should be changed to a fct returning a suitable value
			// to reflect cell and mut type

			// SLrest = 1.9;
			
			return (node_var(node, rice_SL_index_CNZCell(), local_ind) - get_SLrest()) / get_SLrest();
		}

		//====================================================================
		//Total membrane current at node
		//====================================================================
		inline double membrane_current(	Node* node,
										const double& Vm,
										const double& strain,
										const Vector<double> &Ext_conc,
										const Vector<unsigned> &local_ind,
										const unsigned &cell_type,
										const unsigned &mut_type,
										const unsigned &fibrosis) const
		{	
			//Calculate values required by lots of currents now to avoid excessive overhead...

			double Ena, Eca, Ek;
			//double Ekf, Enaf;												//!!!!! REVERSAL POTENTIALS USED BY FIBROSIS
			get_reversal_Na(Ext_conc[0], node_var(node, nai_index_CNZCell(), local_ind), Ena);
			get_reversal_Ca(Ext_conc[1], node_var(node, cai_index_CNZCell(), local_ind), Eca);
			get_reversal_K(Ext_conc[2],  node_var(node,  ki_index_CNZCell(), local_ind), Ek);

			//Get the ISAC scale
			double ISAC_ = ISAC_ISAC_CNZCell(node, Ext_conc, local_ind, cell_type, mut_type, fibrosis, Vm, strain);

			double total_membrane_current;
			//Calculate contribution from each channel
			total_membrane_current 	= 	(	INa_current_CNZCell(node, Ext_conc, local_ind, cell_type, mut_type, fibrosis, Vm, Ena)
										+	IKr_current_CNZCell(node, Ext_conc, local_ind, cell_type, mut_type, fibrosis, Vm, Ek)
										+	IKs_current_CNZCell(node, Ext_conc, local_ind, cell_type, mut_type, fibrosis, Vm, Ek)
										+	ICaL_current_CNZCell(node, Ext_conc, local_ind, cell_type, mut_type, fibrosis, Vm, CRN_ErL)
										+	IK1_current_CNZCell(node, Ext_conc, local_ind, cell_type, mut_type, fibrosis, Vm, Ek)
										+	Iab_current_CNZCell(node, Ext_conc, local_ind, cell_type, mut_type, fibrosis, Vm, 0.0)			//!!!!! NO NERNST POTENTIAL USED IN CNZCell CODE
										+	IbK_current_CNZCell(node, Ext_conc, local_ind, cell_type, mut_type, fibrosis, Vm, Ek)
										+	IbCa_current_CNZCell(node, Ext_conc, local_ind, cell_type, mut_type, fibrosis, Vm, Eca)
									    +	IbNa_current_CNZCell(node, Ext_conc, local_ind, cell_type, mut_type, fibrosis, Vm, Ena)
									    +	ICap_current_CNZCell(node, Ext_conc, local_ind, cell_type, mut_type, fibrosis, Vm, 0.0)		//!!!!! NO NERNST POTENTIAL USED IN CNZCell CODE
									    +	INaCa_current_CNZCell(node, Ext_conc, local_ind, cell_type, mut_type, fibrosis, Vm, 0.0)		//!!!!! NO NERNST POTENTIAL USED IN CNZCell CODE
									    +	INaK_current_CNZCell(node, Ext_conc, local_ind, cell_type, mut_type, fibrosis, Vm, 0.0)		//!!!!! NO NERNST POTENTIAL USED IN CNZCell CODE
									    +	Ito_current_CNZCell(node, Ext_conc, local_ind, cell_type, mut_type, fibrosis, Vm, Ek)
									    +	IKur_current_CNZCell(node, Ext_conc, local_ind, cell_type, mut_type, fibrosis, Vm, Ek)
									    +	If_current_CNZCell(node, Ext_conc, local_ind, cell_type, mut_type, fibrosis, Vm, 0.0)			//!!!!! NO NERNST POTENTIAL USED IN CNZCell CODE
									    +	ICaT_current_CNZCell(node, Ext_conc, local_ind, cell_type, mut_type, fibrosis, Vm, 0.0)		//!!!!! NO NERNST POTENTIAL USED IN CNZCell CODE
										+	IGap_current_CNZCell(node, Ext_conc, local_ind, cell_type, mut_type, fibrosis, Vm, 0.0)		//!!!!! NOT IMPLEMENTED YET
										// +	ISAC_Na_current_CNZCell(node, Ext_conc, local_ind, cell_type, mut_type, fibrosis, Vm, ISAC_)
										// +	ISAC_K_current_CNZCell(node, Ext_conc, local_ind, cell_type, mut_type, fibrosis, Vm, ISAC_)
										// +	ISAC_Ca_current_CNZCell(node, Ext_conc, local_ind, cell_type, mut_type, fibrosis, Vm, ISAC_)
										+	ISAC_ISAC_CNZCell(node, Ext_conc, local_ind, cell_type, mut_type, fibrosis, Vm, strain)
										) / Cm;

			//Not dividing by the membrane capacitance. I am moving dependence on Cm to the monodomain element
			return total_membrane_current;
		}

		//Fill in the generic residual and jacobian contribution for the cell variables associated with the node passed
		//	Defined in .cc
		void fill_in_generic_residual_contribution_cell_base(Node* node,
															const double& Vm,
															const double& strain,
															const Vector<double> &Ext_conc,
															const Vector<unsigned> &local_ind,
															const unsigned &cell_type,
															const unsigned &mut_type,
															const unsigned &fibrosis,
															Vector<double> &residuals,
															DenseMatrix<double> &jacobian,
															unsigned flag);

		//The membrane capacitance
		double const cm() const {return Cm;}
	
	protected:

		//====================================================================
		//====================================================================
		// Cell Helper functions
		//====================================================================
		//====================================================================

		//====================================================================
		// External ionic concentrations
		//====================================================================
		inline void get_reversal_Na(const double& Na_o,
									const double& Na_i,
									double& Ena) const
		{
			Ena = 26.71*log(Na_o / Na_i);
		}
		inline void get_reversal_K(const double& K_o,
									const double& K_i,
									double& Ek) const
		{
			Ek = 26.71*log(K_o / K_i);
		}
		inline void get_reversal_Ca(const double& Ca_o,
									const double& Ca_i,
									double& Eca) const
		{
			Eca = 13.35*log(Ca_o / Ca_i);
		}
		//!!!!!
		//ADD THE FIBROBLAST REVERSAL POTENTIALS

		//====================================================================
		// The channel currents
		//	Calculates the current through each channel from the gating variables
		//		associated with the node
		//	Implemented as virtual to allow overloading for testing new channel models
		//		with minimal effort
		//====================================================================
		inline double INa_current_CNZCell(	Node* node,
													const Vector<double> &Ext_conc,
                            						const Vector<unsigned> &local_ind,
													const unsigned &cell_type,
													const unsigned &mut_type,
													const unsigned &fibrosis,
													const double &Vm,
													const double &Rev_Pot) const ;
		inline double IKr_current_CNZCell(	Node* node,
													const Vector<double> &Ext_conc,
													const Vector<unsigned> &local_ind,
													const unsigned &cell_type,
													const unsigned &mut_type,
													const unsigned &fibrosis,
													const double &Vm,
													const double &Rev_Pot) const ;
		inline double IKs_current_CNZCell(	Node* node,
													const Vector<double> &Ext_conc,
													const Vector<unsigned> &local_ind,
													const unsigned &cell_type,
													const unsigned &mut_type,
													const unsigned &fibrosis,
													const double &Vm,
													const double &Rev_Pot) const ;
		inline double ICaL_current_CNZCell(	Node* node,
													const Vector<double> &Ext_conc,
													const Vector<unsigned> &local_ind,
													const unsigned &cell_type,
													const unsigned &mut_type,
													const unsigned &fibrosis,
													const double &Vm,
													const double &Rev_Pot) const ;
		inline double IK1_current_CNZCell(	Node* node,
													const Vector<double> &Ext_conc,
													const Vector<unsigned> &local_ind,
													const unsigned &cell_type,
													const unsigned &mut_type,
													const unsigned &fibrosis,
													const double &Vm,
													const double &Rev_Pot) const ;
		inline double Iab_current_CNZCell(	Node* node,
													const Vector<double> &Ext_conc,
													const Vector<unsigned> &local_ind,
													const unsigned &cell_type,
													const unsigned &mut_type,
													const unsigned &fibrosis,
													const double &Vm,
													const double &Rev_Pot) const ;
		inline double IbK_current_CNZCell(	Node* node,
													const Vector<double> &Ext_conc,
													const Vector<unsigned> &local_ind,
													const unsigned &cell_type,
													const unsigned &mut_type,
													const unsigned &fibrosis,
													const double &Vm,
													const double &Rev_Pot) const ;
		inline double IbCa_current_CNZCell(	Node* node,
													const Vector<double> &Ext_conc,
													const Vector<unsigned> &local_ind,
													const unsigned &cell_type,
													const unsigned &mut_type,
													const unsigned &fibrosis,
													const double &Vm,
													const double &Rev_Pot) const ;
    	inline double IbNa_current_CNZCell(	Node* node,
    												const Vector<double> &Ext_conc,
    												const Vector<unsigned> &local_ind,
													const unsigned &cell_type,
													const unsigned &mut_type,
													const unsigned &fibrosis,
													const double &Vm,
													const double &Rev_Pot) const ;
    	inline double ICap_current_CNZCell(	Node* node,
    												const Vector<double> &Ext_conc,
    												const Vector<unsigned> &local_ind,
													const unsigned &cell_type,
													const unsigned &mut_type,
													const unsigned &fibrosis,
													const double &Vm,
													const double &Rev_Pot) const ;
    	inline double INaCa_current_CNZCell(Node* node,
    												const Vector<double> &Ext_conc,
    												const Vector<unsigned> &local_ind,
													const unsigned &cell_type,
													const unsigned &mut_type,
													const unsigned &fibrosis,
													const double &Vm,
													const double &Rev_Pot) const ;
    	inline double INaK_current_CNZCell(	Node* node,
    												const Vector<double> &Ext_conc,
    												const Vector<unsigned> &local_ind,
													const unsigned &cell_type,
													const unsigned &mut_type,
													const unsigned &fibrosis,
													const double &Vm,
													const double &Rev_Pot) const ;
    	inline double Ito_current_CNZCell(	Node* node,
    												const Vector<double> &Ext_conc,
    												const Vector<unsigned> &local_ind,
													const unsigned &cell_type,
													const unsigned &mut_type,
													const unsigned &fibrosis,
													const double &Vm,
													const double &Rev_Pot) const ;
    	inline double IKur_current_CNZCell(	Node* node,
    												const Vector<double> &Ext_conc,
    												const Vector<unsigned> &local_ind,
													const unsigned &cell_type,
													const unsigned &mut_type,
													const unsigned &fibrosis,
													const double &Vm,
													const double &Rev_Pot) const ;
    	inline double If_current_CNZCell(	Node* node,
    												const Vector<double> &Ext_conc,
    												const Vector<unsigned> &local_ind,
													const unsigned &cell_type,
													const unsigned &mut_type,
													const unsigned &fibrosis,
													const double &Vm,
													const double &Rev_Pot) const ;
    	inline double ICaT_current_CNZCell(	Node* node,
    												const Vector<double> &Ext_conc,
    												const Vector<unsigned> &local_ind,
													const unsigned &cell_type,
													const unsigned &mut_type,
													const unsigned &fibrosis,
													const double &Vm,
													const double &Rev_Pot) const ;
    	
    	inline double IGap_current_CNZCell(	Node* node,
    												const Vector<double> &Ext_conc,
    												const Vector<unsigned> &local_ind,
													const unsigned &cell_type,
													const unsigned &mut_type,
													const unsigned &fibrosis,
													const double &Vm,
													const double &Rev_Pot) const ;
    	
    	inline double ISAC_ISAC_CNZCell(	Node* node,
    												const Vector<double> &Ext_conc,
    												const Vector<unsigned> &local_ind,
													const unsigned &cell_type,
													const unsigned &mut_type,
													const unsigned &fibrosis,
													const double &Vm,
													const double &strain) const ;
    	inline double ISAC_Na_current_CNZCell(Node* node,
    												const Vector<double> &Ext_conc,
    												const Vector<unsigned> &local_ind,
													const unsigned &cell_type,
													const unsigned &mut_type,
													const unsigned &fibrosis,
													const double &Vm,
													const double &ISAC_) const ;
    	inline double ISAC_K_current_CNZCell(Node* node,
    												const Vector<double> &Ext_conc,
    												const Vector<unsigned> &local_ind,
													const unsigned &cell_type,
													const unsigned &mut_type,
													const unsigned &fibrosis,
													const double &Vm,
													const double &ISAC_) const ;
    	inline double ISAC_Ca_current_CNZCell(Node* node,
    												const Vector<double> &Ext_conc,
    												const Vector<unsigned> &local_ind,
													const unsigned &cell_type,
													const unsigned &mut_type,
													const unsigned &fibrosis,
													const double &Vm,
													const double &ISAC_) const ;
    	
    private:
		//====================================================================
		//====================================================================
		//The the local index of each variable:	purely to improve readability
		//====================================================================
		//====================================================================
		//!!!!! Rewrite these to just return a number
		//!!!!! Currently this daisy chains down the functions
		//!!!!!		incurring significant overhead for large index variables

		inline unsigned m_index_CNZCell() const {return 0;}
		inline unsigned h_index_CNZCell() const {return m_index_CNZCell()+1;}
		inline unsigned j_index_CNZCell() const {return h_index_CNZCell()+1;}
		inline unsigned d_index_CNZCell() const {return j_index_CNZCell()+1;}
		inline unsigned f_index_CNZCell() const {return d_index_CNZCell()+1;}
		inline unsigned xr_index_CNZCell() const {return f_index_CNZCell()+1;}
		inline unsigned xs_index_CNZCell() const {return xr_index_CNZCell()+1;}
		inline unsigned nai_index_CNZCell() const {return xs_index_CNZCell()+1;}
		inline unsigned cai_index_CNZCell() const {return nai_index_CNZCell()+1;}
		inline unsigned ki_index_CNZCell() const {return cai_index_CNZCell()+1;}
		inline unsigned fca_index_CNZCell() const {return ki_index_CNZCell()+1;}
		inline unsigned itr_index_CNZCell() const {return fca_index_CNZCell()+1;}
		inline unsigned its_index_CNZCell() const {return itr_index_CNZCell()+1;}
		inline unsigned isusr_index_CNZCell() const {return its_index_CNZCell()+1;}
		inline unsigned isuss_index_CNZCell() const {return isusr_index_CNZCell()+1;}
		inline unsigned Cass_index_CNZCell() const {return isuss_index_CNZCell()+1;}
		inline unsigned CaSR1_index_CNZCell() const {return Cass_index_CNZCell()+1;}
		inline unsigned CaSR2_index_CNZCell() const {return CaSR1_index_CNZCell()+1;}
		inline unsigned SERCACa_index_CNZCell() const {return CaSR2_index_CNZCell()+1;}
		inline unsigned SERCACass_index_CNZCell() const {return SERCACa_index_CNZCell()+1;}
		inline unsigned RyRoss_index_CNZCell() const {return SERCACass_index_CNZCell()+1;}
		inline unsigned RyRcss_index_CNZCell() const {return RyRoss_index_CNZCell()+1;}
		inline unsigned RyRass_index_CNZCell() const {return RyRcss_index_CNZCell()+1;}
		inline unsigned RyRo3_index_CNZCell() const {return RyRass_index_CNZCell()+1;}
		inline unsigned RyRc3_index_CNZCell() const {return RyRo3_index_CNZCell()+1;}
		inline unsigned RyRa3_index_CNZCell() const {return RyRc3_index_CNZCell()+1;}
		//These are the pinned variables
		inline unsigned dd_index_CNZCell() const {return RyRa3_index_CNZCell()+1;}
		inline unsigned ff_index_CNZCell() const {return dd_index_CNZCell()+1;}
		// inline unsigned rkv_index_CNZCell() const {return ff_index_CNZCell()+1;}
		// inline unsigned skv_index_CNZCell() const {return rkv_index_CNZCell()+1;}
		// inline unsigned kif_index_CNZCell() const {return skv_index_CNZCell()+1;}
		// inline unsigned naif_index_CNZCell() const {return kif_index_CNZCell()+1;}
		// inline unsigned Vmf_index_CNZCell() const {return naif_index_CNZCell()+1;}
		inline unsigned CNZ_a_index_CNZCell() const {return ff_index_CNZCell()+1;}//{return Vmf_index_CNZCell()+1;}
		inline unsigned CNZ_i_index_CNZCell() const {return CNZ_a_index_CNZCell()+1;}
		inline unsigned If_y_index_CNZCell() const {return CNZ_i_index_CNZCell()+1;}
		// inline unsigned BA_index_CNZCell() const {return If_y_index_CNZCell()+1;}
		// inline unsigned BI_index_CNZCell() const {return BA_index_CNZCell()+1;}

		//Force model parameters
		inline unsigned rice_N_index_CNZCell() const {return If_y_index_CNZCell()+1;}
		inline unsigned rice_XBprer_index_CNZCell() const {return rice_N_index_CNZCell()+1;}
		inline unsigned rice_XBpostr_index_CNZCell() const {return rice_XBprer_index_CNZCell()+1;}
		inline unsigned rice_SL_index_CNZCell() const {return rice_XBpostr_index_CNZCell()+1;}
		inline unsigned rice_xXBpostr_index_CNZCell() const {return rice_SL_index_CNZCell()+1;}
		inline unsigned rice_xXBprer_index_CNZCell() const {return rice_xXBpostr_index_CNZCell()+1;}
		inline unsigned rice_TRPNCaL_index_CNZCell() const {return rice_xXBprer_index_CNZCell()+1;}
		inline unsigned rice_TRPNCaH_index_CNZCell() const {return rice_TRPNCaL_index_CNZCell()+1;}
		inline unsigned intf_index_CNZCell() const {return rice_TRPNCaH_index_CNZCell()+1;}

		//========================================================================================================================================
		//========================================================================================================================================
		//========================================================================================================================================
		// Model constants and variables
		//========================================================================================================================================
		//========================================================================================================================================
		//========================================================================================================================================

		//====================================================================
		//====================================================================
		// Constants from CNZ_Constants.hpp from Haibo-Ni
		//====================================================================
		//====================================================================
		double CRN_vcell; /* um3 */
		double CRN_vi;
		double CRN_vup/*0.0552*vcell*/;
		double CRN_vrel/*0.0048*vcell*/;
		double T; /* 37 Celcius */
		double CRN_Tfac;
		double CRN_Csp; /* pF/cm2 */
		double F; /* coul/mmol */
		double R; /* J K-1 mol-1 */
		double FoRT;	/*	F/RT */
		double CRN_kb; /* mM */
		double CRN_nab; /* mM */
		double CRN_cab; /* mM */
		double CRN_nac;
		double CRN_cac;
		double CRN_kc;
		double CRN_gna; /* nS/pF */
		double CRN_gto; /* nS/pF */
		double CRN_gkr; /* nS/pF */
		double CRN_gks; /* nS/pF */
		double CRN_gcaL; /* nS/pF */
		double CRN_ErL; /* mV */
		double CRN_gk1; /* nS/pF */
		double CRN_gbna; /* nS/pF */
		double CRN_gbk;
		double CRN_gbca; /* nS/pF */
		double CRN_inakbar; /* pA/pF */
		double CRN_kmnai; /* mM */
		double CRN_kmko; /* mM */
		double CRN_icapbar; /* pA/pF */
		double CRN_kmcap; /* mM */
		double CRN_knacalr; /* pA/pF */
		double CRN_kmnalr; /* mM */
		double CRN_kmcalr; /* mM */
		double CRN_ksatlr;
		double CRN_gammalr;
		double CRN_trpnbar; /* mM */
		double CRN_cmdnbar; /* mM */
		double CRN_csqnbar; /* mM */
		double CRN_kmcsqn; /* mM */
		double CRN_kmcmdn; /* mM */
		double CRN_kmtrpn; /* mM */
		double CRN_grelbar; /* ms-1 */
		double CRN_kmup; /* mM */
		double CRN_iupbar; /* mM/ms */
		double CRN_caupmax; /* mM */
		double CRN_kupleak/*iupbar/caupmax*/; /* ms-1 */
		double CRN_tautr; /* ms */
		double CRN_gf_na;////0.10/* 0.09*/; /* nS/pF */
		double CRN_gf_k;
		double CRN_gf;//0.0752;
		double CRN_Ef; /* mV */
		double gcaT;
		double EcaT;
		double MAL_gto; //nS/pF **** in manuscript it is given in nS, so has been /100 here
		double MAL_gkur;
		double CNZ_gkur;
		// New parameters
		double  GONG_gto;
		double  gf;
		// KM model intracellular model parameters
		double Vss;
		double rjunct;
		double lcell;
		double dx;
		double Aj_nj;// = M_PI*rjunct*2*lcell*0.5; // atea between junct and non junct
		double xj_nj;// = 0.02/2 + dx/2; // diffusion distance from center to center of junct to first njunct
		double xj_nj_Nai;// = 0.02/2 + 2*dx; // diffusion distance from center of junct to center of njunct (between 2nd and 3rd njunct)
		double Vnonjunct3;
		double VSR3;
		double VSR4;
		double Vcytosol;
		double Vnonjunct_Nai;
		double BCa;
		double SLlow;
		double SLhigh;
		double KdBCa;
		double KdSLlow;
		double KdSLhigh;
		double CSQN;
		double KdCSQN;
		double BNa;
		double KdBNa;
		double DCa;// % µm2/s
		double DCaSR;//
		double DCaBm; //% µm2/s
		double DNa;
		double SERCAKmf;
		double SERCAKmr;
		double k4 ;// % pump rate
		double k3; //= k4 / SERCAKmr^2;
		double k1;// = 1000^2 * k4;
		double k2;// = k1 * SERCAKmf^2;
		double cpumps;
		double kSRleak;
		// Fibroblast stuff
		double Cmf; // pF
		double vif;//0.00000137;//0.00000000137; // um3  (from 0.00137 nL -> 0.00000137 nm3 -> 0.00000000137 um3
		double naof; //mM
		double kof; //mM
		double Cm;
		//ISAC parameters
		//densities of the different ISAC types
		double ISAC_pNa;
		double ISAC_pK;
		double ISAC_pCa;
		double ISAC_total_Sca;
		//parameters
		double ISAC_Esac;
		double ISAC_Ke;
		double ISAC_strain_half;
		double ISAC_GSac;
		//Switch parameters from SingleCellParameters.cpp
		unsigned IKur_type_CNZ;


		//====================================================================
		//BEGIN Force model parameters
		double SLmax;// belus 2010. fig6, was 2.4;        //   (um) maximum sarcomere length
		double SLmin;//1.4;        //   (um) minimum sarcomere length
		double len_thin;//1.2;      //   (um) thin filament length
		double len_thick; // //1.65;     //   (um) thick filament length
		double len_hbare;      //   (um) length of bare portion of thick filament
		//   Temperature Dependence
		double Qkon;
		double Qkoff;
		// double Qkoff = 1.4;
		double Qkn_p;
		double Qkp_n;
		double Qfapp;
		// double Qgapp = 6.25;
		double Qgapp;
		double Qhf;
		double Qhb;
		double Qgxb;

		//   Ca binding to troponin
		double kon;    //   (1/[ms uM])
		double koffL; //   (1/ms)
		double koffH;  //   (1/ms)
		double perm50;      //   perm variable that controls n to p transition
		double nperm;       //     in Hill-like fashion
		double kn_p;     //   (1/ms)
		double kp_n;      //   (1/ms)
		double koffmod;        //   mod to change species

		//   Thin filament regulation and crossbridge cycling
		double fapp;   //   (1/ms) XB on rate
		double gapp;    //   (1/ms) XB off rate
		double gslmod;          //   controls SL effect on gapp
		double hf;  //   (1/ms) rate between pre-force and force states
		double hfmdc;          //
		double hb;   //   (1/ms) rate between pre-force and force states
		double hbmdc;          //
		double gxb;    //   (1/ms) ATP consuming transition rate
		double sigmap;          //   distortion dependence of STP using transition gxb
		double sigman;          //
		double xbmodsp;      //   mouse specific modification for XB cycling rates

		//   Mean strain of strongly-bound states
		double x_0;      //   (um) strain induced by head rotation
		double xPsi;          //   scaling factor balancing SL motion and XB cycling

		//   Normalized active a nd passive force

		double PCon_t;      //   (norm Force) passive force due to titin
		double PExp_t;         //     these apply to trabeculae and single cells only
		double SL_c;       //   (um) resting length for collagen
		double PCon_c;       //   (norm Force) passive force due to collagen
		double PExp_c;         //     these apply to trabeculae and single cells only

		//   Calculation of complete muscle response
		double massf;  //   ([norm Force ms^2]/um) muscle mass
		double visc;    //   ([norm Force ms]/um) muscle viscosity
		double KSE;          //   (norm Force/um) series elastic element
		double kxb;        //   (mN/mm^2) maximal force
		double Trop_conc;       //   (uM) troponin concentration
		double Temp;
		//END FORCE PARAMETERS
		//====================================================================


		//====================================================================
		//====================================================================
		// Variables dependent on mutation type or cell type
		//====================================================================
		//====================================================================
		//Order of application of parameter modifiers:
		//		+ Default
		//		+ Cell Type
		//		+ Mutation Type
		//		+ Atrial Fibrillation Type

		//====================================================================
		// Conductances
		//====================================================================
		//GNa
		inline double get_GNa(unsigned cell_type = 0, unsigned mut_type = 0) const {
			switch(cell_type){
				case 3:		return 1.3;
				case 4:		return 1.3;
				case 10:	return 0.06;
				case 11:	return 0.3;
			}
			return 1.0;
		}

		//GKr
		inline double get_GKr(unsigned cell_type = 0, unsigned mut_type = 0) const {
			switch(cell_type){
				case 5:		return 1.63;
				case 7:		return 1.6;
				case 8:		return 1.6;
				case 9:		return 2.4;
				case 10:	return 0.45;
				case 11:	return 2.75;
			}
			return 1.0;
		}

		//GKs
		inline double get_GKs(unsigned cell_type = 0, unsigned mut_type = 0) const {
			switch(cell_type){
				case 9:		return 1.5;
				case 10:	return 0.69;
				case 11:	return 2.0;
			}
			return 1.0;
		}

		//GCaL
		inline double get_GCaL(unsigned cell_type = 0, unsigned mut_type = 0) const {
			switch(cell_type){
				case 1:		return 0.94;
				case 2:		return 1.68;
				case 4:		return 0.4;
				case 5:		return 0.67;
				case 6:		return 2.32;
				case 9:		return 0.7;
				case 10:	return 0.68;
				case 11:	return 2.28;
			}
			return 1.0;
		}

		//GK1
		inline double get_GK1(unsigned cell_type = 0, unsigned mut_type = 0) const {
			switch(cell_type){
				case 6:		return 0.85;
				case 9:		return 0.62;
				case 10:	return 0.42;
				case 11:	return 0.3;
			}
			return 1.0;
		}

		//Gbca
		inline double get_Gbca(unsigned cell_type = 0, unsigned mut_type = 0) const {
			return 1.0;
		}

		//GCap
		inline double get_GCap(unsigned cell_type = 0, unsigned mut_type = 0) const {
			return 1.0;
		}

		//GNaCa
		inline double get_GNaCa(unsigned cell_type = 0, unsigned mut_type = 0) const {
			switch(cell_type){
				case 10:	return 0.5;
				case 11:	return 0.5;
			}
			return 1.0;
		}

		//Gto
		inline double get_Gto(unsigned cell_type = 0, unsigned mut_type = 0) const {
			switch(cell_type){
				case 2:		return 1.35;
				case 3:		return 0.53;
				case 4:		return 0.16;
				case 5:		return 0.6;
				case 6:		return 1.17;
				case 8:		return 0.53;
				case 9:		return 0.75;
				case 10:	return 0.4;
				case 11:	return 0.8;
			}
			return 1.0;
		}

		//GKur
		inline double get_GKur(unsigned cell_type = 0, unsigned mut_type = 0) const {
			double GKur_ = 1.0;
			switch(cell_type){
				case 4:		GKur_ = 0.667;
				case 8:		GKur_ = 0.8;
				case 10:	GKur_ = 0.26;
				case 11:	GKur_ = 0.26;
			}
			switch(mut_type){
				case 0:		return GKur_;
				case 1:		return 1.74186924;
				case 2:		return GKur_*1.286906;
				case 3:		return GKur_*1.388228;
				case 4: 	return GKur_*0.461283;
				case 5:		return GKur_*0.563448;
				case 6:		return GKur_*0.038593;
			}
		}

		//Gf
		inline double get_Gf(unsigned cell_type = 0, unsigned mut_type = 0) const {
			switch(cell_type){
				case 7:		return 1.0;
				case 8:		return 1.0;
				case 10:	return 4.4;
				case 11:	return 17.292;
			}
			return 0.4;
		}

		//GCaT
		inline double get_GCaT(unsigned cell_type = 0, unsigned mut_type = 0) const {
			switch(cell_type){
				case 10:	return 76.5;
				case 11:	return 76.5;
			}
			return 1.0;
		}

		//====================================================================
		//Miscellaneous channel parameters
		//====================================================================
		inline double get_IKur_c(unsigned cell_type = 0, unsigned mut_type = 0) const {
			switch(mut_type){
				case 1:		return 3.6887;
			}
			return 4.5128;
		}

		inline double get_IKur_x0(unsigned cell_type = 0, unsigned mut_type = 0) const {
			switch(mut_type){
				case 1:		return 2.84400335;
			}
			return 1.899769;
		}

		inline double get_Ikur_y0(unsigned cell_type = 0, unsigned mut_type = 0) const {
			switch(mut_type){
				case 1:		return 15.2672201;
			}
			return 20.5232;
		}

		//====================================================================
		// Potential Shifts
		//====================================================================

		//IK1_v_shift
		inline double get_IK1_v_shift(unsigned cell_type = 0, unsigned mut_type = 0) const {
			switch(cell_type){
				case 4:		return -6.0;
			}
			return 0.0;
		}

		//IKr_ac_shift
		inline double get_IKr_ac_shift(unsigned cell_type = 0, unsigned mut_type = 0){
			switch(cell_type){
				default:	return 0.0;
			}
			return 0.0;
		}

		//IKr_ac_grad
		inline double get_IKr_ac_grad(unsigned cell_type = 0, unsigned mut_type = 0) const {
			switch(cell_type){
				default:	return 1.0;
			}
			return 1.0;
		}

		//IKs_shift
		inline double get_IKs_shift(unsigned cell_type = 0, unsigned mut_type = 0) const {
			switch(cell_type){
				default:	return 0.0;
			}
			return 0.0;
		}

		inline double get_IKs_grad(unsigned cell_type = 0, unsigned mut_type = 0) const {
			switch(cell_type){
				default:	return 1.0;
			}
			return 1.0;
		}

		// Ikur
		inline double get_IKur_ac_shift(unsigned cell_type = 0, unsigned mut_type = 0) const {
			switch(cell_type){
				case 8:		{
					if(IKur_type_CNZ==0){
						return -14.0;
					}
				}
			}
			return 0.0;
		}

		inline double get_IKur_ac_grad(unsigned cell_type = 0, unsigned mut_type = 0) const {
			switch(cell_type){
				case 8:		{
					if(IKur_type_CNZ==0){
						return 2.1317;
					}
				}
			}
			return 1.0;
		}

		inline double get_IKur_inac_shift(unsigned cell_type = 0, unsigned mut_type = 0) const {
			double IKur_inac_shift = 0.0;
			switch(cell_type){
				case 8:		{if(IKur_type_CNZ==0){IKur_inac_shift = 25.0;}}
			}
			switch(mut_type){
				case 0:		return 0.0;
				case 1:		return -9.6150807654200001;
				case 2:		return -4.02829;
				case 3:		return -6.032311251379999;
				case 4:		return -5.012779270500001;
				case 5:		return -4.5454272743;
				case 6:		return 1.4151025432;
			}
		}

		inline double get_IKur_inac_grad(unsigned cell_type = 0, unsigned mut_type = 0) const {
			double IKur_inac_grad = 1.0;
			switch(cell_type){
				case 8:		{if(IKur_type_CNZ==0){IKur_inac_grad = 1.769;}}
			}
			switch(mut_type){
				case 0:		return 1.0;
				case 1:		return 0.80075124328979652;
				case 2:		return 0.940280253452448;
				case 3:		return 0.748490912918043;
				case 4:		return 0.781775743434569;
				case 5:		return 0.842432589996777;
				case 6:		return 0.687940393974062;
			}
		}

		inline double get_IKur_inac_mult(unsigned cell_type = 0, unsigned mut_type = 0) const {
			switch(mut_type){
				case 0:		return 1.0;
				case 1:		return 0.87254304449870279;
				case 2:		return 0.935206196986113;
				case 3:		return 0.874602534570044;
				case 4:		return 0.936476668495346;
				case 5:		return 1.174004519012284;
				case 6:		return 1.212942827258507;
			}
		}

		inline double get_IKur_inac_add(unsigned cell_type = 0, unsigned mut_type = 0) const {
			switch(mut_type){
				case 0:		return 0.0;
				case 1:		return 0.073931087206000057;
				case 2:		return 0.039197146604;
				case 3:		return 0.070656047487;
				case 4:		return 0.034583585385;
				case 5:		return -0.09291551303;
				case 6:		return -0.110508855073;
			}
		}

		inline double get_IKur_Vhchange(unsigned cell_type = 0, unsigned mut_type = 0) const {
			return 0.0;
		}

		inline double get_IKur_slope(unsigned cell_type = 0, unsigned mut_type = 0) const {
			return 1.0;
		}

		inline double get_IKur_timeconstants(unsigned cell_type = 0, unsigned mut_type = 0) const {
			return 1.0;
		}

		inline double get_IKur_cond(unsigned cell_type = 0, unsigned mut_type = 0) const {
			return 1.0;
		}

		//If
		inline double get_If_vshift(unsigned cell_type = 0, unsigned mut_type = 0) const {
			return 0.0;
		}

		inline double get_If_grad(unsigned cell_type = 0, unsigned mut_type = 0) const {
			switch(cell_type){
				case 0:		return 1.0;
				case 10:	return 1.1;
				case 11:	return 1.075;
			}
			return 1.0;
		}

		//====================================================================
		// Calcium Handling
		//====================================================================
		//fRyR
		inline double get_fRyR(unsigned cell_type = 0, unsigned mut_type = 0) const {
			return 0.0;
		}
		//fIRel
		inline double get_fIRel(unsigned cell_type = 0, unsigned mut_type = 0) const {
			return 1.0;
		}
		//GSR_leak
		inline double get_GSR_leak(unsigned cell_type = 0, unsigned mut_type = 0) const {
			return 1.0;
		}

		//BULK_CONST
		inline double get_BULK_CONST(unsigned cell_type = 0, unsigned mut_type = 0) const {
			switch(cell_type){
				case 1:		return 1.20;
				case 3:		return 1.5;
				case 4:		return 1.5;
				case 6:		return 1.6;
				case 10:	return 3.0;
				case 11:	return 3.0;
			}
			return 1.25;
		}

		//RyR
		inline double get_RyR(unsigned cell_type = 0, unsigned mut_type = 0) const {
			return 1.0;
		}

		//====================================================================
		//Force model
		//====================================================================
		inline double get_SLrest(unsigned cell_type = 0, unsigned mut_type = 0) const {
			return 1.9;
		}
		inline double get_SLset(unsigned cell_type = 0, unsigned mut_type = 0) const {
			return 1.9;
		}

		//========================================================================================================================================
		//========================================================================================================================================
		//========================================================================================================================================
		// End model constants and variables
		//========================================================================================================================================
		//========================================================================================================================================
		//========================================================================================================================================

	};

	//====================================================================
	//====================================================================
	// End CNZ Cell model as inherited by Haibo Ni
	//====================================================================
	//====================================================================
}

#endif