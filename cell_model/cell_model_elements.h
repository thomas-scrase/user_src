//LIC// ====================================================================
//LIC// Contains the base cell model class along with two simple cell models
//LIC// ZeroCell - purely for testing
//LIC// FitzHighNagumo - an old redundant model also for testing, albeit more
//LIC//		in depth.
//LIC// ====================================================================




//local_ind[i] contains the index for which the local_ind[i]th nodal value of node returns the ith cell variable
//This is needed because in multiphysics elements, the cell variables might be shifted to accommodate the other element variables


#ifndef OOMPH_CELL_MODEL_HEADER
#define OOMPH_CELL_MODEL_HEADER

// Config header generated by autoconfig
#ifdef HAVE_CONFIG_H
  #include <oomph-lib-config.h>
#endif

//OOMPH-LIB includes
#include "../generic/nodes.h"
#include "../generic/oomph_utilities.h"
#include "../generic/matrices.h"
#include "../generic/Qelements.h"
#include "../generic/Telements.h"

//define a sign and heaviside function for use in rice model
#define rice_sign(a) ((a) < (0.) ? (-1.0) : (1.0))
#define rice_heav(a) ((a) < (0.) ? (0.0) : (1.0))

namespace oomph{
	class CellModelBase
	{
	public:
		CellModelBase()	{}

		virtual ~CellModelBase()	{}

		inline double node_var_derivative(	Node* node,
											const unsigned &ind,
											const Vector<unsigned> &local_ind) const
		{
			TimeStepper* time_stepper_pt = node->time_stepper_pt();
			double dvardt=0.0;
			if(!time_stepper_pt->is_steady()){
				const unsigned n_time = time_stepper_pt->ntstorage();

				for(unsigned t=0;t<n_time;t++){
					dvardt += time_stepper_pt->weight(1,t)*node->value(t,local_ind[ind]);
				}
			}
			return dvardt;
		}

		inline double node_var(	Node* node,
								const unsigned &ind,
								const Vector<unsigned> &local_ind) const
		{
			return node->value(local_ind[ind]);
		}

		virtual inline double active_strain(	Node* node,
												const Vector<unsigned> &local_ind) const
		{
			std::string error_message =
		    "Active strain has not been implemented for this cell model yet.";
		    
		   throw OomphLibError(error_message,
		                       OOMPH_CURRENT_FUNCTION,
		                       OOMPH_EXCEPTION_LOCATION);
		   return 0.0;
		}

		virtual inline double membrane_current(	Node* node,
												const double& Vm,
												const double& strain,
												const Vector<double> &Ext_conc,
												const Vector<unsigned> &local_ind,
												const unsigned &cell_type,
												const unsigned &mut_type,
												const unsigned &fibrosis) const
		{
			std::string error_message =
		    "Membrane current has not been implemented for this cell model yet.";
		    
		   throw OomphLibError(error_message,
		                       OOMPH_CURRENT_FUNCTION,
		                       OOMPH_EXCEPTION_LOCATION);
		   return 0.0;
		}

		// Calculate the sub residual and sub jacobian objects
		virtual inline void fill_in_generic_residual_contribution_cell_base(Node* node,
																			const double& Vm,
																			const double& strain,
																			const Vector<double> &Ext_conc,
																			const Vector<unsigned> &local_ind,
																			const unsigned &cell_type,
																			const unsigned &mut_type,
																			const unsigned &fibrosis,
																			Vector<double> &residuals,
																			DenseMatrix<double> &jacobian,
																			unsigned flag)
		{
			throw OomphLibError("fill_in_generic_residual_contribution_cell_base has not been implemented for this cell model yet.",
		                       OOMPH_CURRENT_FUNCTION,
		                       OOMPH_EXCEPTION_LOCATION);
		}

		const unsigned Required_storage() const {
			// std::cout << "in CellModelBase Required_storage(): " << Required_Storage << std::endl;
			return Required_Storage;
		}

		// const unsigned &Required_derivatives() const {return *Required_derivatives;}

	protected:
		unsigned Required_Storage;

		// static const unsigned Required_derivatives;
	};

















	//====================================================================
	//====================================================================
	//Begin the Zero Cell model:
	// an empty cell class for testing if linking between the
	// monodomain elements and cell model interface elements
	// is working correctly.
	//====================================================================
	//====================================================================
	class ZeroCell	:	public CellModelBase
	{
	public:
		ZeroCell(){
			this->Required_Storage = 1;
		}

		virtual ~ZeroCell()	{}

		virtual double active_strain(	Node* node,
										const Vector<unsigned> &local_ind) const
		{
			return 0.0;
		}

		inline double membrane_current(	Node* node,
										const double& Vm,
										const double& strain,
										const Vector<double> &Ext_conc,
										const Vector<unsigned> &local_ind,
										const unsigned &cell_type,
										const unsigned &mut_type,
										const unsigned &fibrosis) const
		{
			//zero to not affect the monodomain solution
			return 1.0;
		}

		void fill_in_generic_residual_contribution_cell_base(	Node* node,
						const double& Vm,
						const double& strain,
						const Vector<double> &Ext_conc,
						const Vector<unsigned> &local_ind,
						const unsigned &cell_type,
						const unsigned &mut_type,
						const unsigned &fibrosis,
						Vector<double> &residuals,
						DenseMatrix<double> &jacobian,
						unsigned flag)
		{
			//some function which behaves
			int var_ind = 0;
			residuals[local_ind[var_ind]] += node_var_derivative(node, var_ind, local_ind) + node_var(node,var_ind,local_ind)*(node_var(node,var_ind,local_ind)+1.0);
			if(flag){
				jacobian(var_ind, var_ind) += node->time_stepper_pt()->weight(1,0) + 2*node_var(node,var_ind,local_ind)+1.0;
			}
		}

		double const cm() const {return 1.0;}
	};












	//====================================================================
	//====================================================================
	//Begin the FitzHugh-Nagumo Cell model:
	// a deprecated cell class for testing if linking between the
	// monodomain elements and cell model interface elements
	// is working correctly, and for demonstrating cell model wrappers
	// used during modelling.
	//====================================================================
	//====================================================================
	class FitzHughNagumo	:	public CellModelBase
	{
	public:
		FitzHughNagumo(){
			this->Required_Storage = 1;
		}

		virtual ~FitzHughNagumo()	{}

		virtual double active_strain(	Node* node,
										const Vector<unsigned> &local_ind) const
		{
			return 0.0;
		}

		inline virtual double potential_forcing_function(const double& Vm) const{
			return Vm*(1-Vm*Vm/3.0);
			// return 0.0;
		}

		inline virtual double variable_forcing_function(const double& Vm, const double& var) const{
			return 0.08*(Vm + 0.7 - 0.8*var);
			// return 10.0*(Vm - potential_scaling() + 0.7 - 0.8*var);
		}

		// The membrane current at the node
		inline double membrane_current(	Node* node,
										const double& Vm,
										const double& strain,
										const Vector<double> &Ext_conc,
										const Vector<unsigned> &local_ind,
										const unsigned &cell_type,
										const unsigned &mut_type,
										const unsigned &fibrosis) const
		{
			return -(potential_forcing_function(Vm) - node_var(node,0,local_ind));
		}

		void fill_in_generic_residual_contribution_cell_base(	Node* node,
						const double& Vm,
						const double& strain,
						const Vector<double> &Ext_conc,
						const Vector<unsigned> &local_ind,
						const unsigned &cell_type,
						const unsigned &mut_type,
						const unsigned &fibrosis,
						Vector<double> &residuals,
						DenseMatrix<double> &jacobian,
						unsigned flag)
		{
			//some function which behaves
			int var_ind = 0;
			residuals[local_ind[var_ind]] += node_var_derivative(node, var_ind, local_ind) - variable_forcing_function(Vm, node_var(node, var_ind, local_ind));
			if(flag){
				jacobian(var_ind, var_ind) += node->time_stepper_pt()->weight(1,0) + 2*node_var(node,var_ind,local_ind)+1.0;
			}
		}

		double const cm() const {return 1.0;}

		// double const potential_scaling() const {return -77.079842;}
	};


}

#endif