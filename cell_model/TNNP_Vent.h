//LIC// ====================================================================
//LIC// Contains the TNNP ventricle model, last updated by Ni, Haibo
//LIC// ====================================================================

#ifndef OOMPH_TNNP_VENT_HEADER
#define OOMPH_TNNP_VENT_HEADER

// Config header generated by autoconfig
#ifdef HAVE_CONFIG_H
  #include <oomph-lib-config.h>
#endif

#include "cell_model_base.h"

namespace oomph{

	class TNNPVent : public CellModelBase
	{
	public:
		//Defined in .cc
		TNNPVent();

		virtual ~TNNPVent()	{};

		virtual inline double active_strain(CellState &state)
		{
			return 0.0;
		}


		//====================================================================
		//Total membrane current at node
		//====================================================================
		virtual inline double membrane_current(CellState &state)
		{
			//Call the reversal functions
			ENa_reversal(state);
			EK_reversal(state);
			EKs_reversal(state);
			ECa_reversal(state);

			//Calculate contribution from each channel
			IKr_current(state);
			IKs_current(state);
			IK1_current(state);
			Ito_current(state);
			INa_current(state);
			IbNa_current(state);
			ICaL_current(state);
			IbCa_current(state);
		    INaK_current(state);
		    INaCa_current(state);
		    IpCa_current(state);
		    IpK_current(state);
		    INaL_current(state);
		    IKATP_current(state);

		    return (state.ikr() + state.iks() + state.ik1() + state.ito() + state.ina() + state.ibna() + state.ical()
		    	+	state.ibca() + state.inak() + state.inaca() + state.ipca() + state.ipk() + state.inal() + state.ikatp());
		}


		//Fill in the generic residual and jacobian contribution for the cell variables associated with the node passed
		//	Defined in .cc
		void fill_in_generic_residual_contribution_cell_base(CellState &state,
															Vector<double> &residuals,
															DenseMatrix<double> &jacobian,
															unsigned flag);

		inline void return_initial_membrane_potential(double &v, const unsigned &cell_type=0);
		//Return the initial condition for the nth variable and cell_typeth cell type
		inline bool return_initial_value(const unsigned &n, double &v, const unsigned &cell_type=0);

		//The membrane capacitance
		virtual double cm() const {return TTCell_CAPACITANCE;}


	protected:
		//====================================================================
		// The channel currents
		//	Calculates the current through each channel from the gating variables
		//		associated with the node
		//	Implemented as virtual to allow overloading for testing new channel models
		//		with minimal effort
		//====================================================================
		virtual inline void IKr_current(CellState &state) ;
		virtual inline void IKs_current(CellState &state) ;
		virtual inline void IK1_current(CellState &state) ;
		virtual inline void Ito_current(CellState &state) ;
		virtual inline void Isus_current(CellState &state) ;
		virtual inline void INa_current(CellState &state) ;
		virtual inline void IbNa_current(CellState &state) ;
		virtual inline void ICaL_current(CellState &state) ;
    	virtual inline void IbCa_current(CellState &state) ;
    	virtual inline void INaK_current(CellState &state) ;
    	virtual inline void INaCa_current(CellState &state) ;
    	virtual inline void IpCa_current(CellState &state) ;
    	virtual inline void IpK_current(CellState &state) ;
    	virtual inline void INaL_current(CellState &state) ;
    	virtual inline void IKATP_current(CellState &state) ;
    	virtual inline void If_current(CellState &state) ;

    	//The reversal potentials
    	virtual inline void ENa_reversal(CellState &state);
		virtual inline void EK_reversal(CellState &state);
		virtual inline void EKs_reversal(CellState &state);
		virtual inline void ECa_reversal(CellState &state);

		//The channel residual functions
		virtual inline void IKr_Markov_residual(CellState &state, Vector<double> &residuals) ;
		virtual inline void IKs_residual(CellState &state, Vector<double> &residuals) ;
		virtual inline void IK1_residual(CellState &state, Vector<double> &residuals) ;
		virtual inline void Ito_residual(CellState &state, Vector<double> &residuals) ;
		virtual inline void INa_residual(CellState &state, Vector<double> &residuals) ;
		virtual inline void IbNa_residual(CellState &state, Vector<double> &residuals) ;
		virtual inline void ICaL_residual(CellState &state, Vector<double> &residuals) ;
		virtual inline void IbCa_residual(CellState &state, Vector<double> &residuals) ;
		virtual inline void INaK_residual(CellState &state, Vector<double> &residuals) ;
		virtual inline void INaCa_residual(CellState &state, Vector<double> &residuals) ;
		virtual inline void IpCa_residual(CellState &state, Vector<double> &residuals) ;
		virtual inline void IpK_residual(CellState &state, Vector<double> &residuals) ;
		virtual inline void INaL_residual(CellState &state, Vector<double> &residuals) ;
		virtual inline void IKATP_residual(CellState &state, Vector<double> &residuals) ;

		//The current residual functions
		virtual inline void Ca_i_residual(CellState &state, Vector<double> &residuals) ;
		virtual inline void Na_i_residual(CellState &state, Vector<double> &residuals) ;
		virtual inline void K_i_residual(CellState &state, Vector<double> &residuals) ;


		// constants for Tent ventricle model
		double TTCell_Ko;
		double TTCell_Cao;
		double TTCell_Nao;
		double TTCell_Vc;
		double TTCell_Vsr;
		double TTCell_Vss;
		double TTCell_Bufc;
		double TTCell_Kbufc;
		double TTCell_Bufsr;
		double TTCell_Kbufsr;
		double TTCell_Bufss;
		double TTCell_Kbufss;
		double TTCell_Vmaxup;
		double TTCell_Kup;
		double TTCell_Vrel;
		double TTCell_k1_;
		double TTCell_k2_;
		double TTCell_k3;
		double TTCell_k4;
		double TTCell_EC;
		double TTCell_maxsr;
		double TTCell_minsr;
		double TTCell_Vleak;
		double TTCell_Vxfer;
		double TTCell_R;
		double TTCell_F;
		double TTCell_T;
		double TTCell_CAPACITANCE;
		double TTCell_pKNa;
		double TTCell_GbNa;
		double TTCell_KmK;
		double TTCell_KmNa;
		double TTCell_knak;
		double TTCell_GCaL;
		double TTCell_GbCa;
		double TTCell_knaca;
		double TTCell_KmNai;
		double TTCell_KmCa;
		double TTCell_ksat;
		double TTCell_n;
		double TTCell_GpCa;
		double TTCell_KpCa;
		double TTCell_GpK;

		double TTCell_RTONF;
		double TTCell_inverseVcF2;
		double TTCell_inverseVcF;
		double TTCell_inversevssF2;

	private:
		virtual inline double get_GNaL(CellState &state){
			switch(state.cell_type()){
				case 100 : return  0.0065;
				case 101 : return 0.0095;
				case 102 : return 0.0065;
				case 103 : return 0.0065;
				case 104 : return 0.0095;
				case 105 : return 0.0065;
				default : return 0.0;
			}
		}
		virtual inline double get_Gks(CellState &state){
			double Mfactor = 2.0;
			switch(state.cell_type()){
				case 100 : return  0.392 * 1.4;
				case 101 : return 0.098 * Mfactor;
				case 102 : return  0.392;
				case 103 : return 0.392 * 1.4 * (1.0 + 0.8 * state.rv_index());
				case 104 : return 0.098 * Mfactor *  (1.0 + 0.8 * state.rv_index());
				case 105 : return 0.392 * (1.0 + 0.8 * state.rv_index());
				default : return 0.0;
			}
		}

		virtual inline double get_Gto(CellState &state){
			switch(state.cell_type()){
				case 100 : return  0.294;
				case 101 : return 0.294;
				case 102 : return  0.073;
				case 103 : return 0.294 * (1.0 + 0.8 * state.rv_index());
				case 104 : return 0.294 * (1.0 + 0.8 * state.rv_index());
				case 105 : return 0.073 * (1.0 + 0.8 * state.rv_index());
				default : return 0.0;
			}
		}

		virtual inline double get_S_INF(CellState &state){
			double InAcTo_Vhalf_ABh = 0.0;
			double InAcTo_Vk_ABh = 1.0;
			switch(state.cell_type()){
				case 100 : return 1. / (1. + exp((state.vm() + 20 + InAcTo_Vhalf_ABh) / (5.0 * InAcTo_Vk_ABh)));
				case 101 : return 1. / (1. + exp((state.vm() + 20 + InAcTo_Vhalf_ABh) / (5.0 * InAcTo_Vk_ABh)));
				case 102 : return 1. / (1. + exp((state.vm() + 28 + InAcTo_Vhalf_ABh) / (5.0 * InAcTo_Vk_ABh)));
				case 103 : return 1. / (1. + exp((state.vm() + 20 + InAcTo_Vhalf_ABh) / (5.0 * InAcTo_Vk_ABh)));
				case 104 : return 1. / (1. + exp((state.vm() + 20 + InAcTo_Vhalf_ABh) / (5.0 * InAcTo_Vk_ABh)));
				case 105 : return 1. / (1. + exp((state.vm() + 28 + InAcTo_Vhalf_ABh) / (5.0 * InAcTo_Vk_ABh)));
				default : return 0.0;
			}
		}

		virtual inline double get_TAU_S(CellState &state){
			switch(state.cell_type()){
				case 100 : return 85.*exp(-(state.vm() + 45.) * (state.vm() + 45.) / 320.) + 5. / (1. + exp((state.vm() - 20.) / 5.)) + 3.;
				case 101 : return 85.0 * exp(-(state.vm() + 45.) * (state.vm() + 45.) / 320.) + 5. / (1. + exp((state.vm() - 20.) / 5.)) + 3.;
				case 102 : return 1000.*exp(-(state.vm() + 67) * (state.vm() + 67) / 1000.) + 8.;
				case 103 : return 85.*exp(-(state.vm() + 45.) * (state.vm() + 45.) / 320.) + 5. / (1. + exp((state.vm() - 20.) / 5.)) + 3.;
				case 104 : return 85.0 * exp(-(state.vm() + 45.) * (state.vm() + 45.) / 320.) + 5. / (1. + exp((state.vm() - 20.) / 5.)) + 3.;
				case 105 : return 1000.*exp(-(state.vm() + 67) * (state.vm() + 67) / 1000.) + 8.;
				default : return 0.0;
			}
		}

		virtual inline double get_R_INF(CellState &state){
			switch(state.cell_type()){
				case 100 : return 1. / (1. + exp((20 - state.vm()) / 6.));
				case 101 : return 1. / (1. + exp((20 - state.vm()) / 6.));
				case 102 : return 1. / (1. + exp((20 - state.vm()) / 6.));
				case 103 : return 1. / (1. + exp((20 - state.vm()) / 6.));
				case 104 : return 1. / (1. + exp((20 - state.vm()) / 6.));
				case 105 : return 1. / (1. + exp((20 - state.vm()) / 6.));
				default : return 0.0;
			}
		}

		virtual inline double get_TAU_R(CellState &state){
			switch(state.cell_type()){
				case 100 : return 9.5 * exp(-(state.vm() + 40.) * (state.vm() + 40.) / 1800.) + 0.8;
				case 101 : return 9.5 * exp(-(state.vm() + 40.) * (state.vm() + 40.) / 1800.) + 0.8;
				case 102 : return 9.5 * exp(-(state.vm() + 40.) * (state.vm() + 40.) / 1800.) + 0.8;
				case 103 : return 9.5 * exp(-(state.vm() + 40.) * (state.vm() + 40.) / 1800.) + 0.8;
				case 104 : return 9.5 * exp(-(state.vm() + 40.) * (state.vm() + 40.) / 1800.) + 0.8;
				case 105 : return 9.5 * exp(-(state.vm() + 40.) * (state.vm() + 40.) / 1800.) + 0.8;
				default : return 0.0;
			}
		}



		virtual inline double get_Ischemia_TTCell_Ko(CellState &state){
			return TTCell_Ko + state.is_index() * 5.4;;
		}

		virtual inline double get_Acidosis_factor(CellState &state){
			return 1.0  - 0.2 * state.is_index();
		}
	};

}

#endif 