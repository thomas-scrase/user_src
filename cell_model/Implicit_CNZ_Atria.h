#ifndef OOMPH_IMPLICIT_CNZ_ATRIA_HEADER
#define OOMPH_IMPLICIT_CNZ_ATRIA_HEADER

// Config header generated by autoconfig
#ifdef HAVE_CONFIG_H
  #include <oomph-lib-config.h>
#endif

#include "cell_model_base.h"

namespace oomph{

class ImplicitCNZAtria : public CellModelBase
{
public:
	ImplicitCNZAtria();

	// void explicit_timestep(CellState &Cellstate, Vector<double> &new_state);

	inline void return_initial_membrane_potential(double &v, const unsigned &cell_type=0);
	inline bool return_initial_state_variable(const unsigned &n, double &v, const unsigned &cell_type);

	//this can be overloaded in case the membrane capacitance is dependent on cell type or state parameters
	inline double cm(CellState &state);

	inline void custom_output(CellState &state, Vector<double> &output) override {}

	inline bool model_calculates_jacobian_entries() override {return false;}

	inline unsigned Num_Variables(){return 49;}
	//The model is explicit so it requires no derivatives
	inline unsigned required_derivatives(){return 1;}
	inline unsigned required_black_box_parameters(){return 0;}
	inline unsigned required_external_data() {return 0;}


	void fill_in_generic_residual_contribution_cell_base(CellState &state,
														Vector<double> &residuals,
														DenseMatrix<double> &jacobian,
														unsigned flag) override;


	double membrane_current(CellState &state)
	{
		//A vector and matrix to act as the dummy residuals and jacobian
		Vector<double> dummy_res(required_nodal_variables());
		DenseMatrix<double> dummy_jac(required_nodal_variables(),required_nodal_variables());
		//Membrane current is calculated in the fill in function
		fill_in_generic_residual_contribution_cell_base(state,
														dummy_res,
														dummy_jac,
														0);
		return state.get_membrane_current();
	}

	double active_strain(CellState &state)
	{
		//A vector and matrix to act as the dummy residuals and jacobian
		Vector<double> dummy_res(required_nodal_variables());
		DenseMatrix<double> dummy_jac(required_nodal_variables(),required_nodal_variables());
		//Active strain is calculated in the fill in function
		fill_in_generic_residual_contribution_cell_base(state,
														dummy_res,
														dummy_jac,
														0);
		return state.get_active_strain();
	}

private:
	int sign(double a){ return ((a) < (0.) ? (-1.0) : (1.0));}
	double heav(double a){ return ((a) < (0.) ? (0.0) : (1.0));}

	//Constants

	//CNZ constants
	double CRN_vcell;
	double CRN_vi;
	double CRN_vup;
	double CRN_vrel;
	double T;
	double CRN_Tfac;
	double CRN_Csp;
	double F;
	double R;
	double CRN_kb;
	double CRN_nab;
	double CRN_cab;
	double CRN_nac;
	double CRN_cac;
	double CRN_kc;
	double CRN_gna;
	double CRN_gto;
	double CRN_gkr;
	double CRN_gks;
	double CRN_gcaL;
	double CRN_ErL;
	double CRN_gk1;
	double CRN_gbna;
	double CRN_gbk;
	double CRN_gbca;
	double CRN_inakbar;
	double CRN_kmnai;
	double CRN_kmko;
	double CRN_icapbar;
	double CRN_kmcap;
	double CRN_knacalr;
	double CRN_kmnalr;
	double CRN_kmcalr;
	double CRN_ksatlr;
	double CRN_gammalr;
	double CRN_trpnbar;
	double CRN_cmdnbar;
	double CRN_csqnbar;
	double CRN_kmcsqn;
	double CRN_kmcmdn;
	double CRN_kmtrpn;
	double CRN_grelbar;
	double CRN_kmup;
	double CRN_iupbar;
	double CRN_caupmax;
	double CRN_kupleak;
	double CRN_tautr;
	double CRN_gf_na;
	double CRN_gf_k;
	double CRN_gf;
	double CRN_Ef;
	double gcaT;
	double EcaT;
	double MAL_gto;
	double MAL_gkur;
	double CNZ_gkur;

	// New parameters

	double  GONG_gto;
	double  gf;

	// KM model intracellular model parameters
	double Vss;
	double rjunct;
	double lcell;

	double dx;
	double Aj_nj;
	double xj_nj;
	double xj_nj_Nai;

	double Vnonjunct3;
	double VSR3;
	double VSR4;
	double Vcytosol;
	double Vnonjunct_Nai;

	double BCa;
	double SLlow;
	double SLhigh;

	double KdBCa;
	double KdSLlow;
	double KdSLhigh;

	double CSQN;
	double KdCSQN;

	double BNa;
	double KdBNa;

	double DCa;
	double DCaSR;
	double DCaBm;
	double DNa;

	double SERCAKmf;
	double SERCAKmr;
	double k4;
	double k3;
	double k1;
	double k2;
	double cpumps;
	double kSRleak;

	// Fibroblast stuff
	double Cmf;
	double vif;
	double naof;
	double kof;
	double Cm;




	//Rice myofilament constants
	#define p0 1.754251548964904
	#define p1 0.905622641626625
	#define p2 0.499437793063966
	#define p3 0.400000001127317
	#define p4 1.000000000000000
	#define p5 1.000000000000000
	#define p6 1.981229252026256
	#define p7 0.511387864324941
	#define p8 0.023420000000000
	// rolling back to its original value.
	double SLmax  ;
	double SLmin  ;
	double len_thin ;
	double len_thick;
	double len_hbare;
	//   Temperature Dependence
	double Qkon;
	double Qkoff;
	// double Qkoff = 1.4;
	double Qkn_p;
	double Qkp_n;
	double Qfapp;
	// double Qgapp = 6.25;
	double Qgapp;
	double Qhf;
	double Qhb;
	double Qgxb;
	//   Ca binding to troponin
	double kon    ;
	double koffL  ;
	double koffH  ;
	double perm50 ;
	double nperm  ;
	double kn_p   ;
	double kp_n   ;
	double koffmod;
	//   Thin filament regulation and crossbridge cycling
	double fapp   ;
	double gapp   ;
	double gslmod ;
	double hf     ;
	double hfmdc  ;
	double hb     ;
	double hbmdc  ;
	double gxb    ;
	double sigmap ;
	double sigman ;
	double xbmodsp;
	//   Mean strain of strongly-bound states
	double x_0    ;
	double xPsi   ;
	//   Normalized active a nd passive force
	double PCon_t ;
	double PExp_t ;
	double SL_c   ;
	double PCon_c ;
	double PExp_c ;
	//   Calculation of complete muscle response
	double massf  ;
	double visc   ;
	double KSE    ;
	double kxb    ;
	double Trop_conc;
	double Temp;

	double SLset ;         // initial length
    double SLrest;       //   (um) rest SL length for 0 passive force


};


}//end namespace

#endif