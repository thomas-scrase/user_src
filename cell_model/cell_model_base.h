//LIC// ====================================================================
//LIC// Contains the base cell model class along with two simple cell models
//LIC// ZeroCell - purely for testing
//LIC// FitzHighNagumo - an old redundant model also for testing, albeit more
//LIC//		in depth.
//LIC// ====================================================================



#ifndef OOMPH_CELL_MODEL_HEADER
#define OOMPH_CELL_MODEL_HEADER

// Config header generated by autoconfig
#ifdef HAVE_CONFIG_H
  #include <oomph-lib-config.h>
#endif

//OOMPH-LIB includes
#include "../generic/nodes.h"
#include "../generic/oomph_utilities.h"
#include "../generic/matrices.h"
#include "../generic/Qelements.h"
#include "../generic/Telements.h"

#include "cell_state_container.h"

//define a sign and heaviside function for use in rice model
#define rice_sign(a) ((a) < (0.) ? (-1.0) : (1.0))
#define rice_heav(a) ((a) < (0.) ? (0.0) : (1.0))

namespace oomph{

	class CellModelBase
	{
	public:
		CellModelBase();

		virtual ~CellModelBase()	{}

		virtual inline double active_strain(CellState &state)
		{
			std::string error_message =
		    "Active strain has not been implemented for this cell model yet.";
		    
		   throw OomphLibError(error_message,
		                       OOMPH_CURRENT_FUNCTION,
		                       OOMPH_EXCEPTION_LOCATION);
		   return 0.0;
		}

		virtual inline double membrane_current(CellState &state)
		{
			std::string error_message =
		    "Membrane current has not been implemented for this cell model yet.";
		    
		   throw OomphLibError(error_message,
		                       OOMPH_CURRENT_FUNCTION,
		                       OOMPH_EXCEPTION_LOCATION);
		   return 0.0;
		}

		// Calculate the sub residual and sub jacobian objects
		virtual inline void fill_in_generic_residual_contribution_cell_base(CellState &state,
																			Vector<double> &residuals,
																			DenseMatrix<double> &jacobian,
																			unsigned flag)
		{
			throw OomphLibError("fill_in_generic_residual_contribution_cell_base has not been implemented for this cell model yet.",
		                       OOMPH_CURRENT_FUNCTION,
		                       OOMPH_EXCEPTION_LOCATION);
		}

		//====================================================================
		//Access functions for mutation type
		//(Element-wise since we assume all cells are affected by the same mutation)
		//====================================================================
		const unsigned &mutation() const {return *Mutation_pt;}
		unsigned* &mutation_pt() {return Mutation_pt;}

		void set_mutation_pt(unsigned* mutation_pt_){Mutation_pt = mutation_pt_;}

		
		//Access functions for request checks
		const unsigned required_storage() const {return Required_Storage;}
		inline unsigned required_derivatives() const {return Required_Derivatives;}
		bool requires_vm() const {return Requires_Vm;}
		bool requires_strain() const{return Requires_Strain;}
		bool requires_na_o() const{return Requires_Na_o;}
		bool requires_k_o() const{return Requires_K_o;}
		bool requires_ca_o() const{return Requires_Ca_o;}
		bool requires_cell_type() const{return Requires_Cell_Type;}
		bool requires_fibrosis() const{return Requires_Fibrosis;}
		bool requires_ab_index() const{return Requires_AB_Index;}
		bool requires_rv_index() const{return Requires_RV_Index;}
		bool requires_is_index() const{return Requires_IS_Index;}

		
		virtual double cm() const {
			throw OomphLibError("Membrane capacitance has not been implemented for this cell model yet.",
		                       OOMPH_CURRENT_FUNCTION,
		                       OOMPH_EXCEPTION_LOCATION);
		}
	protected:
		//====================================================================
		//Mutation type
		//	Used in switch function with the following correspondence:
		//		0 WT, 1 D322H, 2 E48G, 3 A305T, 4 Y155C, 5 D469E, 6 P488S
		//====================================================================
		unsigned *Mutation_pt;

		//The number of tracked variables required by the model
		unsigned Required_Storage;


		//Bools and unsigneds for what data to request from the cell interface element
		unsigned Required_Derivatives; //number of required derivatives
		bool Requires_Vm; //does the model require membrane potential
		bool Requires_Strain; //does the model require strain
		bool Requires_Na_o; //does the model require external sodium concentration
		bool Requires_K_o; //does the model require external potassium concentration
		bool Requires_Ca_o; //does the model require external calcium concentration
		bool Requires_Cell_Type; //does the model require cell type
		bool Requires_Fibrosis; //does the model require fibrosis type?
		bool Requires_AB_Index; //does the model require ab index
		bool Requires_RV_Index; //does the model require rv index
		bool Requires_IS_Index; //does the model require is index
	};

















	//====================================================================
	//====================================================================
	//Begin the Zero Cell model:
	// an empty cell class for testing if linking between the
	// monodomain elements and cell model interface elements
	// is working correctly.
	//====================================================================
	//====================================================================
	class ZeroCell	:	public CellModelBase
	{
	public:
		ZeroCell() : CellModelBase()
		{
			this->Required_Storage = 1;
		}

		virtual ~ZeroCell()	{}

		virtual double active_strain(CellState &state) const
		{
			return 0.0;
		}

		inline double membrane_current(CellState &state)
		{
			//zero to not affect the monodomain solution
			return 1.0;
		}

		void fill_in_generic_residual_contribution_cell_base(CellState &state,
															Vector<double> &residuals,
															DenseMatrix<double> &jacobian,
															unsigned flag)
		{
			//some function which behaves
			residuals[0] += state.var(1,0) + state.var(0,0)*(state.var(0,0)+1.0);
			if(flag){
				jacobian(0, 0) += state.time_stepper_weights(1,0) + 2*state.var(0,0)+1.0;
			}
		}

		double cm() const {return 1.0;}
	};












	//====================================================================
	//====================================================================
	//Begin the FitzHugh-Nagumo Cell model:
	// a deprecated cell class for testing if linking between the
	// monodomain elements and cell model interface elements
	// is working correctly, and for demonstrating cell model wrappers
	// used during modelling.
	//====================================================================
	//====================================================================
	class FitzHughNagumo	:	public CellModelBase
	{
	public:
		FitzHughNagumo() : CellModelBase()
		{
			this->Required_Storage = 1;
		}

		virtual ~FitzHughNagumo()	{}

		virtual double active_strain(CellState &state) const
		{
			return 0.0;
		}

		inline virtual double potential_forcing_function(CellState &state) const
		{
			return state.vm()*(1.0-state.vm()*state.vm()/3.0);
			// return 0.0;
		}

		inline virtual double variable_forcing_function(CellState &state) const
		{
			return 0.08*(state.vm() + 0.7 - 0.8*state.var(0,0));
			// return 10.0*(state.vm() - potential_scaling() + 0.7 - 0.8*var);
		}

		// The membrane current at the node
		inline double membrane_current(CellState &state)
		{
			return -(potential_forcing_function(state) - state.var(0,0));
		}

		void fill_in_generic_residual_contribution_cell_base(CellState &state,
															Vector<double> &residuals,
															DenseMatrix<double> &jacobian,
															unsigned flag)
		{
			//some function which behaves
			int var_ind = 0;
			residuals[0] += state.var(1,0) - variable_forcing_function(state);
			if(flag){
				jacobian(0, 0) += state.time_stepper_weights(1,0) + 2.0*state.var(0,0)+1.0;
			}
		}

		double cm() const {return 1.0;}

		// double const potential_scaling() const {return -77.079842;}
	};


}

#endif