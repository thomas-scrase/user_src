//LIC// ====================================================================
//LIC// Contains the base cell model class along with two simple cell models
//LIC// ZeroCell - purely for testing
//LIC// FitzHighNagumo - an old redundant model also for testing, albeit more
//LIC//		in depth.
//LIC// ====================================================================



#ifndef OOMPH_CELL_MODEL_HEADER
#define OOMPH_CELL_MODEL_HEADER

// Config header generated by autoconfig
#ifdef HAVE_CONFIG_H
  #include <oomph-lib-config.h>
#endif

//OOMPH-LIB includes
#include "../generic/nodes.h"
#include "../generic/oomph_utilities.h"
#include "../generic/matrices.h"
#include "../generic/Qelements.h"
#include "../generic/Telements.h"

#include "cell_state_container.h"

//define a sign and heaviside function for use in rice model
#define rice_sign(a) ((a) < (0.) ? (-1.0) : (1.0))
#define rice_heav(a) ((a) < (0.) ? (0.0) : (1.0))

namespace oomph{

	class CellModelBase
	{
	public:
		CellModelBase();

		virtual ~CellModelBase()	{}

		//Is the passed cell type compatible with this cell model
		virtual inline bool compatible_cell_types(const unsigned& cell_type){
			throw OomphLibError("Cell types compatible with this model have not been defined",
		                       OOMPH_CURRENT_FUNCTION,
		                       OOMPH_EXCEPTION_LOCATION);
		}

		virtual inline double active_strain(CellState &state)
		{
			std::string error_message =
		    "Active strain has not been implemented for this cell model yet.";
		    
		   throw OomphLibError(error_message,
		                       OOMPH_CURRENT_FUNCTION,
		                       OOMPH_EXCEPTION_LOCATION);
		}

		virtual inline double membrane_current(CellState &state)
		{
			std::string error_message =
		    "Membrane current has not been implemented for this cell model yet.";
		    
		   throw OomphLibError(error_message,
		                       OOMPH_CURRENT_FUNCTION,
		                       OOMPH_EXCEPTION_LOCATION);
		}

		virtual inline void custom_output(CellState &state, Vector<double> &output)
		{
			throw OomphLibError("Custom output has not been implemented yet for this cell model.",
		                       OOMPH_CURRENT_FUNCTION,
		                       OOMPH_EXCEPTION_LOCATION);
		}

		// Calculate the sub residual and sub jacobian objects
		virtual inline void fill_in_generic_residual_contribution_cell_base(CellState &state,
																			Vector<double> &residuals,
																			DenseMatrix<double> &jacobian,
																			unsigned flag)
		{
			throw OomphLibError("fill_in_generic_residual_contribution_cell_base has not been implemented for this cell model yet.",
		                       OOMPH_CURRENT_FUNCTION,
		                       OOMPH_EXCEPTION_LOCATION);
		}

		//====================================================================
		//Access functions for mutation type
		//(Element-wise since we assume all cells are affected by the same mutation)
		//====================================================================
		const unsigned &mutation() const {return *Mutation_pt;}
		unsigned* &mutation_pt() {return Mutation_pt;}

		void set_mutation_pt(unsigned* mutation_pt_){Mutation_pt = mutation_pt_;}

		//====================================================================
		//Acess function to dictate initial conditions of cell model to cell
		//	interface node. Implemented as virutal to be overloaded by each
		//	cell model. cell_type is provided (with default value of 0) for
		//	combined cell model to ensure correct cell model initial condition
		//	is returned. Returns a bool, true if the requested variable number
		//	is used by the cell model, false if it is not and the variable
		//	should be pinned
		//====================================================================
		inline void return_initial_membrane_potential(double &v, const unsigned &cell_type=0){
			throw OomphLibError("Initial membrane potential has not been implemented for this cell model yet",
		                       OOMPH_CURRENT_FUNCTION,
		                       OOMPH_EXCEPTION_LOCATION);
		}
		virtual inline bool return_initial_value(const unsigned &n, double &v, const unsigned &cell_type=0){
			throw OomphLibError("Initial conditions have not been implemented for this cell model yet",
		                       OOMPH_CURRENT_FUNCTION,
		                       OOMPH_EXCEPTION_LOCATION);
		}

		const bool model_calculates_jacobian_entries() const {return Model_Calculates_Jacobian_Entries;}
		
		//Access functions for request checks
		const unsigned required_storage() const {return Required_Storage;}
		inline unsigned required_derivatives() const {return Required_Derivatives;}
		bool requires_vm() const {return Requires_Vm;}
		bool requires_strain() const{return Requires_Strain;}
		bool requires_na_o() const{return Requires_Na_o;}
		bool requires_k_o() const{return Requires_K_o;}
		bool requires_ca_o() const{return Requires_Ca_o;}
		bool requires_cell_type() const{return Requires_Cell_Type;}
		bool requires_fibrosis() const{return Requires_Fibrosis;}
		bool requires_ab_index() const{return Requires_AB_Index;}
		bool requires_rv_index() const{return Requires_RV_Index;}
		bool requires_is_index() const{return Requires_IS_Index;}
		bool requires_dt() const{return Requires_dt;}
		bool requires_previous_values() const{return Requires_previous_values;}

		
		virtual double cm() const {
			throw OomphLibError("Membrane capacitance has not been implemented for this cell model yet.",
		                       OOMPH_CURRENT_FUNCTION,
		                       OOMPH_EXCEPTION_LOCATION);
		}
	protected:

		//Does the cell model calculate entries of the jacobian matrix
		bool Model_Calculates_Jacobian_Entries;

		//====================================================================
		//Mutation type
		//	Used in switch function with the following correspondence:
		//		0 WT, 1 D322H, 2 E48G, 3 A305T, 4 Y155C, 5 D469E, 6 P488S
		//====================================================================
		unsigned *Mutation_pt;

		//The number of tracked variables required by the model
		unsigned Required_Storage;


		//Bools and unsigneds for what data to request from the cell interface element
		unsigned Required_Derivatives; //number of required derivatives
		bool Requires_Vm; //does the model require membrane potential
		bool Requires_Strain; //does the model require strain
		bool Requires_Na_o; //does the model require external sodium concentration
		bool Requires_K_o; //does the model require external potassium concentration
		bool Requires_Ca_o; //does the model require external calcium concentration
		bool Requires_Cell_Type; //does the model require cell type
		bool Requires_Fibrosis; //does the model require fibrosis type?
		bool Requires_AB_Index; //does the model require ab index
		bool Requires_RV_Index; //does the model require rv index
		bool Requires_IS_Index; //does the model require is index

		bool Requires_dt; //does the model use an explicit time-stepping method and hence require the temporal increment
		bool Requires_previous_values; //does the model require the previous time values of variables? Generally used by explicit time stepping methods
	};

















	//====================================================================
	//====================================================================
	//Begin the Zero Cell model:
	// an empty cell class for testing if linking between the
	// monodomain elements and cell model interface elements
	// is working correctly.
	//====================================================================
	//====================================================================
	class ZeroCell	:	public CellModelBase
	{
	public:
		ZeroCell() : CellModelBase()
		{
			this->Required_Storage = 1;
		}

		virtual ~ZeroCell()	{}

		bool compatible_cell_types(const unsigned& cell_type){return true;}

		virtual double active_strain(CellState &state) const
		{
			return 0.0;
		}

		inline double membrane_current(CellState &state)
		{
			//zero to not affect the monodomain solution
			return 1.0;
		}

		virtual inline void custom_output(CellState &state, Vector<double> &output)
		{
			//Intentionally returns nothing
		}

		void fill_in_generic_residual_contribution_cell_base(CellState &state,
															Vector<double> &residuals,
															DenseMatrix<double> &jacobian,
															unsigned flag)
		{
			//some function which behaves
			residuals[0] += state.var(1,0) + state.var(0,0)*(state.var(0,0)+1.0);
			if(flag){
				jacobian(0, 0) += state.time_stepper_weights(1,0) + 2*state.var(0,0)+1.0;
			}
		}

		inline bool return_initial_value(const unsigned &n, double &v, const unsigned &cell_type=0){
			switch(n){
				case 0 : {
					v = 1.0;
					return true;
				}
				default : {
					return false;
				}
			}
		}

		double cm() const {return 1.0;}
	};












	//====================================================================
	//====================================================================
	//Begin the FitzHugh-Nagumo Cell model:
	// a deprecated cell class for testing if linking between the
	// monodomain elements and cell model interface elements
	// is working correctly, and for demonstrating cell model wrappers
	// used during modelling.
	//====================================================================
	//====================================================================
	class FitzHughNagumo	:	public CellModelBase
	{
	public:
		FitzHughNagumo() : CellModelBase()
		{
			this->Required_Storage = 1;
		}

		virtual ~FitzHughNagumo()	{}

		bool compatible_cell_types(const unsigned& cell_type){return true;}

		virtual double active_strain(CellState &state) const
		{
			return 0.0;
		}

		inline virtual double potential_forcing_function(CellState &state) const
		{
			return state.vm()*(1.0-state.vm()*state.vm()/3.0);
			// return 0.0;
		}

		inline virtual double variable_forcing_function(CellState &state) const
		{
			return 0.08*(state.vm() + 0.7 - 0.8*state.var(0,0));
			// return 10.0*(state.vm() - potential_scaling() + 0.7 - 0.8*var);
		}

		// The membrane current at the node
		inline double membrane_current(CellState &state)
		{
			return -(potential_forcing_function(state) - state.var(0,0));
		}

		virtual inline void custom_output(CellState &state, Vector<double> &output)
		{
			//Intentionally does nothing
		}

		void fill_in_generic_residual_contribution_cell_base(CellState &state,
															Vector<double> &residuals,
															DenseMatrix<double> &jacobian,
															unsigned flag)
		{
			//some function which behaves
			int var_ind = 0;
			residuals[0] += state.var(1,0) - variable_forcing_function(state);
			if(flag){
				jacobian(0, 0) += state.time_stepper_weights(1,0) + 2.0*state.var(0,0)+1.0;
			}
		}

		virtual inline bool return_initial_value(const unsigned &n, double &v, const unsigned &cell_type=0){
			switch(n){
				case 0 : {
					v = 0.0;
					return true;
				}
				default : {
					return false;
				}
			}
		}

		double cm() const {return 1.0;}

		// double const potential_scaling() const {return -77.079842;}
	};







	//====================================================================
	//====================================================================
	//Explicit time-stepping cell model base
	//	Base for cell models which make explicit time steps, benefits from
	//	needing to make comparatively few changes to already hard coded cell
	//	models when compared to a full convert to oomph-lib style computation.
	//Drawbacks are that benefits of oomph-lib's automatic error computation
	//	are lost, since an explicit scheme is used, the residual no longer
	//	represents the error in the solution but instead the difference between
	//	the value computed by the explicit timestepping function and the current
	//	value at the node.
	//====================================================================
	//====================================================================
	class ExplicitTimeStepCellModelBase : public CellModelBase
	{
	public:
		//Constructor
		ExplicitTimeStepCellModelBase(){
			//Jacobian is simply identity
			Model_Calculates_Jacobian_Entries = true;
			Requires_dt = true;
			Requires_previous_values = true;
		}

		double active_strain(CellState &state)
		{
			Vector<double> DummyVector;
			DummyVector.resize(this->Required_Storage);
			//Compute the cell model explicit timestep
			explicit_timestep(state, DummyVector);
			//Return the calculated cell model strain
			return state.cell_model_strain();
		}

		double membrane_current(CellState &state)
		{
			Vector<double> DummyVector;
			DummyVector.resize(this->Required_Storage);
			//Compute the cell model explicit timestep
			explicit_timestep(state, DummyVector);
			//Return the caclulated cell model current
		   return state.cell_membrane_current();
		}

		// Calculate the sub residual and sub jacobian objects
		void fill_in_generic_residual_contribution_cell_base(CellState &state,
															Vector<double> &residuals,
															DenseMatrix<double> &jacobian,
															unsigned flag)
		{
			//create vector for the next state of the cell variables
			Vector<double> new_state;
			new_state.resize(this->Required_Storage);
			//set new_state = cell variables at previous timestep
			for(unsigned i=0; i<this->Required_Storage; i++){
				new_state[i] = state.previous_variables(i);
			}

			unsigned N = 1;
			if(state.dt() > intrinsic_dt){
				//The smallest integer N such that Ndt_new = dt_old and dt_new < dt_intrinsic
				N = std::floor(state.dt()/intrinsic_dt)+1;
				//set state dt = dt/N
				double dt_new = state.dt()/N;
				state.set_dt(dt_new);
			}

			//solve the explicit time step problem N times
			for(unsigned i=0; i<N; i++){
				//calculate the next time values of the cell variables
				explicit_timestep(state, new_state);
			}

			//contribute to the residuals: explicit calculated current value - what the node thinks the current value is
			for(unsigned i=0; i<this->Required_Storage; i++){
				residuals[i] -= new_state[i] - state.var(0,i);
				//Contribution to jacobian is just identity since new_state[i] is not dependent on the current state in time, but the previous one
				if(flag){
					jacobian(i,i) = 1.0;
				}
			}

		}

		//The explicit time step taken by the original cell model
		virtual void explicit_timestep(CellState &state, Vector<double> &new_state){
			std::string error_message = "Explicit_timestep has not been implemented for this ExplicitTimeStepCellModel type cell model yet\n";
			error_message += ". In order to use this cell model you must overload this function to a suitably modified version of your cell model time stepper.\n";
			error_message += "For details on requirements see Thomas M A Scrase PhD Thesis.";
			throw OomphLibError(error_message,
		                       OOMPH_CURRENT_FUNCTION,
		                       OOMPH_EXCEPTION_LOCATION);
		}

	protected:
		//The largest dt which ensures convergence of the method,
		//	must be implemented by the user who defined the cell
		//	model
		double intrinsic_dt;

	};



	//====================================================================
	//====================================================================
	//Combined cell model, useful for computations over an entire organ
	//	i.e. atria computed by CNZ and ventricles by TNNP
	//	This way multiple cell meshes are not required.
	//====================================================================
	//====================================================================
	template<class CELL_MODEL_1, class CELL_MODEL_2>
	class CombinedCellModel :	public CELL_MODEL_1,
								public CELL_MODEL_2
	{
	public:
		CombinedCellModel() :	CELL_MODEL_1(), CELL_MODEL_2()
		{
			this->Required_Storage = std::max(CELL_MODEL_1::Required_Storage, CELL_MODEL_2::Required_Storage);
		}

		//Identify the cell model which is to be used in the subsequent computation:
		//	by default this function will simply check if the passed cell type compatible
		//	with both cell models. If it is only compatible with one then return true for
		//	CELL_MODEL_1, or false for CELL_MODEL_2. If it is compatible with both then
		//	in DPARANOID throw an error.
		//	Implemented as virtual so that user defined cell type distributions over
		//	the cell models can be used
		//		i.e. both models are of atria type but right atrium is to be computed
		//		by CELL_MODEL_2 and the rest is to be computed by CELL_MODEL_1
		virtual inline bool Identify_Correct_Cell_Model(const unsigned& cell_type){
			#ifdef DPARANOID
			if(CELL_MODEL_1::compatible_cell_types(cell_type) and CELL_MODEL_2::compatible_cell_types(cell_type)){
				throw OomphLibError("Cell type is compatible with both cell models, since paranoid is enabled I\n
									am killing the process. Please use non-overlapping cell models or alternatively redefine this function to\n
									a user defined cell type distribution",
		                       OOMPH_CURRENT_FUNCTION,
		                       OOMPH_EXCEPTION_LOCATION);
			}
			#endif
			
			if(CELL_MODEL_1::compatible_cell_types(cell_type)){
				return true;
			}
			if(CELL_MODEL_2::compatible_cell_types(cell_type)){
				return false;
			}

			//if we get here then neither cell model can handle the passed cell type
			throw OomphLibError("Cell type is not compatible with either cell model",
		                       OOMPH_CURRENT_FUNCTION,
		                       OOMPH_EXCEPTION_LOCATION);

		}


		double active_strain(CellState &state)
		{
			if(Identify_Correct_Cell_Model(state.cell_type())){
				return CELL_MODEL_1::active_strain(state);
			}
			else{
				return CELL_MODEL_2::active_strain(state);
			}
		}

		double membrane_current(CellState &state)
		{
			if(Identify_Correct_Cell_Model(state.cell_type())){
				return CELL_MODEL_1::membrane_current(state);
			}
			else{
				return CELL_MODEL_2::membrane_current(state);
			}
		}

		virtual inline void custom_output(CellState &state, Vector<double> &output)
		{
			if(Identify_Correct_Cell_Model(state.cell_type())){
				CELL_MODEL_1::custom_output(state, output);
			}
			else{
				CELL_MODEL_2::custom_output(state, output);
			}
		}

		// Calculate the sub residual and sub jacobian objects
		void fill_in_generic_residual_contribution_cell_base(CellState &state,
															Vector<double> &residuals,
															DenseMatrix<double> &jacobian,
															unsigned flag)
		{
			if(Identify_Correct_Cell_Model(state.cell_type())){
				CELL_MODEL_1::fill_in_generic_residual_contribution_cell_base(state,residuals, jacobian, flag);
			}
			else{
				CELL_MODEL_2::fill_in_generic_residual_contribution_cell_base(state,residuals, jacobian, flag);
			}
		}

		virtual inline void return_initial_membrane_potential(double &v, const unsigned &cell_type=0){
			if(Identify_Correct_Cell_Model(cell_type)){
				CELL_MODEL_1::return_initial_membrane_potential(v, cell_type);
			}
			else{
				CELL_MODEL_2::return_initial_membrane_potential(v, cell_type);
			}
		}

		virtual inline bool return_initial_value(const unsigned &n, double &v, const unsigned &cell_type=0){
			if(Identify_Correct_Cell_Model(cell_type)){
				return CELL_MODEL_1::return_initial_value(n, v, cell_type);
			}
			else{
				return CELL_MODEL_2::return_initial_value(n, v, cell_type);
			}
		}

	};


}

#endif