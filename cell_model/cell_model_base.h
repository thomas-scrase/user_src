//LIC// ====================================================================
//LIC// Contains the base cell model class along with two simple cell models
//LIC// ZeroCell - purely for testing
//LIC// FitzHighNagumo - an old redundant model also for testing, albeit more
//LIC//		interesting
//LIC// ====================================================================



#ifndef OOMPH_CELL_MODEL_HEADER
#define OOMPH_CELL_MODEL_HEADER

// Config header generated by autoconfig
#ifdef HAVE_CONFIG_H
  #include <oomph-lib-config.h>
#endif

//OOMPH-LIB includes
#include "../generic/nodes.h"
#include "../generic/oomph_utilities.h"
#include "../generic/matrices.h"
#include "../generic/Qelements.h"
#include "../generic/Telements.h"

#include "cell_state_container.h"

//define a sign and heaviside function for use in rice model
#define rice_sign(a) ((a) < (0.) ? (-1.0) : (1.0))
#define rice_heav(a) ((a) < (0.) ? (0.0) : (1.0))

namespace oomph{

	//The base cell model class. By default it is implemented as entirely broken.
	//	This ensures that whowever is making a new cell model specifies all the
	//	necessary members
	//====================================================================
	//====================================================================
	//By default this is an explicit time-stepping cell model
	//	Base for cell models which make explicit time steps, benefits from
	//	needing to make comparatively few changes to already hard coded cell
	//	models when compared to a full convert to oomph-lib style computation.
	//Drawbacks are that benefits of oomph-lib's automatic error computation
	//	are lost, since an explicit scheme is used, the residual no longer
	//	represents the error in the solution but instead the difference between
	//	the value computed by the explicit timestepping function and the current
	//	value at the node. Further, the entire explicit timestep is required
	//	to be computed when calculating active strain and membrane current which
	//	is likely to reduce efficiency
	//Benefits include a very easily invertible jacobian, since only
	//	diagonal entries are filled and ease of use by the user
	//====================================================================
	//====================================================================
	class CellModelBase
	{
	public:
		CellModelBase()	:	Mutation_pt(0), Intrinsic_dt(0.0) {}

		virtual ~CellModelBase()	{}

		//Is the passed cell type compatible with this cell model
		virtual inline bool compatible_cell_types(const unsigned& cell_type){
			throw OomphLibError("Cell types compatible with this model have not been defined yet",
		                       OOMPH_CURRENT_FUNCTION,
		                       OOMPH_EXCEPTION_LOCATION);
		}

		//Return the total membrane current when requested by the interace element
		//	default implementation assumes an explicit timestepping method, implemented
		//	as virtual to allow a user to implement an implicit method
		virtual inline double membrane_current(CellState &state)
		{
			Vector<double> DummyVector;
			DummyVector.resize(Num_Variables());
			//set DummyVector = cell variables at previous timestep
			for(unsigned i=0; i<Num_Variables(); i++){
				// DummyVector[i] = state.get_previous_variables(i);
				DummyVector[i] = state.get_var(0,i);
			}
			double dt_old = state.get_dt();
			state.set_dt(0.0);
			//Compute the cell model explicit timestep
			explicit_timestep(state, DummyVector);
			state.set_dt(dt_old);
			// std::exit(0);
			//Return the caclulated cell model current
			return state.get_membrane_current();
		}


		//Return the active strain when requested by the interace element
		//	default implementation assumes an explicit timestepping method, implemented
		//	as virtual to allow a user to implement an implicit method
		virtual inline double active_strain(CellState &state)
		{
			Vector<double> DummyVector;
			DummyVector.resize(Num_Variables());
			//set DummyVector = cell variables at previous timestep
			for(unsigned i=0; i<Num_Variables(); i++){
				// DummyVector[i] = state.get_previous_variables(i);
				DummyVector[i] = state.get_var(0,i);
			}
			double dt_old = state.get_dt();
			state.set_dt(0.0);
			//Compute the cell model explicit timestep with a dummy vector
			explicit_timestep(state, DummyVector);
			state.set_dt(dt_old);
			//Return the calculated cell model strain
			return state.get_active_strain();
		}

		//return the membrane capacitane of the model for the provided state
		// virtual inline double cm(CellState &state) {
		// 	throw OomphLibError("Membrane capacitance has not been implemented for this cell model yet.",
		//                        OOMPH_CURRENT_FUNCTION,
		//                        OOMPH_EXCEPTION_LOCATION);
		// }
		
		//Get the custom output for the cell model, this could be specific ion currents, 
		//	conductances, whatever the user wants. By default it is broken, in an explicit
		//	method it should make use of the Cell State General_cell_model_data
		virtual inline void custom_output(CellState &state, Vector<double> &output)
		{
			throw OomphLibError("Custom output has not been implemented yet for this cell model.",
		                       OOMPH_CURRENT_FUNCTION,
		                       OOMPH_EXCEPTION_LOCATION);
		}

		// Calculate the sub residual and sub jacobian objects.
		// By default this is assumes the cell model to be an explicit method. however
		// it mplemented as virtual to allow for overloading when a user wants to implement a explicit model
		virtual inline void fill_in_generic_residual_contribution_cell_base(CellState &state,
																			Vector<double> &residuals,
																			DenseMatrix<double> &jacobian,
																			unsigned flag)
		{
			//create vector for the previous state of the cell variables
			Vector<double> new_state;
			new_state.resize(Num_Variables());
			//set new_state = cell variables at previous timestep
			for(unsigned i=0; i<Num_Variables(); i++){
				new_state[i] = state.get_previous_variables(i);
			}

			//Work out whether a smaller dt is required by the explicit time stepper
			//	if so, set dt to the largest value smaller than the current dt
			//	which divides the original dt by an integer number
			unsigned N = 1;
			if(state.get_dt() > Intrinsic_dt){
				//The smallest integer N such that Ndt_new = dt_old and dt_new < dt_intrinsic
				N = std::floor(state.get_dt()/Intrinsic_dt)+1;
				//set state dt = dt/N
				double dt_new = state.get_dt()/N;
				state.set_dt(dt_new);
			}

			// std::cout << "solving " << N << " times, with step of " << state.get_dt() << " for a total step length of " << N*state.get_dt() << std::endl;

			//solve the explicit time step problem N times
			for(unsigned i=0; i<N; i++){
				// std::cout << "Solving cell model with dt=" << state.get_dt() << std::endl;
				//calculate the next time values of the cell variables
				explicit_timestep(state, new_state);
			}

			//contribute to the residuals: explicit calculated current value - what the node thinks the current value is
			for(unsigned i=0; i<Num_Variables(); i++){
				// std::cout << "residual and jacobian " << i << std::endl;
				residuals[i] = -( new_state[i] - state.get_var(0,i) );
				// if(residuals[i]>1e-9){std::cout << residuals[i] << std::endl;}
				//Contribution to jacobian is just identity since new_state[i] is not dependent on the current state in time, but the previous one
				if(flag){
					jacobian(i,i) = 1.0;
				}
			}
		}

		//The explicit time step taken by the cell model, this is used by default.
		//New state is the cell state variables to be found, it is also the previous
		//	timestep in the weakly coupled timestepping method, at each stage
		//	new_state[i] = new_state[i] + dt*f(new_state);
		//	is calculated.
		//In the case of an implicit cell model this function will not be called.
		// Instead, fill in residual and jacobian procedure will be overridden
		// to perform the necessary calculations
		virtual void explicit_timestep(CellState &state, Vector<double> &new_state){
			std::string error_message = "Explicit_timestep has not been implemented for this Cell Model yet\n";
			error_message += ". In order to use this cell model you must overload this function to a suitably modified version of your cell model time stepper.\n";
			error_message += "For details on requirements see Thomas M A Scrase PhD Thesis.";
			throw OomphLibError(error_message,
		                       OOMPH_CURRENT_FUNCTION,
		                       OOMPH_EXCEPTION_LOCATION);
		}

		//====================================================================
		//Access functions for mutation type
		//(Element-wise since we assume all cells are affected by the same mutation)
		//====================================================================
		const std::string &mutation() const {return *Mutation_pt;}
		std::string* &mutation_pt() {return Mutation_pt;}

		void set_mutation_pt(std::string* mutation_pt_){Mutation_pt = mutation_pt_;}

		//====================================================================
		//Acess function to dictate initial conditions of cell model to cell
		//	interface node. Implemented as virutal to be overloaded by each
		//	cell model. cell_type is provided (with default value of 0) for
		//	combined cell model to ensure correct cell model initial condition
		//	is returned. Returns a bool, true if the requested variable number
		//	is used by the cell model, false if it is not and the variable
		//	should be pinned
		//====================================================================
		virtual inline void return_initial_membrane_potential(double &v, const unsigned &cell_type=0){
			throw OomphLibError("Initial membrane potential has not been implemented for this cell model yet",
		                       OOMPH_CURRENT_FUNCTION,
		                       OOMPH_EXCEPTION_LOCATION);
		}
		//if the requested variable number has no default initial state, then it is assumed to not be
		//	useful and is pinned by the cell interface element
		virtual inline bool return_initial_state_variable(const unsigned &n, double &v, const unsigned &cell_type=0){
			throw OomphLibError("Initial conditions have not been implemented for this cell model yet",
		                       OOMPH_CURRENT_FUNCTION,
		                       OOMPH_EXCEPTION_LOCATION);
		}

		//We assume that the model calculates jacobian entries
		virtual inline bool model_calculates_jacobian_entries() {return true;}

		virtual inline unsigned Num_Variables(){
			throw OomphLibError("The amount of storage required for this model to function has not been defined for this cell model yet",
		                       OOMPH_CURRENT_FUNCTION,
		                       OOMPH_EXCEPTION_LOCATION);
		}
		
		//How many nodal variables does the cell model need?
		//Cell type is provided as an argument so that interface element can
		//	provide the correct amount of storage for each node and so that combined
		//	cell model class can pick the correct cell model required nodal variables
		virtual inline unsigned required_nodal_variables() {
			return Num_Variables();
		}
		virtual inline unsigned required_derivatives() {
			throw OomphLibError("The number of derivatives required for this model to function has not been defined for this cell model yet",
		                       OOMPH_CURRENT_FUNCTION,
		                       OOMPH_EXCEPTION_LOCATION);
		}
		
		virtual inline unsigned required_black_box_parameters() {
			throw OomphLibError("The number of black box nodal parameters required for this model to function has not been defined for this cell model yet",
		                       OOMPH_CURRENT_FUNCTION,
		                       OOMPH_EXCEPTION_LOCATION);
		}

		virtual inline unsigned required_external_data() {
			throw OomphLibError("The number of external data required for this model to function has not been defined for this cell model yet",
		                       OOMPH_CURRENT_FUNCTION,
		                       OOMPH_EXCEPTION_LOCATION);
		}
	
	protected:

		//====================================================================
		//Mutation type
		//	Used in switch function with the following correspondence:
		//		0 WT, 1 D322H, 2 E48G, 3 A305T, 4 Y155C, 5 D469E, 6 P488S
		//====================================================================
		std::string *Mutation_pt;

		//The largest dt which ensures convergence of the method,
		//	must be implemented by the user who defined the cell
		//	model
		double Intrinsic_dt;
	};







	//====================================================================
	//====================================================================
	//Combined cell model, useful for computations over an entire organ
	//	i.e. atria computed by CNZ and ventricles by TNNP
	//	This way multiple cell meshes are not required.
	//====================================================================
	//====================================================================
	template<class CELL_MODEL_1, class CELL_MODEL_2>
	class CombinedCellModel :	public CELL_MODEL_1,
								public CELL_MODEL_2
	{
	public:
		CombinedCellModel() :	CELL_MODEL_1(), CELL_MODEL_2(){ }

		//Identify the cell model which is to be used in the subsequent computation:
		//	by default this function will simply check if the passed cell type compatible
		//	with both cell models. If it is only compatible with one then return true for
		//	CELL_MODEL_1, or false for CELL_MODEL_2. If it is compatible with both then
		//	in PARANOID throw an error.
		//	Implemented as virtual so that user defined cell type distributions over
		//	the cell models can be used
		//		i.e. both models are of atria type but right atrium is to be computed
		//		by CELL_MODEL_2 and the rest are to be computed by CELL_MODEL_1
		virtual inline bool Identify_Correct_Cell_Model(const unsigned& cell_type){
			#ifdef PARANOID
			if(CELL_MODEL_1::compatible_cell_types(cell_type) and CELL_MODEL_2::compatible_cell_types(cell_type)){
				throw OomphLibError("Cell type is compatible with both cell models, since paranoid is enabled I\n"
									"am killing the process. Please use non-overlapping cell models or alternatively redefine this function to\n"
									"a user defined cell type distribution",
		                       OOMPH_CURRENT_FUNCTION,
		                       OOMPH_EXCEPTION_LOCATION);
			}
			#endif
			
			if(CELL_MODEL_1::compatible_cell_types(cell_type)){
				return true;
			}
			if(CELL_MODEL_2::compatible_cell_types(cell_type)){
				return false;
			}

			//if we get here then neither cell model can handle the passed cell type
			throw OomphLibError("Cell type is not compatible with either cell model",
		                       OOMPH_CURRENT_FUNCTION,
		                       OOMPH_EXCEPTION_LOCATION);

		}
		//return the correct model's membrane current
		double membrane_current(CellState &state)
		{
			if(Identify_Correct_Cell_Model(state.get_cell_type())){
				return CELL_MODEL_1::membrane_current(state);
			}
			else{
				return CELL_MODEL_2::membrane_current(state);
			}
		}
		//return the correct model's active strain
		double active_strain(CellState &state)
		{
			if(Identify_Correct_Cell_Model(state.get_cell_type())){
				return CELL_MODEL_1::active_strain(state);
			}
			else{
				return CELL_MODEL_2::active_strain(state);
			}
		}

		//return the correct model's membrane capacitance
		// double cm(CellState &state) {
		// 	if(Identify_Correct_Cell_Model(state.get_cell_type())){
		// 		return CELL_MODEL_1::cm(state);
		// 	}
		// 	else{
		// 		return CELL_MODEL_2::cm(state);
		// 	}
		// }

		inline void custom_output(CellState &state, Vector<double> &output)
		{
			if(Identify_Correct_Cell_Model(state.get_cell_type())){
				CELL_MODEL_1::custom_output(state, output);
			}
			else{
				CELL_MODEL_2::custom_output(state, output);
			}
		}

		// Calculate the sub residual and sub jacobian objects
		void fill_in_generic_residual_contribution_cell_base(CellState &state,
															Vector<double> &residuals,
															DenseMatrix<double> &jacobian,
															unsigned flag)
		{
			if(Identify_Correct_Cell_Model(state.get_cell_type())){
				CELL_MODEL_1::fill_in_generic_residual_contribution_cell_base(state,residuals, jacobian, flag);
			}
			else{
				CELL_MODEL_2::fill_in_generic_residual_contribution_cell_base(state,residuals, jacobian, flag);
			}
		}

		inline void return_initial_membrane_potential(double &v, const unsigned &cell_type=0){
			if(Identify_Correct_Cell_Model(cell_type)){
				CELL_MODEL_1::return_initial_membrane_potential(v, cell_type);
			}
			else{
				CELL_MODEL_2::return_initial_membrane_potential(v, cell_type);
			}
		}

		inline bool return_initial_state_variable(const unsigned &n, double &v, const unsigned &cell_type=0){
			if(Identify_Correct_Cell_Model(cell_type)){
				return CELL_MODEL_1::return_initial_state_variable(n, v, cell_type);
			}
			else{
				return CELL_MODEL_2::return_initial_state_variable(n, v, cell_type);
			}
		}

		
		//It would be very difficult to write a cell model which performs automatic Jacobian fill in
		//	via finite differencing for some nodes and not for others. For this reason this flag is
		//	only set to true if both models can calculate residuals
		inline bool model_calculates_jacobian_entries() {
			if(CELL_MODEL_1::model_calculates_jacobian_entries() && CELL_MODEL_2::model_calculates_jacobian_entries()){
				return true;
			}
		 	else{
		 		return false;
		 	}
		}
		//Return the maximum required storage
		inline unsigned required_nodal_variables(){
			return std::max(CELL_MODEL_1::Num_Variables(),CELL_MODEL_2::Num_Variables());
		}
		//return the maximum number of required derivatives
		inline unsigned required_derivatives(const unsigned &cell_type=0){
			if(Identify_Correct_Cell_Model(cell_type)){
				return CELL_MODEL_1::required_derivatives();
			}
			else{
				return CELL_MODEL_2::required_derivatives();
			}
		}
		//return the maximum number of required black box parameters
		inline unsigned required_black_box_parameters(){
			return std::max(CELL_MODEL_1::required_black_box_parameters(),CELL_MODEL_2::required_black_box_parameters());
		}
	};





}

#endif