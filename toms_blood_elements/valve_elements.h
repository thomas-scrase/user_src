//Handles boundary between two Navier-Stokes fluid domain separated by a valve.
//Valve element handles valve variables e.g. open fraction
//Valve face elements handle enforcing flow rate between elements in the two domains.

//Create Valve mesh
//Add valve element
//Add valve face elements - passing reference to valve element
//Valve element calculates 'Ball' which contains all valve face elements.

//Valve element communicates open fraction to face elements, if an integral point
//	in a face element is outside of this open fraction then zero flow is enforced

//Face elements communicate some measure of trans-valvular pressure to the valve element
//	which is used to calculate valve opening and closing dynamics


//ALTERNATIVELY

//Instead of imposing zero flow outside of the open fraction, enforce that total flow
//	through all valve face elements is equal to that given by an idealised model
//	e.g. Mynard or Darcey (Not really applicable, but modelling a valve as a flow restricting porous medium might work)
//This model of valve blood flow is more restrictive in that flow is prescribed but could be a nice verification method
//	However this method will require a hijacking of a fluid degree of freedom



#ifndef OOMPH_VALVE_ELEMENTS_HEADER
#define OOMPH_VALVE_ELEMENTS_HEADER

// Config header generated by autoconfig
#ifdef HAVE_CONFIG_H
	#include <oomph-lib-config.h>
#endif

#include "one_dimensional_navier_stokes_continuity_elements.h"

namespace oomph{

template<class ELEMENT, unsigned DIM>
class ValveElement :
	public OneDimensionalNavierStokesContinuityElement
{

	//Needs storage for:
	// Valve centre
	// Valve max area / max radius
	// Min effective area coefficient - 0: close completely
	// Max effective area coefficient - 1: opens fully
	// Open/closed ratio - Dof
	// ValveFaceElements which make up this valve

	//Needs fcts for:
	// Get Inlet/Outlet pressure
	// Prescribed Inlet/outlet pressure fct pt
	// Is a given coordinate in the open or closed section, if |x-r_c| > R_eff,max?
	// Add face element - called when constructing a ValveFaceElement
	// Calculate centre and max area/radius of valve - only perform
	//  once at the start of simulation
	// Flush ValveFaceElements - used in mesh refinement

private:

	//The centre and maximum squared radius of the valve,
	//	should be calculated only once to avoid odd discontinuities
	//	during simulation.
	Vector<double> Valve_Centre(DIM);
	double Max_Squared_Radius;

	//The minimum and maximum effective area coefficients of the valve
	//	Used in solution of the equation for the time-dependent open
	//	fraction variable. Supplied as AREA coefficients instead of radius
	double Min_Effective_Area_Coefficient;
	double Max_Effective_Area_Coefficient;

	//There is no difference in the way the two face meshes are handled, the names
	//	are just there to distinguish between them.

	Mesh* InletMeshPt;

	Mesh* OutletMeshPt;


	//Pointer to function which prescribes pressure at location x on the valve
	//	We only allow for a maximum of 1 function prescribing pressure since
	//	the flow is never prescribed on both sides of the valve. The element will
	//	automatically assume the function prescribes pressure on the side which has
	//	no associated elements.
	ValveElementPrescribedPressureFctPt PrescribedPressureFctPt;

	//Pointer to the prescribed total volume flow. Only used if there are no elements on
	//	one side of the valve. Used in conjunction with the prescribed pressure. 
	ValveElementPrescribedTotalVolumeFlowFctPt PrescribedVolumeFlowFctPt;

	//Safely access the prescribed pressure function pointer
	inline void get_prescribed_pressure(const Vector<double>& x,
										double& p){
		if(PrescribedPressureFctPt!=0){
			(*PrescribedPressureFctPt)(0.0, x, p);
		}
		else{
			p=0.0;
		}
	}


	//Flush the references to inlet and outlet face elements
	//	used during mesh refinement when face elements need
	//	to be rebuilt
	void Flush_Inlet_Valve_Face_Mesh(){
		// ValveInletFaceElements.clear();
		// ValveInletFaceElements.resize(0);
		InletMeshPt.free();
	}
	void Flush_Outlet_Valve_Face_Mesh(){
		// ValveOutletFaceElements.clear();
		// ValveOutletFaceElements.resize(0);
		OutletMeshPt.free();
	}

	//Calculate the centre of the valve and the maximum radius required
	//	to encompass all supplied face elements. Should only be performed once
	//	when the valve is first generated before any simulations or discontinuities
	//	could be introduced
	void Calculate_Centre_And_Max_Radius();

	//Calculate the squared radial distance of the point x from the centre of the valve
	void Calculate_Radial_Distance_At_Point(const Vector<double>& x,
											double& r){
	#ifdef DPARANOID
		if(x.size()!=DIM){
			throw OomphLibError(
			    "Dimension of passed coordinates is not equal to dimension of ValveElement",
			    OOMPH_CURRENT_FUNCTION,
			    OOMPH_EXCEPTION_LOCATION);
		}
	#endif

		//zero r
		r=0.0;
		//Calcualte squared L2 norm on (x-Centre)
		for(unsigned i=0; i<DIM; i++){
			r += pow((x[i]-Valve_Centre[i]),2.0);
		}
	}

	//Return the current valve square radius calculated from max radius and open fraction
	double Current_Valve_Radius(){
		return 	(Max_Effective_Area_Coefficient*Max_Squared_Radius
					-Min_Effective_Area_Coefficient*Max_Squared_Radius)*open_fraction()
				+Min_Effective_Area_Coefficient*Max_Squared_Radius;
	}

	ValveElementMeasureOfPressureFromMeshFctPt MeasureOfPressureFromMeshFctPt;

	//Calculate the measure of pressure at one of the face meshes, if mesh is true calculate
	//	the pressure on the inlet face, if mesh is false do it for the outlet
	void Calculate_Pressure_At_Face_Mesh(const bool& mesh, double& p){
		p=0.0;
		//Inlet mesh
		if(mesh){
			//If the inlet mesh has been set
			if(InletMeshPt!=0){
				//loop over the elements in the mesh
				unsigned nelement = InletMeshPt->nelement();
				for(unsigned i=0; i<nelement; i++){
					ValveFaceElement* el_pt = dynamic_cast<ValveFaceElement*>((InletMeshPt->element_pt())[i]);
					//If the element is a valve face element, then get it's contribution
					if(el_pt!=0){
						double p_inc=0.0;
						el_pt->measure_of_pressure(p_inc);
						p+=p_inc;
					}
				}
			}
			else{

			}
		}
	}

public:


	ValveElement() : InletMeshPt(0), OutletMeshPt(0)	{	}


	//The prescribed function on the empty side of the valve
	typedef void ValveElementPrescribedPressureFctPt(const double& t,
													const Vector<double>& x,
													double& p);

	//The prescribed volume flux on the empty side of the valve
	typedef void ValveElementPrescribedTotalVolumeFlowFctPt(const double&t,
															double& q);

	//Calculate the component of velocity normal to the valve
	//	at a given squared radial distance which is consistent with
	//	the total volume flux q, the current squared radius of the valve,
	//	and an ideal flow profile. - Default is Poiseuille
	typedef void ValveElementNormalVelocityFromTotalVolumeFctPt(const double& q,
																const double& delta_p,
																const double& R,
																const double& r,
																double& u_n);

	//Assign the minimum effective area coefficient of the valve
	void set_min_effective_area_coefficient(const double min_effective_area_coefficient){
		Min_Effective_Area_Coefficient = min_effective_area_coefficient;
	}

	//Assign the maximum effective area coefficient of the valve
	void set_max_effective_area_coefficient(const double max_effective_area_coefficient){
		Max_Effective_Area_Coefficient = max_effective_area_coefficient;
	}

	void set_inlet_mesh_pt(Mesh* inlet_mesh_pt){
	#ifdef DPARANOID
		if(InletMeshPt!=NULL){
			throw OomphLibError(
			    "Attempting to set inlet mesh to a valve without clearing it first.",
			    OOMPH_CURRENT_FUNCTION,
			    OOMPH_EXCEPTION_LOCATION);
		}
	#endif
		InletMeshPt = inlet_mesh_pt;
	}

	void set_outlet_mesh_pt(Mesh* inlet_mesh_pt){
	#ifdef DPARANOID
		if(OutletMeshPt!=NULL){
			throw OomphLibError(
			    "Attempting to set outlet mesh to a valve without clearing it first.",
			    OOMPH_CURRENT_FUNCTION,
			    OOMPH_EXCEPTION_LOCATION);
		}
	#endif
		OutletMeshPt = outlet_mesh_pt;
	}
	
	//Flush the mesh containing inlet face elements
	void flush_inlet_valve_face_mesh(){Flush_Inlet_Valve_Face_Mesh();}
	//Flush the mesh containing outlet face elements
	void flush_outlet_valve_face_mesh(){Flush_Outlet_Valve_Face_Mesh();}

	//Calculate the centre and max radius of the mesh
	void calculate_centre_and_max_radius(){Calculate_Centre_And_Max_Radius();}

	//Get if the point x is within the open region of the valve
	bool get_in_open_region(const Vector<double>& x){
	#ifdef DPARANOID
		if(x.size()!=DIM){
			throw OomphLibError(
			    "Dimension of passed coordinates is not equal to dimension of ValveElement",
			    OOMPH_CURRENT_FUNCTION,
			    OOMPH_EXCEPTION_LOCATION);
		}
	#endif

		// Get the squared radial distance of the point x from
		//	the centre of the valve
		double r=0.0;
		Calculate_Radial_Distance_At_Point(x,r);
		
		return (r<Current_Valve_Radius());

	}
};


template<class ELEMENT, unsigned DIM>
class ValveFaceElement : 
 public virtual FaceGeometry<ELEMENT>,
 public virtual FaceElement
 public virtual ElementWithExternalElement
{
 	//Needs storage for:
 	// ValveElement handling this face element
 	// Pointer to bulk element this face element is attached to - HANDLED BY FACE ELEMENT
 	// Dofs to store lagrange multipliers
 	// External element things - setup interaction with faces
 	//  on the other side of the valve
 	// Assume ValveFaceElement is attached to the Inlet or Outlet?

 	//Needs fcts for:
 	// Get a measure of inlet and outlet pressure
 	// Get whether a point is in the open or closed section

private:
	// Pointer to the valve element which controls this valve
	//	Needed to determine if a particular point on the valve is within
	//	the open or closed regions.
	ValveElement<ELEMENT, DIM> ValveElement_pt;

	// Return the integral of pressure over the face
	double integrate_pressure();


public:

	// The measure of pressure used when computing the traction
	//	on the valve. By default this is just integrate the pressure
	//	over the entire mesh.
	virtual void measure_of_pressure(double &p){p=integrate_pressure();}
};


namespace Valve_functions{

	//	Set up the interaction with the external elements
	//	Finds the bulk fluid elements at the location of
	//	the face elements. If the bulk element found is
	//	one on which a face element is already attached
	//	then ignore it, otherwise add it to the 
	template<class FLUID_ELEMENT>
	void 
}


}
#endif