#ifndef OOMPH_ANISOTROPIC_SOLID_WITH_VECTOR_ELASTICITY_ELEMENTS
#define OOMPH_ANISOTROPIC_SOLID_WITH_VECTOR_ELASTICITY_ELEMENTS

// Config header generated by autoconfig
#ifdef HAVE_CONFIG_H
  #include <oomph-lib-config.h>
#endif

#include "anisotropic_solid_elements.h"
#include "anisotropic_solid_vector_expansion_elements.h"

namespace oomph
{	
	////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////
	//======================================================================
	//Q ELEMENTS
	//======================================================================
	////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////

	template<unsigned DIM, unsigned NVECT, unsigned NNODE_1D>
	class QAnisotropicWithVectPVDElement	:	public virtual QAnisotropicPVDElement<DIM, NNODE_1D>,	//ADD PIN VECTS AT CONSTRUCTION
												public virtual QAnisotropicSolidVectorExpansionElement<DIM, NVECT, NNODE_1D>
	{
	public:
		QAnisotropicWithVectPVDElement() : QAnisotropicPVDElement<DIM, NNODE_1D>(),	//ADD PIN VECTS AT CONSTRUCTION
											QAnisotropicSolidVectorExpansionElement<DIM, NVECT, NNODE_1D>()
		{	}
		// ~QAnisotropicWithVectPVDElement();
		
		unsigned required_nvalue(const unsigned &n) const
		{return (QAnisotropicSolidVectorExpansionElement<DIM, NVECT, NNODE_1D>::required_nvalue(n) +
				 QAnisotropicPVDElement<DIM, NNODE_1D>::required_nvalue(n));}

		void anisotropic_matrix(const unsigned& ipt,
                               const Vector<double> &s,
                               const Vector<double>& xi,
                               const DenseMatrix<double> &g, 
                               const DenseMatrix<double> &G,
                               DenseMatrix<double>& A)
		{
			if(QAnisotropicPVDElement<DIM, NNODE_1D>::Anisotropic_matrix_fct_pt==0){
				A.resize(DIM, NVECT);
				Vector<double> V(DIM);
				for(unsigned vec=0; vec<NVECT; vec++){
					this->interpolated_vector_anisotropic_solid_vector_expansion(ipt, s, xi, vec, V);
					for(unsigned d=0; d<DIM; d++){
						A(d, vec) = V[d];
					}
				}
			}
			else{
				(*QAnisotropicPVDElement<DIM, NNODE_1D>::Anisotropic_matrix_fct_pt)(ipt, s, xi, g, G, A);
			}
		}

		void output(std::ostream &outfile) {FiniteElement::output(outfile);}

		void output(std::ostream &outfile, const unsigned &nplot)
		{
			//vector of local coordinates
		   	Vector<double> s(DIM);
		   	Vector<double> xi(DIM);
		   
		   	// Tecplot header info
		   	outfile << this->tecplot_zone_string(nplot);
		   
		   	// Loop over plot points
		   	unsigned num_plot_points=this->nplot_points(nplot);
		   	for (unsigned iplot=0;iplot<num_plot_points;iplot++)
		    {
		    	// Get local coordinates of plot point
		     	this->get_s_plot(iplot,nplot,s);
		     
		     	// Get the Lagrangian coordinate
		     	this->interpolated_xi(s,xi);

		     	// Output the position of the plot point
		     	for(unsigned i=0;i<DIM;i++) {outfile << this->interpolated_x(s,i) << " ";}

		     	// Output the vectors
		      	Vector<double> Vect(DIM);
		     	for(int i=0; i<NVECT;i++){
		     		this->interpolated_vector_anisotropic_solid_vector_expansion(0,s,xi,i,Vect);
		     		for(int j=0; j<DIM; j++){
		     			outfile << Vect[j] << " ";
		     		}
		     	}

		    }
		   outfile << std::endl;
		   
		   // Write tecplot footer (e.g. FE connectivity lists)
		   this->write_tecplot_zone_footer(outfile,nplot);
		}

		void output(FILE* file_pt){FiniteElement::output(file_pt);}
		void output(FILE* file_pt, const unsigned &n_plot){FiniteElement::output(file_pt,n_plot);}
		void output_fct(std::ostream &outfile, const unsigned &Nplot,FiniteElement::SteadyExactSolutionFctPt exact_soln_pt){FiniteElement::output_fct(outfile,Nplot,exact_soln_pt);}
		void output_fct(std::ostream &outfile, const unsigned &Nplot,const double& time,FiniteElement::UnsteadyExactSolutionFctPt exact_soln_pt){FiniteElement::output_fct(outfile,Nplot,time,exact_soln_pt);}
		void compute_error(std::ostream &outfile,FiniteElement::SteadyExactSolutionFctPt exact_soln_pt,double& error, double& norm){FiniteElement::compute_error(outfile,exact_soln_pt,error,norm);}
		
		void fill_in_contribution_to_residuals(Vector<double> &residuals)
		{
			AnisotropicPVDEquations<DIM>::fill_in_contribution_to_residuals(residuals);
			AnisotropicSolidVectorExpansionEquations<DIM,NVECT>::fill_in_contribution_to_residuals(residuals);
		}

		void fill_in_contribution_to_jacobian(Vector<double> &residuals,DenseMatrix<double> &jacobian)
		{
			AnisotropicPVDEquations<DIM>::fill_in_contribution_to_jacobian(residuals,jacobian);
			AnisotropicSolidVectorExpansionEquations<DIM,NVECT>::fill_in_contribution_to_jacobian(residuals,jacobian);
		}

		void fill_in_contribution_to_jacobian_and_mass_matrix(Vector<double> &residuals, DenseMatrix<double> &jacobian, DenseMatrix<double> &mass_matrix)
  		{
		   FiniteElement::fill_in_contribution_to_jacobian_and_mass_matrix(residuals,jacobian,mass_matrix);
		}
	};

	// //Face Geometries
	template<unsigned DIM, unsigned NVECT, unsigned NNODE_1D>
	class FaceGeometry<QAnisotropicWithVectPVDElement<DIM, NVECT,NNODE_1D> >:
	public virtual SolidQElement<DIM-1,NNODE_1D>
	{
	public:
		FaceGeometry() : SolidQElement<DIM-1,NNODE_1D>() {}
	};

	template<unsigned NVECT, unsigned NNODE_1D>
	class FaceGeometry<QAnisotropicWithVectPVDElement<1, NVECT, NNODE_1D> >:
	public virtual PointElement
	{
	public:
		FaceGeometry() : PointElement() {}
	};

	////////////////////////////////////////////////////////////////////////
	//======================================================================
	//Q WITH PRESSURE
	//======================================================================
	////////////////////////////////////////////////////////////////////////
	//NNODE_1D HAS NO EFFECT, ENFORCED THAT NNODE_1D=3 FOR QUADRATIC INTERPOLATION OF PRESSURE DOFS
	template<unsigned DIM, unsigned NVECT>
	class QAnisotropicWithVectPVDElementWithPressure	:	public virtual QAnisotropicPVDElementWithPressure<DIM>,	//ADD PIN VECTS AT CONSTRUCTION
															public virtual QAnisotropicSolidVectorExpansionElement<DIM, NVECT, 3>
	{
	public:
		QAnisotropicWithVectPVDElementWithPressure() : QAnisotropicPVDElementWithPressure<DIM>(),	//ADD PIN VECTS AT CONSTRUCTION
														QAnisotropicSolidVectorExpansionElement<DIM, NVECT, 3>()
		{	}

		// ~QAnisotropicWithVectPVDElementWithPressure();
		
		unsigned required_nvalue(const unsigned &n) const
		{return (QAnisotropicSolidVectorExpansionElement<DIM, NVECT, 3>::required_nvalue(n) +
				 QAnisotropicPVDElementWithPressure<DIM>::required_nvalue(n));} 

		void anisotropic_matrix(const unsigned& ipt,
                               const Vector<double> &s,
                               const Vector<double>& xi,
                               const DenseMatrix<double> &g, 
                               const DenseMatrix<double> &G,
                               DenseMatrix<double>& A)
		{
			if(QAnisotropicPVDElementWithPressure<DIM>::Anisotropic_matrix_fct_pt==0){
				A.resize(DIM, NVECT);
				Vector<double> V(DIM);
				for(unsigned vec=0; vec<NVECT; vec++){
					this->interpolated_vector_anisotropic_solid_vector_expansion(ipt, s, xi, vec, V);
					for(unsigned d=0; d<DIM; d++){
						A(d, vec) = V[d];
					}
				}
			}
			else{
				(*QAnisotropicPVDElementWithPressure<DIM>::Anisotropic_matrix_fct_pt)(ipt, s, xi, g, G, A);
			}
		}

		void output(std::ostream &outfile) {FiniteElement::output(outfile);}

		void output(std::ostream &outfile, const unsigned &nplot)
		{
			//vector of local coordinates
		   	Vector<double> s(DIM);
		   	Vector<double> xi(DIM);
		   
		   	// Tecplot header info
		   	outfile << this->tecplot_zone_string(nplot);
		   
		   	// Loop over plot points
		   	unsigned num_plot_points=this->nplot_points(nplot);
		   	for (unsigned iplot=0;iplot<num_plot_points;iplot++)
		    {
		    	// Get local coordinates of plot point
		     	this->get_s_plot(iplot,nplot,s);
		     
		     	// Get the Lagrangian coordinate
		     	this->interpolated_xi(s,xi);

		     	// Output the position of the plot point
		     	for(unsigned i=0;i<DIM;i++) {outfile << this->interpolated_x(s,i) << " ";}

		     	// Output the vectors
		      	Vector<double> Vect(DIM);
		     	for(int i=0; i<NVECT;i++){
		     		this->interpolated_vector_anisotropic_solid_vector_expansion(0,s,xi,i,Vect);
		     		for(int j=0; j<DIM; j++){
		     			outfile << Vect[j] << " ";
		     		}
		     	}

		    }
		   outfile << std::endl;
		   
		   // Write tecplot footer (e.g. FE connectivity lists)
		   this->write_tecplot_zone_footer(outfile,nplot);
		}

		void output(FILE* file_pt){FiniteElement::output(file_pt);}
		void output(FILE* file_pt, const unsigned &n_plot){FiniteElement::output(file_pt,n_plot);}
		void output_fct(std::ostream &outfile, const unsigned &Nplot,FiniteElement::SteadyExactSolutionFctPt exact_soln_pt){FiniteElement::output_fct(outfile,Nplot,exact_soln_pt);}
		void output_fct(std::ostream &outfile, const unsigned &Nplot,const double& time,FiniteElement::UnsteadyExactSolutionFctPt exact_soln_pt){FiniteElement::output_fct(outfile,Nplot,time,exact_soln_pt);}
		void compute_error(std::ostream &outfile,FiniteElement::SteadyExactSolutionFctPt exact_soln_pt,double& error, double& norm){FiniteElement::compute_error(outfile,exact_soln_pt,error,norm);}
		
		void fill_in_contribution_to_residuals(Vector<double> &residuals)
		{
			AnisotropicPVDEquationsWithPressure<DIM>::fill_in_contribution_to_residuals(residuals);
			AnisotropicSolidVectorExpansionEquations<DIM,NVECT>::fill_in_contribution_to_residuals(residuals);
		}

		void fill_in_contribution_to_jacobian(Vector<double> &residuals,DenseMatrix<double> &jacobian)
		{
			AnisotropicPVDEquationsWithPressure<DIM>::fill_in_contribution_to_jacobian(residuals,jacobian);
			AnisotropicSolidVectorExpansionEquations<DIM,NVECT>::fill_in_contribution_to_jacobian(residuals,jacobian);
		}

		void fill_in_contribution_to_jacobian_and_mass_matrix(Vector<double> &residuals, DenseMatrix<double> &jacobian, DenseMatrix<double> &mass_matrix)
  		{
		   FiniteElement::fill_in_contribution_to_jacobian_and_mass_matrix(residuals,jacobian,mass_matrix);
		}

	};

	// //Face Geometries
	template<unsigned DIM, unsigned NVECT>
	class FaceGeometry<QAnisotropicWithVectPVDElementWithPressure<DIM, NVECT> >:
	public virtual SolidQElement<DIM-1,3>
	{
	public:
		FaceGeometry() : SolidQElement<DIM-1,3>() {}
	};

	template<unsigned NVECT>
	class FaceGeometry<QAnisotropicWithVectPVDElementWithPressure<1, NVECT> >:
	public virtual PointElement
	{
	public:
		FaceGeometry() : PointElement() {}
	};

	////////////////////////////////////////////////////////////////////////
	//======================================================================
	//Q WITH CONTINUOUS PRESSURE
	//======================================================================
	////////////////////////////////////////////////////////////////////////

	template<unsigned DIM, unsigned NVECT>
	class QAnisotropicWithVectPVDElementWithContinuousPressure	:	public virtual QAnisotropicPVDElementWithContinuousPressure<DIM>,	//ADD PIN VECTS AT CONSTRUCTION
																	public virtual QAnisotropicSolidVectorExpansionElement<DIM, NVECT, 3>
	{
	public:
		QAnisotropicWithVectPVDElementWithContinuousPressure() : QAnisotropicPVDElementWithContinuousPressure<DIM>(),	//ADD PIN VECTS AT CONSTRUCTION
											QAnisotropicSolidVectorExpansionElement<DIM, NVECT, 3>()
		{	}
		// ~QAnisotropicWithVectPVDElementWithContinuousPressure();
		
		unsigned required_nvalue(const unsigned &n) const
		{return (QAnisotropicSolidVectorExpansionElement<DIM, NVECT, 3>::required_nvalue(n) +
				 QAnisotropicPVDElementWithContinuousPressure<DIM>::required_nvalue(n));} 

		//!!!!!!!!!!!!!!!!!!!!!!11
		unsigned vect_min_index_anisotropic_solid_vector_expansion() const {return (this->solid_p_nodal_index() + 1);}

		void anisotropic_matrix(const unsigned& ipt,
                               const Vector<double> &s,
                               const Vector<double>& xi,
                               const DenseMatrix<double> &g, 
                               const DenseMatrix<double> &G,
                               DenseMatrix<double>& A)
		{
			if(QAnisotropicPVDElementWithContinuousPressure<DIM>::Anisotropic_matrix_fct_pt==0){
				A.resize(DIM, NVECT);
				Vector<double> V(DIM);
				for(unsigned vec=0; vec<NVECT; vec++){
					this->interpolated_vector_anisotropic_solid_vector_expansion(ipt, s, xi, vec, V);
					for(unsigned d=0; d<DIM; d++){
						A(d, vec) = V[d];
					}
				}
			}
			else{
				(*QAnisotropicPVDElementWithContinuousPressure<DIM>::Anisotropic_matrix_fct_pt)(ipt, s, xi, g, G, A);
			}
		}

		void output(std::ostream &outfile) {FiniteElement::output(outfile);}

		void output(std::ostream &outfile, const unsigned &nplot)
		{
			//vector of local coordinates
		   	Vector<double> s(DIM);
		   	Vector<double> xi(DIM);
		   
		   	// Tecplot header info
		   	outfile << this->tecplot_zone_string(nplot);
		   
		   	// Loop over plot points
		   	unsigned num_plot_points=this->nplot_points(nplot);
		   	for (unsigned iplot=0;iplot<num_plot_points;iplot++)
		    {
		    	// Get local coordinates of plot point
		     	this->get_s_plot(iplot,nplot,s);
		     
		     	// Get the Lagrangian coordinate
		     	this->interpolated_xi(s,xi);

		     	// Output the position of the plot point
		     	for(unsigned i=0;i<DIM;i++) {outfile << this->interpolated_x(s,i) << " ";}

		     	// Output the vectors
		      	Vector<double> Vect(DIM);
		     	for(int i=0; i<NVECT;i++){
		     		this->interpolated_vector_anisotropic_solid_vector_expansion(0,s,xi,i,Vect);
		     		for(int j=0; j<DIM; j++){
		     			outfile << Vect[j] << " ";
		     		}
		     	}

		    }
		   outfile << std::endl;
		   
		   // Write tecplot footer (e.g. FE connectivity lists)
		   this->write_tecplot_zone_footer(outfile,nplot);
		}

		void output(FILE* file_pt){FiniteElement::output(file_pt);}
		void output(FILE* file_pt, const unsigned &n_plot){FiniteElement::output(file_pt,n_plot);}
		void output_fct(std::ostream &outfile, const unsigned &Nplot,FiniteElement::SteadyExactSolutionFctPt exact_soln_pt){FiniteElement::output_fct(outfile,Nplot,exact_soln_pt);}
		void output_fct(std::ostream &outfile, const unsigned &Nplot,const double& time,FiniteElement::UnsteadyExactSolutionFctPt exact_soln_pt){FiniteElement::output_fct(outfile,Nplot,time,exact_soln_pt);}
		void compute_error(std::ostream &outfile,FiniteElement::SteadyExactSolutionFctPt exact_soln_pt,double& error, double& norm){FiniteElement::compute_error(outfile,exact_soln_pt,error,norm);}
		
		void fill_in_contribution_to_residuals(Vector<double> &residuals)
		{
			AnisotropicPVDEquationsWithPressure<DIM>::fill_in_contribution_to_residuals(residuals);
			AnisotropicSolidVectorExpansionEquations<DIM,NVECT>::fill_in_contribution_to_residuals(residuals);
		}

		void fill_in_contribution_to_jacobian(Vector<double> &residuals,DenseMatrix<double> &jacobian)
		{
			AnisotropicPVDEquationsWithPressure<DIM>::fill_in_contribution_to_jacobian(residuals,jacobian);
			AnisotropicSolidVectorExpansionEquations<DIM,NVECT>::fill_in_contribution_to_jacobian(residuals,jacobian);
		}

		void fill_in_contribution_to_jacobian_and_mass_matrix(Vector<double> &residuals, DenseMatrix<double> &jacobian, DenseMatrix<double> &mass_matrix)
  		{
		   FiniteElement::fill_in_contribution_to_jacobian_and_mass_matrix(residuals,jacobian,mass_matrix);
		}
	};

	//Face elements
	template<unsigned DIM, unsigned NVECT>
	class FaceGeometry<QAnisotropicWithVectPVDElementWithContinuousPressure<DIM, NVECT> >:
	public virtual SolidQElement<DIM-1,3>
	{
	public:
		FaceGeometry() : SolidQElement<DIM-1,3>() {}
	};

	template<unsigned NVECT>
	class FaceGeometry<QAnisotropicWithVectPVDElementWithContinuousPressure<1, NVECT> >:
	public virtual PointElement
	{
	public:
		FaceGeometry() : PointElement() {}
	};

	//REFINEABLE QELEMENTS








































	////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////
	//======================================================================
	//T ELEMENTS
	//======================================================================
	////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////

	template<unsigned DIM, unsigned NVECT, unsigned NNODE_1D>
	class TAnisotropicWithVectPVDElement	:	public virtual TAnisotropicPVDElement<DIM, NNODE_1D>,	//ADD PIN VECTS AT CONSTRUCTION
												public virtual TAnisotropicSolidVectorExpansionElement<DIM, NVECT, NNODE_1D>
	{
	public:
		TAnisotropicWithVectPVDElement() : TAnisotropicPVDElement<DIM, NNODE_1D>(),	//ADD PIN VECTS AT CONSTRUCTION
											TAnisotropicSolidVectorExpansionElement<DIM, NVECT, NNODE_1D>()
		{	}
		// ~TAnisotropicWithVectPVDElement();
		
		unsigned required_nvalue(const unsigned &n) const
		{return (TAnisotropicSolidVectorExpansionElement<DIM, NVECT, NNODE_1D>::required_nvalue(n) +
				 TAnisotropicPVDElement<DIM, NNODE_1D>::required_nvalue(n));}


		void anisotropic_matrix(const unsigned& ipt,
                               const Vector<double> &s,
                               const Vector<double>& xi,
                               const DenseMatrix<double> &g, 
                               const DenseMatrix<double> &G,
                               DenseMatrix<double>& A)
		{
			if(TAnisotropicPVDElement<DIM, NNODE_1D>::Anisotropic_matrix_fct_pt==0){
				A.resize(DIM, NVECT);
				Vector<double> V(DIM);
				for(unsigned vec=0; vec<NVECT; vec++){
					this->interpolated_vector_anisotropic_solid_vector_expansion(ipt, s, xi, vec, V);
					for(unsigned d=0; d<DIM; d++){
						A(d, vec) = V[d];
					}
				}
			}
			else{
				(*TAnisotropicPVDElement<DIM, NNODE_1D>::Anisotropic_matrix_fct_pt)(ipt, s, xi, g, G, A);
			}
		}

		void output(std::ostream &outfile) {FiniteElement::output(outfile);}

		void output(std::ostream &outfile, const unsigned &nplot)
		{
			//vector of local coordinates
		   	Vector<double> s(DIM);
		   	Vector<double> xi(DIM);
		   
		   	// Tecplot header info
		   	outfile << this->tecplot_zone_string(nplot);
		   
		   	// Loop over plot points
		   	unsigned num_plot_points=this->nplot_points(nplot);
		   	for (unsigned iplot=0;iplot<num_plot_points;iplot++)
		    {
		    	// Get local coordinates of plot point
		     	this->get_s_plot(iplot,nplot,s);
		     
		     	// Get the Lagrangian coordinate
		     	this->interpolated_xi(s,xi);

		     	// Output the position of the plot point
		     	for(unsigned i=0;i<DIM;i++) 
		      	{outfile << this->interpolated_x(s,i) << " ";}

		     	// Output the vectors
		      Vector<double> Vect(DIM);
		     	for(int i=0; i<NVECT;i++){
		     		this->interpolated_vector_anisotropic_solid_vector_expansion(0,s,xi,i,Vect);
		     		for(int j=0; j<DIM; j++){
		     			outfile << Vect[j] << " ";
		     		}
		     	}

		    }
		   outfile << std::endl;
		   
		   // Write tecplot footer (e.g. FE connectivity lists)
		   this->write_tecplot_zone_footer(outfile,nplot);
		}

		void output(FILE* file_pt){FiniteElement::output(file_pt);}
		void output(FILE* file_pt, const unsigned &n_plot){FiniteElement::output(file_pt,n_plot);}
		void output_fct(std::ostream &outfile, const unsigned &Nplot,FiniteElement::SteadyExactSolutionFctPt exact_soln_pt){FiniteElement::output_fct(outfile,Nplot,exact_soln_pt);}
		void output_fct(std::ostream &outfile, const unsigned &Nplot,const double& time,FiniteElement::UnsteadyExactSolutionFctPt exact_soln_pt){FiniteElement::output_fct(outfile,Nplot,time,exact_soln_pt);}
		void compute_error(std::ostream &outfile,FiniteElement::SteadyExactSolutionFctPt exact_soln_pt,double& error, double& norm){FiniteElement::compute_error(outfile,exact_soln_pt,error,norm);}
		
		void fill_in_contribution_to_residuals(Vector<double> &residuals)
		{
			AnisotropicPVDEquations<DIM>::fill_in_contribution_to_residuals(residuals);
			AnisotropicSolidVectorExpansionEquations<DIM,NVECT>::fill_in_contribution_to_residuals(residuals);
		}

		void fill_in_contribution_to_jacobian(Vector<double> &residuals,DenseMatrix<double> &jacobian)
		{
			AnisotropicPVDEquations<DIM>::fill_in_contribution_to_jacobian(residuals,jacobian);
			AnisotropicSolidVectorExpansionEquations<DIM,NVECT>::fill_in_contribution_to_jacobian(residuals,jacobian);
		}

		void fill_in_contribution_to_jacobian_and_mass_matrix(Vector<double> &residuals, DenseMatrix<double> &jacobian, DenseMatrix<double> &mass_matrix)
  		{
		   FiniteElement::fill_in_contribution_to_jacobian_and_mass_matrix(residuals,jacobian,mass_matrix);
		}
	};

	//T Face geometries
	template<unsigned DIM, unsigned NVECT, unsigned NNODE_1D>
	class FaceGeometry<TAnisotropicWithVectPVDElement<DIM, NVECT,NNODE_1D> >:
	public virtual SolidTElement<DIM-1,NNODE_1D>
	{
	public:
		FaceGeometry() : SolidTElement<DIM-1,NNODE_1D>() {}
	};

	template<unsigned NVECT, unsigned NNODE_1D>
	class FaceGeometry<TAnisotropicWithVectPVDElement<1, NVECT, NNODE_1D> >:
	public virtual PointElement
	{
	public:
		FaceGeometry() : PointElement() {}
	};

	////////////////////////////////////////////////////////////////////////
	//======================================================================
	//T WITH CONTINUOUS PRESSURE
	//======================================================================
	////////////////////////////////////////////////////////////////////////

	template<unsigned DIM, unsigned NVECT>
	class TAnisotropicWithVectPVDElementWithContinuousPressure	:	public virtual TAnisotropicPVDElementWithContinuousPressure<DIM>,	//ADD PIN VECTS AT CONSTRUCTION
																	public virtual TAnisotropicSolidVectorExpansionElement<DIM, NVECT, 3>
	{
	public:
		TAnisotropicWithVectPVDElementWithContinuousPressure() : TAnisotropicPVDElementWithContinuousPressure<DIM>(),	//ADD PIN VECTS AT CONSTRUCTION
											TAnisotropicSolidVectorExpansionElement<DIM, NVECT, 3>()
		{	}
		// ~TAnisotropicWithVectPVDElementWithContinuousPressure();
		
		unsigned required_nvalue(const unsigned &n) const
		{return (TAnisotropicSolidVectorExpansionElement<DIM, NVECT, 3>::required_nvalue(n) +
				 TAnisotropicPVDElementWithContinuousPressure<DIM>::required_nvalue(n));} 

		//!!!!!!!!!!!!!!!!!!!!!!11
		unsigned vect_min_index_anisotropic_solid_vector_expansion() const {return (this->solid_p_nodal_index() + 1);}

		void anisotropic_matrix(const unsigned& ipt,
                               const Vector<double> &s,
                               const Vector<double>& xi,
                               const DenseMatrix<double> &g, 
                               const DenseMatrix<double> &G,
                               DenseMatrix<double>& A)
		{
			if(TAnisotropicPVDElementWithContinuousPressure<DIM>::Anisotropic_matrix_fct_pt==0){
				A.resize(DIM, NVECT);
				Vector<double> V(DIM);
				for(unsigned vec=0; vec<NVECT; vec++){
					this->interpolated_vector_anisotropic_solid_vector_expansion(ipt, s, xi, vec, V);
					for(unsigned d=0; d<DIM; d++){
						A(d, vec) = V[d];
					}
				}
			}
			else{
				(*TAnisotropicPVDElementWithContinuousPressure<DIM>::Anisotropic_matrix_fct_pt)(ipt, s, xi, g, G, A);
			}
		}

		void output(std::ostream &outfile) {FiniteElement::output(outfile);}

		void output(std::ostream &outfile, const unsigned &nplot)
		{
			//vector of local coordinates
		   	Vector<double> s(DIM);
		   	Vector<double> xi(DIM);
		   
		   	// Tecplot header info
		   	outfile << this->tecplot_zone_string(nplot);
		   
		   	// Loop over plot points
		   	unsigned num_plot_points=this->nplot_points(nplot);
		   	for (unsigned iplot=0;iplot<num_plot_points;iplot++)
		    {
		    	// Get local coordinates of plot point
		     	this->get_s_plot(iplot,nplot,s);
		     
		     	// Get the Lagrangian coordinate
		     	this->interpolated_xi(s,xi);

		     	// Output the position of the plot point
		     	for(unsigned i=0;i<DIM;i++) {outfile << this->interpolated_x(s,i) << " ";}

		     	// Output the vectors
		      	Vector<double> Vect(DIM);
		     	for(int i=0; i<NVECT;i++){
		     		this->interpolated_vector_anisotropic_solid_vector_expansion(0,s,xi,i,Vect);
		     		for(int j=0; j<DIM; j++){
		     			outfile << Vect[j] << " ";
		     		}
		     	}

		    }
		   outfile << std::endl;
		   
		   // Write tecplot footer (e.g. FE connectivity lists)
		   this->write_tecplot_zone_footer(outfile,nplot);
		}

		void output(FILE* file_pt){FiniteElement::output(file_pt);}
		void output(FILE* file_pt, const unsigned &n_plot){FiniteElement::output(file_pt,n_plot);}
		void output_fct(std::ostream &outfile, const unsigned &Nplot,FiniteElement::SteadyExactSolutionFctPt exact_soln_pt){FiniteElement::output_fct(outfile,Nplot,exact_soln_pt);}
		void output_fct(std::ostream &outfile, const unsigned &Nplot,const double& time,FiniteElement::UnsteadyExactSolutionFctPt exact_soln_pt){FiniteElement::output_fct(outfile,Nplot,time,exact_soln_pt);}
		void compute_error(std::ostream &outfile,FiniteElement::SteadyExactSolutionFctPt exact_soln_pt,double& error, double& norm){FiniteElement::compute_error(outfile,exact_soln_pt,error,norm);}
		
		void fill_in_contribution_to_residuals(Vector<double> &residuals)
		{
			AnisotropicPVDEquationsWithPressure<DIM>::fill_in_contribution_to_residuals(residuals);
			AnisotropicSolidVectorExpansionEquations<DIM,NVECT>::fill_in_contribution_to_residuals(residuals);
		}

		void fill_in_contribution_to_jacobian(Vector<double> &residuals,DenseMatrix<double> &jacobian)
		{
			AnisotropicPVDEquationsWithPressure<DIM>::fill_in_contribution_to_jacobian(residuals,jacobian);
			AnisotropicSolidVectorExpansionEquations<DIM,NVECT>::fill_in_contribution_to_jacobian(residuals,jacobian);
		}

		void fill_in_contribution_to_jacobian_and_mass_matrix(Vector<double> &residuals, DenseMatrix<double> &jacobian, DenseMatrix<double> &mass_matrix)
  		{
		   FiniteElement::fill_in_contribution_to_jacobian_and_mass_matrix(residuals,jacobian,mass_matrix);
		}
	};

	//Face Geometries
	template<unsigned DIM, unsigned NVECT>
	class FaceGeometry<TAnisotropicWithVectPVDElementWithContinuousPressure<DIM, NVECT> >:
	public virtual SolidTElement<DIM-1,3>
	{
	public:
		FaceGeometry() : SolidTElement<DIM-1,3>() {}
	};

	template<unsigned NVECT>
	class FaceGeometry<TAnisotropicWithVectPVDElementWithContinuousPressure<1, NVECT> >:
	public virtual PointElement
	{
	public:
		FaceGeometry() : PointElement() {}
	};

	//Refineable TElements
}

#endif