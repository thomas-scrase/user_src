//LIC// ====================================================================
//LIC// 
//LIC//====================================================================


//Header file for CellInterface elements
#ifndef OOMPH_FULLY_SEGREGATED_CELL_SOLVER_ELEMENTS_HEADER
#define OOMPH_FULLY_SEGREGATED_CELL_SOLVER_ELEMENTS_HEADER

// Config header generated by autoconfig
#ifdef HAVE_CONFIG_H
	#include <oomph-lib-config.h>
#endif

//For the custom integration schemes
#include "../toms_utilities/toms_integral.h"


//OOMPH-LIB headers
#include "../generic/nodes.h"
#include "../generic/oomph_utilities.h"
#include "../generic/Qelements.h"
#include "../generic/Telements.h"
#include "../generic/error_estimator.h"
#include "../generic/problem.h"
#include "../generic/assembly_handler.h"


#include "../cell_model_fully_segregated/cell_model_base_fully_segregated.h"

#include "../cell_membrane_potential/cell_membrane_potential_elements.h"

namespace oomph
{

template <class CONDUCTANCE_MODEL>
class FullySegregatedCellEquations : public virtual FiniteElement,
									public virtual CONDUCTANCE_MODEL,
									public virtual ConductingCellFunctionsBase
{
public:

	////General class functions

	//Constructor
	FullySegregatedCellEquations() : CONDUCTANCE_MODEL()
	{
		//Provide storage for the pointer to each cell associated with each node in the element
		Cell_associated_with_each_node_pt.resize(this->nnode(), nullptr);
	}

	//Destructor
	~FullySegregatedCellEquations()
	{

	}

	//get the integration point associated with node n
	inline unsigned ipt_at_node(const unsigned &n) const
			{return ipt_not_at_nodes + n;}

	//The required amount of storage per node
	inline unsigned required_nvalue(const unsigned &n) const {
		return (CONDUCTANCE_MODEL::required_nvalue(n));
	}

	inline void add_cell_to_node(const unsigned &l, CellModelBaseFullySegregated* cell_pt){
		Cell_associated_with_each_node_pt[l] = cell_pt;
	}



	/////Get variables from cell model

	//Get Vm predicted from cell model
	inline double get_nodal_predicted_vm(const unsigned &l) const {
		return Cell_associated_with_each_node_pt[l]->get_predicted_vm();
	}

	//Get active strain from cell model
	inline double get_nodal_active_strain(const unsigned &l) const {
		return Cell_associated_with_each_node_pt[l]->get_active_strain();
	}	

	//Get general data from cell at node - generally used for outputting but can be used for other things, such as communicating ion flux to an external element



	/////Send variables to cell model

	//Set cell type of cell at node
	void set_cell_type(const unsigned &l, const unsigned &cell_type){
		Cell_associated_with_each_node_pt[l]->set_cell_type(cell_Type);
	}

	//Send general data to cell at node
	inline void set_other_data_at_node(const unsigned &l, const unsigned &var, const double &value){
		Cell_associated_with_each_node_pt[l]->set_other_data(var, value);
	}

	//Assign initial conditions - the cell model generally does this itself but we can override it by forcing it to use the variables this function sends instead
	inline void assign_initial_conditions(const unsigned&l, const Vector<double>& vals, const double& vm){
		Cell_associated_with_each_node_pt[l]->assign_initial_conditions(vals);
	}



	/////Interpolate data from the cell models

	//Get interpolated Vm predicted from cell model
	double get_interpolated_predicted_vm_from_cell_model(const Vector<double>& s) const {
		//The thing we are outputting
		double out = 0.0;
		//The shape function
		const unsigned n_node = this->nnode();
		Shape psi(n_node);
		shape(s,psi);
		//Loop over the nodes
		for(unsigned l=0; l<n_node; l++){
			Out += psi[l]*get_nodal_predicted_vm(l);
		}
	}

	//Get interpolated active strain from cell model
	double get_interpolated_active_strain_from_cell_model(const Vector<double>& s) const {
		//The thing we are outputting
		double out = 0.0;
		//The shape function
		const unsigned n_node = this->nnode();
		Shape psi(n_node);
		shape(s,psi);
		//Loop over the nodes
		for(unsigned l=0; l<n_node; l++){
			Out += psi[l]*get_nodal_active_strain(l);
		}
	}


	// Get interpolated general data from cell model - this is dangerous, make sure that you are definitely interpolating the same data from all nodes in the element
	//													the issue arrises from that each node could be associated with different cell models, the general output data
	//													of which might not line up if you are not careful. I provide no safety checks for this, you are on your own.
	// void get_interpolated_general_output_from_cell_model(const Vector<double>& s, Vector<double> &Out) const {
	// 	Out.resize(Cell_associated_with_each_node_pt[l]->Num_Output_Data, 0.0);

	// 	const unsigned n_node = this->nnode();
	// 	Shape psi(n_node);
	// 	shape(s,psi);

	// 	for(unsigned l=0; l<n_node; l++){
	// 		Vector<double> node_out(Cell_associated_with_each_node_pt[l]->Num_Output_Data, 0.0);
	// 		Cell_associated_with_each_node_pt[l]->get_optional_cell_output(l, node_out);
	// 		for(unsigned i=0; i<CELL_MODEL::Num_Output_Data; i++){
	// 			Out[i] += psi[l]*node_out[i];
	// 		}
	// 	}
	// }
		


	/////Set general node-wise data

	//Set general nodal parameters



	/////Fill in residuals and jacobian

	void fill_in_contribution_to_residuals(Vector<double> &residuals)
	{
		CONDUCTANCE_MODEL::fill_in_generic_residual_contribution_BaseCellMembranePotential(residuals, GeneralisedElement::Dummy_matrix,
																				GeneralisedElement::Dummy_matrix, 0);
	}

	void fill_in_contribution_to_jacobian(Vector<double> &residuals,
		                                   DenseMatrix<double> &jacobian)
	{	
		CONDUCTANCE_MODEL::fill_in_contribution_to_jacobian(residuals, jacobian);
	}

	void fill_in_contribution_to_jacobian_and_mass_matrix(Vector<double> &residuals, DenseMatrix<double> &jacobian,
															DenseMatrix<double> &mass_matrix)
	{
		//Broken - how can this be filled in for the cell variables? - Not obvious
		FiniteElement::fill_in_contribution_to_jacobian_and_mass_matrix(residuals, jacobian, mass_matrix);
	}




protected:
	//The number of integral points which are not additional ones placed at the nodes
	unsigned ipt_not_at_nodes;

private:
	//Pointer to the cell corresponding to each node in the element
	Vector<CellModelBaseFullySegregated*> Cell_associated_with_each_node_pt;
};













//Q Element
template<unsigned DIM, unsigned NNODE_1D, template<unsigned> class CONDUCTANCE_MODEL>
class QFullySegregatedCellElement : public virtual QElement<DIM, NNODE_1D>,
									public virtual FullySegregatedCellEquations<CONDUCTANCE_MODEL<DIM>>
{
private:

public:
	QFullySegregatedCellElement() : QElement<DIM, NNODE_1D>(),
									FullySegregatedCellEquations<CONDUCTANCE_MODEL<DIM>>()
	{
		//set the integration scheme to one with integral points aligned with the nodes
		GaussWithNodes<DIM, NNODE_1D>* new_integral_pt = new GaussWithNodes<DIM, NNODE_1D>;
		this->set_integration_scheme(new_integral_pt);
		//set the number of integral points which are not aligned with nodes
		this->ipt_not_at_nodes = this->integral_pt()->nweight() - this->nnode();
	}

	QFullySegregatedCellElement(const QFullySegregatedCellElement<DIM, NNODE_1D, CONDUCTANCE_MODEL>& dummy){BrokenCopy::broken_copy("QFullySegregatedCellElement");}

	void operator=(const QFullySegregatedCellElement<DIM, NNODE_1D, CONDUCTANCE_MODEL>&){BrokenCopy::broken_assign("QFullySegregatedCellElement");}


	//====================================================================
	//Output functions
	//====================================================================
	/// Output with default number of plot points
	void output(std::ostream &outfile){
		FullySegregatedCellEquations<CONDUCTANCE_MODEL<DIM>>::output(outfile);
	}
	/// \short Output FE representation of soln: x,y,V_fct,[vars] or x,y,z,V_fct,[vars] at 
	/// nplot^DIM plot points
	void output(std::ostream &outfile, const unsigned &nplot){
		FullySegregatedCellEquations<CONDUCTANCE_MODEL<DIM>>::output(outfile, nplot);
	}
	/// C_style output with default number of plot points
	void output(FILE* file_pt){
		FullySegregatedCellEquations<CONDUCTANCE_MODEL<DIM>>::output(file_pt);
	}
	 /// \short C-style output FE representation of soln: x,y,V_fct,[vars] or x,y,z,V_fct,[vars] at 
	 /// n_plot^DIM plot points
	 void output(FILE* file_pt, const unsigned &n_plot){
	 	FullySegregatedCellEquations<CONDUCTANCE_MODEL<DIM>>::output(file_pt, n_plot);
	}

	//======================================================================
	/// \short Define the shape functions and test functions and derivatives
	/// w.r.t. global coordinates and return Jacobian of mapping.
	///
	/// Galerkin: Test functions = shape functions
	//======================================================================
	double dshape_and_dtest_eulerian_BaseCellMembranePotential(const Vector<double> &s,
														Shape &psi, 
														DShape &dpsidx,
														Shape &test, 
														DShape &dtestdx) const
	{
		//Call the geometrical shape functions and derivatives  
		double J = this->dshape_eulerian(s,psi,dpsidx);
		//Loop over the test functions and derivatives and set them equal to the
		//shape functions
		for(unsigned i=0;i<NNODE_1D;i++)
		{
			test[i] = psi[i]; 
			for(unsigned j=0;j<DIM;j++)
			{
				dtestdx(i,j) = dpsidx(i,j);
			}
		}
		//Return the jacobian
		return J;
	}

	//======================================================================
	/// Define the shape functions and test functions and derivatives
	/// w.r.t. global coordinates and return Jacobian of mapping.
	///
	/// Galerkin: Test functions = shape functions
	//======================================================================
	double dshape_and_dtest_eulerian_at_knot_BaseCellMembranePotential(const unsigned &ipt,
																Shape &psi, 
																DShape &dpsidx,
																Shape &test, 
																DShape &dtestdx) const
	{
		//Call the geometrical shape functions and derivatives  
		double J = this->dshape_eulerian_at_knot(ipt,psi,dpsidx);
		//Set the test functions equal to the shape functions (pointer copy)
		test = psi;
		dtestdx = dpsidx;
		//Return the jacobian
		return J;
	}

};


template<unsigned NNODE_1D, unsigned DIM, template<unsigned> class CONDUCTANCE_MODEL>
class FaceGeometry<QFullySegregatedCellElement<DIM, NNODE_1D, CONDUCTANCE_MODEL> >:
	public virtual QElement<DIM-1, NNODE_1D>
{
public:
	FaceGeometry()	:	QElement<DIM-1, NNODE_1D>()	{}
};	

template<unsigned NNODE_1D, template<unsigned> class CONDUCTANCE_MODEL>
class FaceGeometry<QFullySegregatedCellElement<1, NNODE_1D, CONDUCTANCE_MODEL> >:
	public virtual PointElement
{
public:
	FaceGeometry()	:	PointElement()	{}
};



//T Element
template<unsigned DIM, unsigned NNODE_1D, template<unsigned> class CONDUCTANCE_MODEL>
class TFullySegregatedCellElement : public virtual TElement<DIM, NNODE_1D>,
									public virtual FullySegregatedCellEquations<CONDUCTANCE_MODEL<DIM>>
{
private:

public:
	TFullySegregatedCellElement() : TElement<DIM, NNODE_1D>(),
									FullySegregatedCellEquations<CONDUCTANCE_MODEL<DIM>>()
	{
		//set the integration scheme to one with integral points aligned with the nodes
		TGaussWithNodes<DIM, NNODE_1D>* new_integral_pt = new TGaussWithNodes<DIM, NNODE_1D>;
		this->set_integration_scheme(new_integral_pt);
		//set the number of integral points which are not aligned with nodes
		this->ipt_not_at_nodes = this->integral_pt()->nweight() - this->nnode();
	}

	TFullySegregatedCellElement(const TFullySegregatedCellElement<DIM, NNODE_1D, CONDUCTANCE_MODEL>& dummy){BrokenCopy::broken_copy("TFullySegregatedCellElement");}

	void operator=(const TFullySegregatedCellElement<DIM, NNODE_1D, CONDUCTANCE_MODEL>&){BrokenCopy::broken_assign("TFullySegregatedCellElement");}


	//====================================================================
	//Output functions
	//====================================================================
	/// Output with default number of plot points
	void output(std::ostream &outfile){
		FullySegregatedCellEquations<CONDUCTANCE_MODEL<DIM>>::output(outfile);
	}
	/// \short Output FE representation of soln: x,y,V_fct,[vars] or x,y,z,V_fct,[vars] at 
	/// nplot^DIM plot points
	void output(std::ostream &outfile, const unsigned &nplot){
		FullySegregatedCellEquations<CONDUCTANCE_MODEL<DIM>>::output(outfile, nplot);
	}
	/// C_style output with default number of plot points
	void output(FILE* file_pt){
		FullySegregatedCellEquations<CONDUCTANCE_MODEL<DIM>>::output(file_pt);
	}
	 /// \short C-style output FE representation of soln: x,y,V_fct,[vars] or x,y,z,V_fct,[vars] at 
	 /// n_plot^DIM plot points
	 void output(FILE* file_pt, const unsigned &n_plot){
	 	FullySegregatedCellEquations<CONDUCTANCE_MODEL<DIM>>::output(file_pt, n_plot);
	}

	//======================================================================
	/// \short Define the shape functions and test functions and derivatives
	/// w.r.t. global coordinates and return Jacobian of mapping.
	///
	/// Galerkin: Test functions = shape functions
	//======================================================================
	double dshape_and_dtest_eulerian_BaseCellMembranePotential(const Vector<double> &s,
														Shape &psi, 
														DShape &dpsidx,
														Shape &test, 
														DShape &dtestdx) const
	{
		//Call the geometrical shape functions and derivatives  
		double J = this->dshape_eulerian(s,psi,dpsidx);
		//Loop over the test functions and derivatives and set them equal to the
		//shape functions
		for(unsigned i=0;i<NNODE_1D;i++)
		{
			test[i] = psi[i]; 
			for(unsigned j=0;j<DIM;j++)
			{
				dtestdx(i,j) = dpsidx(i,j);
			}
		}
		//Return the jacobian
		return J;
	}

	//======================================================================
	/// Define the shape functions and test functions and derivatives
	/// w.r.t. global coordinates and return Jacobian of mapping.
	///
	/// Galerkin: Test functions = shape functions
	//======================================================================
	double dshape_and_dtest_eulerian_at_knot_BaseCellMembranePotential(const unsigned &ipt,
																Shape &psi, 
																DShape &dpsidx,
																Shape &test, 
																DShape &dtestdx) const
	{
		//Call the geometrical shape functions and derivatives  
		double J = this->dshape_eulerian_at_knot(ipt,psi,dpsidx);
		//Set the test functions equal to the shape functions (pointer copy)
		test = psi;
		dtestdx = dpsidx;
		//Return the jacobian
		return J;
	}

};


template<unsigned NNODE_1D, unsigned DIM, template<unsigned> class CONDUCTANCE_MODEL>
class FaceGeometry<TFullySegregatedCellElement<DIM, NNODE_1D, CONDUCTANCE_MODEL> >:
	public virtual TElement<DIM-1, NNODE_1D>
{
public:
	FaceGeometry()	:	TElement<DIM-1, NNODE_1D>()	{}
};	

template<unsigned NNODE_1D, template<unsigned> class CONDUCTANCE_MODEL>
class FaceGeometry<TFullySegregatedCellElement<1, NNODE_1D, CONDUCTANCE_MODEL> >:
	public virtual PointElement
{
public:
	FaceGeometry()	:	PointElement()	{}
};


















//Mesh base class which handles cell objects and provides suitable pointers to the cells to each element in the mesh
//NOTE this class requires the elements and nodes to already be constructed hence you MUST inherit from this class
// AFTER the mesh class
class CellMeshBase
{
private:

	//This function is left virtual since the way in which cells are built on the mesh is entirely problem-dependent.
	// the helper function build_cell_at_node(...) is provided to handle all of the tricky communications, I strongly
	// recommend you use it, if you for any reason do not need to use it please let me know so I can change the functionality
	virtual void BuildCells()
	{
		throw OomphLibError(
			"I am attempting to build the cells in the mesh but you haven't overloaded the appropriate function",
			OOMPH_CURRENT_FUNCTION,
			OOMPH_EXCEPTION_LOCATION);
	}


	//Work out what elements contain each 'global' node and which local node indexes correspond to these nodes.
	// For large meshes this function will likely take a very long time, is there a way to speed it up?
	void BuildNodeElementTables()
	{
		//First we allocate suitable storage in the vectors
		Elements_containing_node.resize(this->nnode());
		Local_node_in_element_equal_to_global_node.resize(this->nnode());

		//Next we loop over all the nodes
		for(unsigned l=0; l<this->nnode(); l++){
			//Get a pointer to the l-th node
			Node* mesh_nod_pt = this->node_pt(l);

			//Next loop over all the elements in the mesh
			for(unsigned e=0; e<this->nelement(); e++){
				//Get a pointer to the element
				GeneralisedElement* elem_pt this->element_pt(e);

				//Now we loop over the nodes in that element
				for(unsigned l1=0; l1<elem_pt->nnode(); l1++){
					//get a pointer to that element
					Node* elem_nod_pt = elem_pt->nope_pt(l1);

					//If the pointers point to the same object then add the element and the local node number to the table
					Elements_containing_node[l].push_back(std::pair<unsigned long, unsigned>(e, l1));
				}
			}
		}
	}

	//Build a cell at the location of the l-th node in the mesh. We need to pass the cell by pointer to all elements which contain
	// the l-th node in the mesh and also pass one of these elements and the local coordinate of the node within that element
	// to the cell.
	template<class CELL_MODEL>
	void build_cell_at_node(const unsigned long& l)
	{
		//Build the cell
		Cells_pt.push_back(new CELL_MODEL);

		//Pass the cell by pointer to all of the elements containing the node
		for(unsigned i=0; i<Elements_containing_node[l].size(); i++){
			//Get a pointer to the i-th element containing the node
			ConductingCellFunctionsBase* elem_pt = dynamic_cast<ConductingCellFunctionsBase*>(this->element_pt(Elements_containing_node[l][i].first));

			//Add the pointer to the suitable entry in the vector of cell pointers in the element
			elem_pt->add_cell_to_node(Elements_containing_node[l][i].second, Cells_pt[NumCells]);
		}



		//Pass the element and node to the cell - we just take the first element number in the lookup table
		ConductingCellFunctionsBase* elem_pt = dynamic_cast<ConductingCellFunctionsBase*>(this->element_pt(Elements_containing_node[l][0].first));
		//Get the local node index in the element
		unsigned node_ind = Elements_containing_node[l][0].second;

		//Get the integral point and local and global coordinates of the node in the element
		//Integral point
		const unsigned ipt = elem_pt->ipt_at_node(node_ind);
		//Local coordinate
		Vector<double> s(elem_pt->dim());
		elem_pt->local_coordinate_of_node(node_ind, s);
		//Global coordinate
		Vector<double> x(elem_pt->dim());
		elem_pt->get_x(s, x);


		//add the element and local and global coordinates to the cell
		Cells_pt[NumCells]->set_my_element_and_coordinate(elem_pt, ipt, s, x, node_ind);


		//Increment the number of cells
		NumCells++;
	}

	//Setup the indexes of where in the vector of cell data each cells data starts
	// Data is packaged as Vm_0, w_0, Vm_1, w_1, ... , Vm_n, w_n
	void SetupDataIndices()
	{
		//provide suitable storage
		Starting_Index_For_Data_Of_Cell.resize(NumCells, 0);

		//iterate through the cells other than the first, that one obviously starts at 0
		for(unsigned c=1; c<NumCells; c++){
			//The index at which this cells data is stored
			Starting_Index_For_Data_Of_Cell[c] = (Starting_Index_For_Data_Of_Cell[c-1] + 1 + Cells_pt[c-1]->get_Num_Cell_Vars());
		}

		//The total number of data associated with the cells
		Total_cell_data = Starting_Index_For_Data_Of_Cell[NumCells-1] + 1 + Cells_pt[NumCells-1]->get_Num_Cell_Vars();
	}


	//Vector of cells in the mesh
	Vector<CellModelBaseFullySegregated*> Cells_pt;

	//The number of cells in the mesh
	unsigned long NumCells;

	//Vector containing vectors of element numbers containing each node in the mesh and the local node number of the node within that element
	Vector<Vector<std::pair(unsigned long, unsigned)>> Elements_containing_node;

	#ifdef OOMPH_HAS_MPI
	//Indices in a vector containing all variables for the cells in the mesh of where each cells data begins
	Vector<unsigned long> Starting_Index_For_Data_Of_Cell;
	unsigned long Total_cell_data;
	#endif



public:
	CellMeshBase() : NumCells(0)
	{
		//Setup node and element tables
		BuildNodeElementTables();

		//Build the cells in the mesh, this is a user overloaded function
		BuildCells();

		#ifdef OOMPH_HAS_MPI
		SetupDataIndices();
		#endif
	}

	~CellMeshBase()
	{
		//Kill all the cells
		for(unsigned c=0; c<NumCells; c++){
			delete Cells_pt[c];
			Cells_pt[c] = 0;
		}
	}

	//Take a timestep with all the cells in the mesh, use mpi if we have built with it, this is the reason we need
	// a pointer to a problem - for access to the mpi communicator
	void Take_time_step_with_all_cells_in_mesh(const double& dt, Problem* problem_pt)
	{
		oomph_info << "Performing a timestep for all cells in a mesh" << std::endl;
		double t_start = TimingHelpers::timer();

		#ifdef OOMPH_HAS_MPI
		Vector<double> My_cell_data(Total_cell_data, 0.0);
		Vector<double> Collected_cell_data(Total_cell_data, 0.0);
		#endif		

		//Serial (or one processor case)
		#ifdef OOMPH_HAS_MPI
		if(problem_pt->communicator_pt()->nproc() == 1){
		#endif
			//Loop over all of the cells in the mesh
			for(unsigned c=0; c<NumCells; c++){
				//Take a timestep
				Cells_pt[c]->TakeTimestep(problem_pt->timestepper_pt()->time_pt()->time(), dt);
			}


		//Otherwise parallel case
		#ifdef OOMPH_HAS_MPI
		}
		else{
			//If we are doing it with mpi then we need to do a bit extra...

			for(unsigned c=0; c<NumCells; c++){
				//If this processor is not required to solve this cell then skip it
				if(c%problem_pt->problem_pt->communicator_pt()->nproc() != problem_pt->communicator_pt()->my_rank()) continue;

				//Take a timestep with the cell
				Cells_pt[c]->TakeTimestep(problem_pt->timestepper_pt()->time_pt()->time(), dt);

				//Add the data to the vector of new cell values
				My_cell_data[Starting_Index_For_Data_Of_Cell[c]] = Cells_pt[c]->get_predicted_vm();
				for(unsigned i=0; i<Cells_pt[c]->get_Num_Cell_Vars(); i++){
					My_cell_data[Starting_Index_For_Data_Of_Cell[c]+1+i] = Cells_pt->get_cell_variable(i);
				}
			}

			//Collect the data into the Collected_cell_data vector	
			MPI_Barrier(problem_pt->communicator_pt()->mpi_comm());
			MPI_Op myOp;
			MPI_Allreduce(My_cell_data.data(), Collected_cell_data.data(), Total_cell_data, MPI_DOUBLE, MPI_SUM, problem_pt->communicator_pt()->mpi_comm());


			//Loop over the cells again and get the new values
			for(unsigned c=0; c<NumCells; c++){
				//If this processor was not required to solve the cell then we need to update the data associated with it
				if(c%problem_pt->problem_pt->communicator_pt()->nproc() != problem_pt->communicator_pt()->my_rank()){
					//Get the start and end point in the collected cell data vector of the data associated with this cell
					Vector<double>::const_iterator first = Collected_cell_data.begin() + Starting_Index_For_Data_Of_Cell[c]+1;
					Vector<double>::const_iterator last = Collected_cell_data.begin() + Starting_Index_For_Data_Of_Cell[c]+1+Cells_pt[c]->get_Num_Cell_Vars();

					//Create a new sub vector of it
					Vector<double> Cell_data(first, last);

					//Call the assign initial conditions of the cell with the new values as those to be assigned
					Cells_pt[c]->assign_initial_conditions(Cell_data, Collected_cell_data[Starting_Index_For_Data_Of_Cell]);
				}
			}

		}
		#endif

		double t_end = TimingHelpers::timer();
		oomph_info << "Done. It took me " << (t_end-t_start) << " seconds to complete." << std::endl;
	}
};


}//End namespace

#endif