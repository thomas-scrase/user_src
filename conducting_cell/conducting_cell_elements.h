//LIC// ====================================================================
//LIC// 
//LIC//====================================================================


//Header file for CellInterface elements
#ifndef OOMPH_CONDUCTING_CELL_ELEMENTS_HEADER
#define OOMPH_CONDUCTING_CELL_ELEMENTS_HEADER

// Config header generated by autoconfig
#ifdef HAVE_CONFIG_H
	#include <oomph-lib-config.h>
#endif

//For the custom integration schemes
#include "../toms_utilities/toms_integral.h"

//For the custom point elements used in single cell elements
#include "../toms_utilities/toms_point_element.h"

#include "../toms_utilities/toms_explicit_timestepping_methods.h"

#include <unordered_map>
#include <functional>

//OOMPH-LIB headers
#include "../generic/nodes.h"
#include "../generic/oomph_utilities.h"
#include "../generic/Qelements.h"
#include "../generic/Telements.h"
#include "../generic/error_estimator.h"


//include the cell model library
#include "../cell_model_updated/cell_model_base_updated.h"

#include "../cell_membrane_potential/cell_membrane_potential_elements.h"

namespace oomph
{	

	template <class CELL_MODEL, class CONDUCTANCE_MODEL>
	class ConductingCellEquations : public virtual FiniteElement,
									public virtual CELL_MODEL,
									public virtual CONDUCTANCE_MODEL,
									public virtual ConductingCellFunctionsBase
	{
	public:

		// \short function pointer to boundary source function fct(bounds, f(bounds)) --
		// bounds_of_node is a vector of the bounds the node exists on
		typedef void (* CellInterfaceBoundarySourceFctPt)
		(std::set<unsigned>* &boundaries_pt, double& bound_source);

		ConductingCellEquations()
		{
			//Initialise the vector of nodes which are computed by this element
			//	by default we compute them all.
			Cell_Inds_To_Compute.resize(this->nnode(), 1);

			SegregatedExplicitTimestepMethodPt = &RK4;

			pin_all_segregated_vars();
		}

		ConductingCellEquations(const ConductingCellEquations& dummy){BrokenCopy::broken_copy("ConductingCellEquations");}

		void operator=(const ConductingCellEquations&){BrokenCopy::broken_assign("ConductingCellEquations");}


		//dependent on cell type to allow for distinction between cell models
		//	in a combined cell model class.
		inline unsigned required_nvalue(const unsigned &n) const {
			return (CELL_MODEL::names_of_cell_variables().size() + CELL_MODEL::required_nvalue(n));
		}


		//return the Gauss point associated with node n
		inline unsigned ipt_at_node(const unsigned &n) const
			{return ipt_not_at_nodes + n;}


		/////////////////////////////////////////////////////////////////////////////////
		//For distributing the cell timestep solve properly over the elements in a mesh
		/////////////////////////////////////////////////////////////////////////////////
		unsigned n_computed_node(){
			unsigned temp = 0;
			for(unsigned i=0; i<this->nnode(); i++){
				temp += Cell_Inds_To_Compute[i];
			}
			return temp;
		}
		void do_not_compute_node(const unsigned &n){
			#ifdef PARANOID
			if(n>this->nnode()){
				throw OomphLibError("n > nnode",
			                       	OOMPH_CURRENT_FUNCTION,
			                       	OOMPH_EXCEPTION_LOCATION);
			}
			#endif
			Cell_Inds_To_Compute[n] = 0;
		}
		void do_compute_node(const unsigned &n){
			#ifdef PARANOID
			if(n>this->nnode()){
				throw OomphLibError("n > nnode",
			                       	OOMPH_CURRENT_FUNCTION,
			                       	OOMPH_EXCEPTION_LOCATION);
			}
			#endif
			Cell_Inds_To_Compute[n] = 1;
		}
		unsigned is_node_computed(const unsigned &n) const {
			#ifdef PARANOID
			if(n>this->nnode()){
				throw OomphLibError("n > nnode",
			                       	OOMPH_CURRENT_FUNCTION,
			                       	OOMPH_EXCEPTION_LOCATION);
			}
			#endif
			return Cell_Inds_To_Compute[n];
		}


		/////////////////////////////////////////////////////////////////////////////////
		//Cell variables at the l-th node
		/////////////////////////////////////////////////////////////////////////////////
		//get the t-th history value of the v-th cell variable associated with the l-th node in the element
		inline double get_nodal_cell_variable(const unsigned &t, const unsigned &l, const unsigned &v) const {
			return node_pt(l)->value(t,CONDUCTANCE_MODEL::max_index_BaseCellMembranePotential() + v);
		}

		inline void get_nodal_cell_variables(const unsigned &t, const unsigned &l, std::unordered_map<std::string, double> &v) const {
			for(unsigned i=0; i<CELL_MODEL::names_of_cell_variables().size(); i++){
				v[CELL_MODEL::names_of_cell_variables()[i]] = get_nodal_cell_variable(t,l, i);
			}
		}


		/////////////////////////////////////////////////////////////////////////////////
		//Get and Set cell type at node n
		/////////////////////////////////////////////////////////////////////////////////

		//Cell type at node
		//	Used in switch function with the following correspondence:
		//		ATRIA 0 - 99,
		//		VENTS 100 - 199,
		//		OTHER 200 - 299 (?)
		//		CNZAtria
		//		0 RA, 1 PM, 2 CT, 3 RAA, 4 AS, 5 AVR, 6 BB, 7 LA, 8 LAA, 9 PV, 10 SAN_C, 11 SAN_P
		//		TNNPVentricle
		//		100 LVEPI 101 LVMCELL 102 LVENDO 103 RVEPI 104 RVMCELL 105 RVENDO 106 PFI 107 PFMB 108 PF
		void set_cell_type(const unsigned &n, const unsigned &cell_type){
			Cell_Type_Data[n] = cell_type;
		}


		// /////////////////////////////////////////////////////////////////////////////////
		// //Get other variables
		// //	these could be, for example:
		// //	 strain in the tissue,
		// //	 oxygen concentration,
		// //	 variables which could be assigned node-wise, or could be the result of some computation and exist in a continuum
		// //We leave this virtual since it's very implementation dependent, it could simply use function pointers to get the
		// //	data we need as is seen in other source functions, or it could call on external elements to interpolate data
		// //	from their own computation, or it could be any other exotic structure you like.
		// /////////////////////////////////////////////////////////////////////////////////
		// inline virtual std::unordered_map<std::string, double> get_other_variables(const unsigned& ipt,
		// 																            const Vector<double> &s,
		// 																            const Vector<double>& x,
		// 																			const unsigned &l,
		// 																			const double &t)
		// {

		// }



		/////////////////////////////////////////////////////////////////////////////////
		//Set other node parameters at node l,
		//	these could be, for example:
		//	 apico-basal ratio,
		//	 other heterogeneity factors,
		//	 ion channel block factors,
		//	Parameters which do not change and are assigned cell (node) wise
		/////////////////////////////////////////////////////////////////////////////////
		//set the var-th black box nodal parameter associated with the l-th node to value
		inline void set_Other_Nodal_Parameter(const unsigned &l, const std::string &var, const double &value){
			//IF DPARANOID
			//check that the var string is one which the cell model requests
			Other_Nodal_Parameters[l][var] = value;
		}


		/////////////////////////////////////////////////////////////////////////////////
		/////////////////////////////////////////////////////////////////////////////////
		//Assign initial conditions at nodes from cell model
		/////////////////////////////////////////////////////////////////////////////////
		/////////////////////////////////////////////////////////////////////////////////
		inline void assign_initial_conditions(){
			for(unsigned n=0; n<this->nnode(); n++){
				//Assign initial conditions of the membrane potential
				//How to handle bidomain? it requires an extra variable to be assigned

				//Assign intitial conditions of cell model variables
				for(unsigned v=0; v<CELL_MODEL::names_of_cell_variables().size(); v++){
					this->node_pt(n)->set_value(CONDUCTANCE_MODEL::max_index_BaseCellMembranePotential() + v,
												CELL_MODEL::return_initial_state_variable(v,Cell_Type_Data[n]));
				}

				this->node_pt(n)->set_value(CONDUCTANCE_MODEL::vm_index_BaseCellMembranePotential(),
												CELL_MODEL::return_initial_membrane_potential(Cell_Type_Data[n]));
			}
		}


		/////////////////////////////////////////////////////////////////////////////////
		/////////////////////////////////////////////////////////////////////////////////
		//Access the explict timestepping method used by the solver, used to set the pointer
		/////////////////////////////////////////////////////////////////////////////////
		/////////////////////////////////////////////////////////////////////////////////
		TomsExplicitTimestepMethodsFctPt &Segregated_Explicit_Timestep_Method_Pt()
		{
			return SegregatedExplicitTimestepMethodPt;
		}




		/////////////////////////////////////////////////////////////////////////////////
		/////////////////////////////////////////////////////////////////////////////////
		//Solving
		/////////////////////////////////////////////////////////////////////////////////
		/////////////////////////////////////////////////////////////////////////////////



		/////////////////////////////////////////////////////////////////////////////////
		//Segregated solve for cell variables and dvdt = -(Iion+Istim)
		/////////////////////////////////////////////////////////////////////////////////
		//Intended for use with strang-splitting. To this aim a bool is provided
		//	pre_shift. pre_shift indicates that the time history values should be
		//	shifted before the explicit step is taken. It also means that the previously
		//	current values, those which were shifted to be the prior values, are used as
		//	the initial conditions of the expliit solve. If pre_shift is set to false
		//	this indicates that the currently accepted value - the value achieved through
		//	the first segregated solve - is used as the initial value.
		//	These are both achived through assigning the values of new_state before any
		//	shifting is performed.
		void perform_segregated_solve(const bool& pre_shift, const double& dt){
			//loop over the cells
			for(unsigned l=0; l<this->nnode(); l++){
				//if the cell is not to be computed then don't compute it
				if(this->is_node_computed(l)){
					//Sort out shifting of data
					if(pre_shift){
						//shift the membrane potential data
						for (int t=this->node_pt(l)->time_stepper_pt()->nprev_values(); t>0; t--){ 
							//Loop over the segregated variables
							for(unsigned i=0; i<CONDUCTANCE_MODEL::required_nvalue(l); i++){
								//Shift them
								this->node_pt(l)->
									set_value(t, CONDUCTANCE_MODEL::vm_index_BaseCellMembranePotential() + i,
												this->node_pt(l)->value(t-1,CONDUCTANCE_MODEL::vm_index_BaseCellMembranePotential() + i));
							}
						}
					}
					//Get coordinate of the node
					unsigned ipt = ipt_at_node(l);

					Vector<double> s(CONDUCTANCE_MODEL::dim());
					//Assign values of s
     				for(unsigned i=0;i<CONDUCTANCE_MODEL::dim();i++) s[i] = this->integral_pt()->knot(ipt,i);

     				Vector<double> x(CONDUCTANCE_MODEL::dim());
					for(unsigned j=0;j<CONDUCTANCE_MODEL::dim();j++)
					{
						x[j] += this->raw_nodal_position(l,j);
					}

					//Get vm
					const double Vm = CONDUCTANCE_MODEL::get_nodal_membrane_potential_BaseCellMembranePotential(l);
					//Get t
					const double t = this->node_pt(l)->time_stepper_pt()->time();
					//Get dt
					//////////
					//Get cell variables
					std::unordered_map<std::string, double> CellVariables;
					get_nodal_cell_variables(0, l , CellVariables);
					//Get Cell type
					const unsigned CellType = Cell_Type_Data[l];
					//Get Other Parameters
					// const Vector<double> OtherParameters = Other_Nodal_Parameters[l];
					const std::unordered_map<std::string, double> OtherParameters = Other_Nodal_Parameters[l];
					//Get Other Variables
					// const Vector<double> OtherVariables = get_other_variables(l, t, x);

					//Allocate New Variables
					std::unordered_map<std::string, double> New_Variables;
					//Allocate New_Vm
					double New_Vm;


					 CellSourcesPackagedWithLocationData Container(dynamic_cast<ConductingCellFunctionsBase*>(this), dynamic_cast<CellModelBaseUpdated*>(this), ipt, s, x, l);

					//Perform the explicit timestep
					(*SegregatedExplicitTimestepMethodPt)(Vm,
														CellVariables,
														CELL_MODEL::names_of_cell_variables(),
														t,
														dt,
														CellType,
														OtherParameters,
														
														Container,

														New_Variables,
														New_Vm);


					//update the nodal variables and the membrane potential
					for(unsigned i=0; i<CELL_MODEL::names_of_cell_variables().size(); i++){
						this->node_pt(l)->set_value(CONDUCTANCE_MODEL::max_index_BaseCellMembranePotential() + i, New_Variables[CELL_MODEL::names_of_cell_variables()[i]]);
					}
					this->node_pt(l)->set_value(CONDUCTANCE_MODEL::vm_index_BaseCellMembranePotential(), New_Vm);
				}
			}
		}


		/////////////////////////////////////////////////////////////////////////////////
		//Residual and Jacobian functions
		// The conductance model is the only thing that does actual oomph lib solving
		/////////////////////////////////////////////////////////////////////////////////
		/// Add the element's contribution to its residual vector (wrapper)
		void fill_in_contribution_to_residuals(Vector<double> &residuals)
		{
		   	//Call the generic residuals function with flag set to 0 and using
		   	//a dummy matrix
			CONDUCTANCE_MODEL::fill_in_contribution_to_residuals(residuals);
		}
		 
		/// \short Add the element's contribution to its residual vector and 
		/// the element Jacobian matrix (wrapper)
		void fill_in_contribution_to_jacobian(Vector<double> &residuals,
		                                   DenseMatrix<double> &jacobian)
		{

			CONDUCTANCE_MODEL::fill_in_contribution_to_jacobian(residuals, jacobian);
		}

		/// Add the element's contribution to its residuals vector,
		/// jacobian matrix and mass matrix
		void fill_in_contribution_to_jacobian_and_mass_matrix(
											Vector<double> &residuals, DenseMatrix<double> &jacobian,
											DenseMatrix<double> &mass_matrix)
		{
			//Call the generic routine with the flag set to 2
			// fill_in_generic_residual_contribution_cell_interface(residuals,jacobian,mass_matrix,2);
			CONDUCTANCE_MODEL::fill_in_contribution_to_jacobian_and_mass_matrix(residuals,jacobian,mass_matrix);
		}




		/////////////////////////////////////////////////////////////////////////////////
		//Get the output data from the cell
		/////////////////////////////////////////////////////////////////////////////////
		std::unordered_map<std::string, double> get_cell_output_data(const unsigned &l)
		{
			//Get the variables required by the cell model

			//Call the function from the cell model
			return CELL_MODEL::get_data_output();
		}

		std::vector<std::string> get_cell_output_names()
		{
			return CELL_MODEL::get_data_output_names();
		}


		/////////////////////////////////////////////////////////////////////////////////
		//Oomph lib Output functions
		/////////////////////////////////////////////////////////////////////////////////
		/// Output with default number of plot points
		void output(std::ostream &outfile){
			unsigned nplot=5;
			output(outfile,nplot);
		}
		/// \short Output FE representation of soln: x,y,V_fct,[vars] or x,y,z,V_fct,[vars] at 
		/// nplot^DIM plot points
		void output(std::ostream &outfile, const unsigned &nplot){};
		/// C_style output with default number of plot points
		void output(FILE* file_pt){
			unsigned n_plot=5;
			output(file_pt,n_plot);
		}
		/// \short C-style output FE representation of soln: x,y,V_fct,[vars] or x,y,z,V_fct,[vars] at 
		/// n_plot^DIM plot points
		void output(FILE* file_pt, const unsigned &n_plot){};



		
		/////////////////////////////////////////////////////////////////////////////////
		//Paraview Output
		/////////////////////////////////////////////////////////////////////////////////
		unsigned nscalar_paraview() const
		{	
			return (CONDUCTANCE_MODEL::get_variable_names().size() + CELL_MODEL::names_of_cell_variables().size() + get_cell_output_names().size());
		}

		void scalar_value_paraview(std::ofstream& file_out,
									const unsigned& i,
									const unsigned& nplot) const
		{
			//Vector of local coordinates
	 		Vector<double> s(CONDUCTANCE_MODEL::DIM);

	 		//Get the number of nodes
	 		const unsigned n_node = this->nnode();

	 		//Preallocate the shape function
	 		Shape psi(n_node);

	 		for(unsigned l=0; l<n_node; l++){
				if(i<CONDUCTANCE_MODEL::get_variable_names().size())
				{
					file_out << this->nodal_value(l, CONDUCTANCE_MODEL::vm_index_BaseCellMembranePotential()+i) << std::endl;
					continue;
				}

				if(i<(CONDUCTANCE_MODEL::get_variable_names().size() + CELL_MODEL::names_of_cell_variables().size())){
					file_out << get_nodal_cell_variable(0, l, i-CONDUCTANCE_MODEL::get_variable_names().size()) << std::endl;
					continue;
				}

				if(i < (CONDUCTANCE_MODEL::get_variable_names().size() + CELL_MODEL::names_of_cell_variables().size() + CELL_MODEL::names_of_cell_variables().size())){
					file_out << get_cell_output_data(l)[CELL_MODEL::get_cell_output_names()[i-(CONDUCTANCE_MODEL::get_variable_names().size() + CELL_MODEL::names_of_cell_variables().size())]] << std::endl;
					continue;
				}
				
	 		}

		}

		void scalar_value_fct_paraview(std::ofstream& file_out,
										const unsigned& i,
										const unsigned& nplot,
										FiniteElement::SteadyExactSolutionFctPt
										exact_soln_pt) const
		{
			scalar_value_paraview(file_out,i,nplot);
		}

		std::string scalar_name_paraview(const unsigned& i) const
		{
			if(i<CONDUCTANCE_MODEL::get_variable_names().size())
			{
				return CONDUCTANCE_MODEL::get_variable_names()[i];
			}

			if(i<(CONDUCTANCE_MODEL::get_variable_names().size() + CELL_MODEL::names_of_cell_variables().size())){
				return CELL_MODEL::names_of_cell_variables()[i-CONDUCTANCE_MODEL::get_variable_names().size()];
			}

			if(i < (CONDUCTANCE_MODEL::get_variable_names().size() + CELL_MODEL::names_of_cell_variables().size() + CELL_MODEL::names_of_cell_variables().size())){
				return get_cell_output_names()[ i - (CONDUCTANCE_MODEL::get_variable_names().size() + CELL_MODEL::names_of_cell_variables().size()) ];
			}

			throw OomphLibError(
					"A variable index which was too large was requested when getting names in paraview output",
					OOMPH_CURRENT_FUNCTION,
					OOMPH_EXCEPTION_LOCATION);
		}








	protected:
		//The number of integral points which are not additional ones placed at the nodes
		unsigned ipt_not_at_nodes;


		/////////////////////////////////////////////////////////////////////////////////
		//For ensuring oomph lib does not do any solving of the cell variables
		/////////////////////////////////////////////////////////////////////////////////
		//Pin all of the segregated variables. There is no need for them to be unpinned
		//	since they are updated manually
		void pin_all_segregated_vars(){
			//Pin all the nodal variables
			for(unsigned l=0; l<this->nnode(); l++){
				for(unsigned i=0; i<CELL_MODEL::names_of_cell_variables().size()+2; i++){
					this->node_pt(l)->pin(CONDUCTANCE_MODEL::max_index_BaseCellMembranePotential()+i);
				}
			}
		}



	private:

		// unsigned Cell_type_internal_index;
		Vector<unsigned> Cell_Type_Data;

		std::vector<std::unordered_map<std::string, double>> Other_Nodal_Parameters;

		// list of local node indexes for which the jacobian and
		//	residual entries are computed. The fill in is
		//	exactly the same as that of neighbouring elements
		//	so we can safely ignore repeated nodes. By default all
		//	nodes are computed. 1 indicates that a node is computed,
		//	0 indicates that it is not computed
		Vector<unsigned> Cell_Inds_To_Compute;

		//The explicit timestepping method we use to solve for the cell variables and also
		//	the spatially independent portion of the membrane potential eqauation
		TomsExplicitTimestepMethodsFctPt SegregatedExplicitTimestepMethodPt;


		// CellInterfaceScalarFctPt StimFctPt;
	};














	//====================================================================
	//====================================================================
	//Q Element
	//====================================================================
	//====================================================================
	template<unsigned DIM, unsigned NNODE_1D, class CELL_MODEL, template<unsigned> class CONDUCTANCE_MODEL>
	class QConductingCellElement :
		public virtual QElement<DIM, NNODE_1D>,
		public virtual ConductingCellEquations<CELL_MODEL, CONDUCTANCE_MODEL<DIM>>
	{
	private:

	public:
		//====================================================================
		//Constructors
		//====================================================================
		QConductingCellElement()	:	QElement<DIM, NNODE_1D>(),
										ConductingCellEquations<CELL_MODEL, CONDUCTANCE_MODEL<DIM>>()
		{
			//set the integration scheme to one with integral points aligned with the nodes
			this->set_integration_scheme(new QNodesOnlyHijackedIntegralScheme<DIM, NNODE_1D>);
			//set the number of integral points which are not aligned with nodes
			this->ipt_not_at_nodes = this->integral_pt()->nweight() - this->nnode();
		}

		QConductingCellElement(const QConductingCellElement<DIM, NNODE_1D, CELL_MODEL, CONDUCTANCE_MODEL>& dummy){BrokenCopy::broken_copy("QConductingCellElement");}

		void operator=(const QConductingCellElement<DIM, NNODE_1D, CELL_MODEL, CONDUCTANCE_MODEL>&){BrokenCopy::broken_assign("QConductingCellElement");}



		//====================================================================
		//Output functions
		//====================================================================
		/// Output with default number of plot points
		void output(std::ostream &outfile){
			ConductingCellEquations<CELL_MODEL, CONDUCTANCE_MODEL<DIM>>::output(outfile);
		}
		/// \short Output FE representation of soln: x,y,V_fct,[vars] or x,y,z,V_fct,[vars] at 
		/// nplot^DIM plot points
		void output(std::ostream &outfile, const unsigned &nplot){
			ConductingCellEquations<CELL_MODEL, CONDUCTANCE_MODEL<DIM>>::output(outfile, nplot);
		}
		/// C_style output with default number of plot points
		void output(FILE* file_pt){
			ConductingCellEquations<CELL_MODEL, CONDUCTANCE_MODEL<DIM>>::output(file_pt);
		}
		 /// \short C-style output FE representation of soln: x,y,V_fct,[vars] or x,y,z,V_fct,[vars] at 
		 /// n_plot^DIM plot points
		 void output(FILE* file_pt, const unsigned &n_plot){
		 	ConductingCellEquations<CELL_MODEL, CONDUCTANCE_MODEL<DIM>>::output(file_pt, n_plot);
		}

	};

	template<unsigned NNODE_1D, unsigned DIM, class CELL_MODEL, template<unsigned> class CONDUCTANCE_MODEL>
	class FaceGeometry<QConductingCellElement<DIM, NNODE_1D, CELL_MODEL, CONDUCTANCE_MODEL> >:
		public virtual QElement<DIM-1, NNODE_1D>
	{
	public:
		FaceGeometry()	:	QElement<DIM-1, NNODE_1D>()	{}
	};	

	template<unsigned NNODE_1D, class CELL_MODEL, template<unsigned> class CONDUCTANCE_MODEL>
	class FaceGeometry<QConductingCellElement<1, NNODE_1D, CELL_MODEL, CONDUCTANCE_MODEL> >:
		public virtual PointElement
	{
	public:
		FaceGeometry()	:	PointElement()	{}
	};




	//====================================================================
	//====================================================================
	//T Element
	//====================================================================
	//====================================================================
	template<unsigned DIM, unsigned NNODE_1D, class CELL_MODEL, template<unsigned> class CONDUCTANCE_MODEL>
	class TConductingCellElement :
		public virtual TElement<DIM, NNODE_1D>,
		public virtual ConductingCellEquations<CELL_MODEL, CONDUCTANCE_MODEL<DIM>>
	{
	private:

	public:
		//====================================================================
		//Constructors
		//====================================================================
		TConductingCellElement()	:	TElement<DIM, NNODE_1D>(),
										ConductingCellEquations<CELL_MODEL, CONDUCTANCE_MODEL<DIM>>()
		{
			//set the integration scheme to one with integral points aligned with the nodes
			this->set_integration_scheme(new QNodesOnlyHijackedIntegralScheme<DIM, NNODE_1D>);
			//set the number of integral points which are not aligned with nodes
			this->ipt_not_at_nodes = this->integral_pt()->nweight() - this->nnode();
		}

		TConductingCellElement(const TConductingCellElement<DIM, NNODE_1D, CELL_MODEL, CONDUCTANCE_MODEL>& dummy){BrokenCopy::broken_copy("TConductingCellElement");}

		void operator=(const TConductingCellElement<DIM, NNODE_1D, CELL_MODEL, CONDUCTANCE_MODEL>&){BrokenCopy::broken_assign("TConductingCellElement");}



		//====================================================================
		//Output functions
		//====================================================================
		/// Output with default number of plot points
		void output(std::ostream &outfile){
			ConductingCellEquations<CELL_MODEL, CONDUCTANCE_MODEL<DIM>>::output(outfile);
		}
		/// \short Output FE representation of soln: x,y,V_fct,[vars] or x,y,z,V_fct,[vars] at 
		/// nplot^DIM plot points
		void output(std::ostream &outfile, const unsigned &nplot){
			ConductingCellEquations<CELL_MODEL, CONDUCTANCE_MODEL<DIM>>::output(outfile, nplot);
		}
		/// C_style output with default number of plot points
		void output(FILE* file_pt){
			ConductingCellEquations<CELL_MODEL, CONDUCTANCE_MODEL<DIM>>::output(file_pt);
		}
		 /// \short C-style output FE representation of soln: x,y,V_fct,[vars] or x,y,z,V_fct,[vars] at 
		 /// n_plot^DIM plot points
		 void output(FILE* file_pt, const unsigned &n_plot){
		 	ConductingCellEquations<CELL_MODEL, CONDUCTANCE_MODEL<DIM>>::output(file_pt, n_plot);
		}

	};

	template<unsigned DIM, unsigned NNODE_1D, class CELL_MODEL, template<unsigned> class CONDUCTANCE_MODEL>
	class FaceGeometry<TConductingCellElement<DIM, NNODE_1D, CELL_MODEL, CONDUCTANCE_MODEL> >:
		public virtual TElement<DIM-1, NNODE_1D>
	{
	public:
		FaceGeometry()	:	TElement<DIM-1, NNODE_1D>()	{}
	};	

	template<unsigned NNODE_1D, class CELL_MODEL, template<unsigned> class CONDUCTANCE_MODEL>
	class FaceGeometry<TConductingCellElement<1, NNODE_1D, CELL_MODEL, CONDUCTANCE_MODEL> >:
		public virtual PointElement
	{
	public:
		FaceGeometry()	:	PointElement()	{}
	};












	// typedef double (*FastStimFctPt)(const double& t);


	//Fast Monodomain Single Cell
	//Does not use oomph-lib machinery.
	//Does not assemble a jacobian or calculate residuals.
	//Only Compatible with exlicit cell models.
	//Uses the explicit timestep function from cell model and maintains
	//	a single cellstate container to avoid unnecessary overhead from
	//	creating and destroying them at each timestep
	//Represents a stripped down version of the CellInterfaceElements
	//Uses explicit Euler for timestepping of the monodomain
	template<class CELL_MODEL>
	class FastSingleCellUpdated : public virtual CELL_MODEL,
									public virtual ConductingCellFunctionsBase
	{
	public:

		FastSingleCellUpdated()// : CELL_MODEL()
		{
			// Variable_vals.resize(CELL_MODEL::names_of_cell_variables().size());

			T=0.0;

			SegregatedExplicitTimestepMethodPt = &RK4;

			// ForwardFctPt = &forwarder;
			// std::cout << "Size at Fast cell Constructor " << CELL_MODEL::names_of_cell_variables().size() << std::endl;
		}

		void pin_membrane_potential(){MembranePotentialIsPinned = true;}
		void unpin_membrane_potential(){MembranePotentialIsPinned = false;}

		void set_cell_type(const unsigned &cell_type){
			Cell_Type_Data = cell_type;
		}

		inline void assign_initial_conditions(){
			// std::cout << "Size at assign initial conditions " << CELL_MODEL::names_of_cell_variables().size() << std::endl;
			//Assign intitial conditions of cell model variables
			for(unsigned v=0; v<CELL_MODEL::names_of_cell_variables().size(); v++){			
				CellVariables[CELL_MODEL::names_of_cell_variables()[v]] = CELL_MODEL::return_initial_state_variable(v,Cell_Type_Data);
			}
			Vm = CELL_MODEL::return_initial_membrane_potential(Cell_Type_Data);
		}

		/////////////////////////////////////////////////////////////////////////////////
		/////////////////////////////////////////////////////////////////////////////////
		//Access the explict timestepping method used by the solver, used to set the pointer
		/////////////////////////////////////////////////////////////////////////////////
		/////////////////////////////////////////////////////////////////////////////////
		TomsExplicitTimestepMethodsFctPt &Segregated_Explicit_Timestep_Method_Pt()
		{
			return SegregatedExplicitTimestepMethodPt;
		}

		//return const membrane potential
		void get_vm(double& vm) const {
			vm = Vm;
		}

		inline void set_vm(const double &vm){
			Vm = vm;
		}

		void get_dvmdt(double & dvdt) const {
			dvdt = dVdt;
		}

		/////////////////////////////////////////////////////////////////////////////////
		//Set other node parameters at node l,
		//	these could be, for example:
		//	 apico-basal ratio,
		//	 other heterogeneity factors,
		//	 ion channel block factors,
		//	Parameters which do not change and are assigned cell (node) wise
		/////////////////////////////////////////////////////////////////////////////////
		//set the var-th black box nodal parameter associated with the l-th node to value
		inline void set_Other_Nodal_Parameter(const std::string &var, const double &value){
			Other_Nodal_Parameters[var] = value;
		}

		// /////////////////////////////////////////////////////////////////////////////////
		// //Get other variables
		// //	these could be, for example:
		// //	 strain in the tissue,
		// //	 oxygen concentration,
		// //	 variables which could be assigned node-wise, or could be the result of some computation and exist in a continuum
		// //We leave this virtual since it's very implementation dependent, it could simply use function pointers to get the
		// //	data we need as is seen in other source functions, or it could call on external elements to interpolate data
		// //	from their own computation, or it could be any other exotic structure you like.
		// /////////////////////////////////////////////////////////////////////////////////
		// inline virtual std::unordered_map<std::string, double> get_other_variables(const double &t)
		// {

		// }

		void TakeTimestep(const double& dt){

			Vector<double> DummyVector;

			//Allocate New Variables
			std::unordered_map<std::string, double> New_Variables;
			//Allocate New_Vm
			double New_Vm;

			CellSourcesPackagedWithLocationData Container(dynamic_cast<ConductingCellFunctionsBase*>(this), dynamic_cast<CellModelBaseUpdated*>(this), 0, DummyVector, DummyVector, 0);

			// for(unsigned i=0; i< CELL_MODEL::names_of_cell_variables().size(); i++){
			// 	std::cout << "Var Name " << i << " :" << CELL_MODEL::names_of_cell_variables()[i] << std::endl;
			// }

			//Perform the explicit timestep
			(*SegregatedExplicitTimestepMethodPt)(Vm,
												CellVariables,
												CELL_MODEL::names_of_cell_variables(),
												T,
												dt,
												Cell_Type_Data,
												Other_Nodal_Parameters,
												
												Container,

												New_Variables,
												New_Vm);

			//update the nodal variables and the membrane potential
			for(unsigned i=0; i<CELL_MODEL::names_of_cell_variables().size(); i++){
				CellVariables[CELL_MODEL::names_of_cell_variables()[i]] = New_Variables[CELL_MODEL::names_of_cell_variables()[i]];
			}
			dVdt = (New_Vm - Vm)/dt;
			Vm = New_Vm;

			T+=dt;
		}



		void output_variables(std::ofstream &data_out){
			for(unsigned i=0; i<CELL_MODEL::names_of_cell_variables().size()+1; i++){
				if(i!=0){data_out << " ";}
				data_out << CellVariables[CELL_MODEL::names_of_cell_variables()[i]];
			}
		}

		Vector<double>* custom_output_vect(){
			return &Custom_Output_Vect;
		}

		// //For setting the stimulus function
		// FastStimFctPt& Stimulus_Function()
		// {
		// 	return StimFctPt;
		// }



	protected:
		/// Is the membrane potential calculated with the element timestepper?
		///	 or alternatively is it prescribed? If so, pin it
		bool MembranePotentialIsPinned;

 		///The cell type
 		unsigned Cell_Type_Data;

		std::unordered_map<std::string, double> Other_Nodal_Parameters;

		//The vector containing the cell variable values and the membrane potential
		std::unordered_map<std::string, double> CellVariables;

		double Vm;

		double dVdt;

		double T;

		//Store the most recent additional variables returned by the cell model
		Vector<double> Custom_Output_Vect;

		// FastStimFctPt StimFctPt;

		//The explicit timestepping method we use to solve for the cell variables and also
		//	the spatially independent portion of the membrane potential eqauation
		TomsExplicitTimestepMethodsFctPt SegregatedExplicitTimestepMethodPt;

		// OtherVariablesFctPt ForwardFctPt;
	};


	//Fast Bidomain Single cell
	//In the limit of a point the Bidomain equations simplify down to the Monodomain equations
	// so we don't need to make a bidomain version








//Namespace, helper functions for dealing with cell interface elements
namespace Oomph_Cell_Interface_Helpers
{
	//Setup non-overlapping node residual and jacobian fill in for the vector of elements
	//	passed. Only to be applied in the case that cells are points and thus their residual and
	//	jacobian is the same regardless of the element it is computed within
	template<class ELEMENT>
	void Setup_Non_Overlapping_Nodes_Updated(const Vector<GeneralisedElement*> element_pts)
	{	
		oomph_info << "Removing excess computation of cell nodes by overlapping elements:" << std::endl;
		unsigned n_elmts = element_pts.size();
		unsigned n_node = 0;
		//Declare map: node_refs -> unique id
		std::map<Node*, unsigned> node_id_map;
		std::map<unsigned, Node*> node_point_map;
		//Declare Vector: Node unique id -> Vector of elements which compute that node
		Vector<Vector<unsigned>> elements_computing_node;
		//Loop over all the elements
		for(unsigned i=0; i<n_elmts; i++){
			FiniteElement* el_pt = dynamic_cast<FiniteElement*>(element_pts[i]);
			unsigned n_el_node = el_pt->nnode();
			//Loop over all the node points
			for(unsigned l=0; l<n_el_node; l++){
				//If the node is new
				if(node_id_map.find(el_pt->node_pt(l)) == node_id_map.end()){
					//Add it to the map of node_refs to a unique node id
					node_id_map[el_pt->node_pt(l)] = n_node;
					node_point_map[n_node] = el_pt->node_pt(l);
					n_node++;
					//Add the element id to the Vector of element ids for that node
					elements_computing_node.resize(n_node);
					elements_computing_node[n_node-1].push_back(i);
				}
				//If the node is not new
				else{
					//Add the element id to the Vector of element ids for that node
					elements_computing_node[node_id_map[el_pt->node_pt(l)]].push_back(i);
				}
			}
		}


		oomph_info << "Found " << n_node << " unique nodes associated with the " << n_elmts << " cell interface elements." << std::endl;

		oomph_info << "Initial number of elements computing each detected node:" << std::endl;
		oomph_info << "Node id : Number of elements" << std::endl;
		//Report on the number of elements computing each node
		for(unsigned l=0; l<n_node; l++){
			oomph_info << l << " : " << elements_computing_node[l].size() << std::endl;
		}

		oomph_info << "Initial number of nodes computed by each element:" << std::endl;
		oomph_info << "Element id : Number of nodes" << std::endl;
		//Report on the number of elements computing each node
		for(unsigned i=0; i<element_pts.size(); i++){
			oomph_info << i << " : " << dynamic_cast<ELEMENT*>(element_pts[i])->n_computed_node() << std::endl;
		}


		bool reduced = false;
		unsigned num_pass = 0;
		//Continue until we have reduced the number of overlapping elements to zero
		while(!reduced){
			//Loop over the nodes
			for(unsigned l=0; l<n_node; l++){
				//If there are > 1 elements which compute it
				if(elements_computing_node[l].size()>1){
					//Vector of number of computed nodes for each element which computes this node
					Vector<unsigned> num_computed_nodes(elements_computing_node[l].size());
					//Loop over the elements which compute this node
					for(unsigned i=0; i<elements_computing_node[l].size(); i++){
						//Get a pointer to the element
						ELEMENT* el_pt =
							dynamic_cast<ELEMENT*>(element_pts[elements_computing_node[l][i]]);
						//Check how many nodes it computes
						num_computed_nodes[i] = el_pt->n_computed_node();
					}
					//Remove the element which computes the most nodes and turn off computation for this node
					unsigned ind_to_be_removed = std::max_element(num_computed_nodes.begin(),num_computed_nodes.end()) - num_computed_nodes.begin();
					//Get a pointer to the node we are working on
					Node* nod_pt = node_point_map[l];
					//Get a pointer to the element
					ELEMENT* el_pt =
						dynamic_cast<ELEMENT*>(element_pts[elements_computing_node[l][ind_to_be_removed]]);
					//Loop over the nodes in the element
					for(unsigned i=0; i<el_pt->nnode(); i++){
						//if the node is the same as the one we are working with
						if(el_pt->node_pt(i) == nod_pt){
							el_pt->do_not_compute_node(i);
						}
					}
					//Remove the element from the vector of elements which compute this node
					elements_computing_node[l].erase(elements_computing_node[l].begin()+ind_to_be_removed);
				}
			}
			num_pass++;
			reduced = true;
			//Loop over the nodes
			for(unsigned l=0; l<n_node; l++){
				//Check how many elements compute each
				if(elements_computing_node[l].size()>1){
					//If they are all computed by just 1 element then stop infinite loop
					reduced = false;
					break;
				}
			}
		}

		//Vector of number of computed nodes for each element
		// Vector<unsigned> num_computed_nodes(element_pts.size());
		// for(unsigned e=0; e<element_pts.size(); e++){
		// 	num_computed_nodes[e] = dynamic_cast<ELEMENT*>(element_pts[e])->n_computed_node();
		// }
		// //While we can reduce all of the elements
		// while(*std::max_element(num_computed_nodes.begin(),num_computed_nodes.end()) > 1){
		// 	//Get the element with the largest number of computed nodes
		// 	unsigned e = std::max_element(num_computed_nodes.begin(),num_computed_nodes.end()) - num_computed_nodes.begin();
		// 	//Get a pointer to it
		// 	ELEMENT* el_pt = dynamic_cast<ELEMENT*>(element_pts[e]);
		// 	//We assume that we haven't managed to reduce the element in question
		// 	bool element_was_reduceable = false;
		// 	//Loop over the nodes in the element
		// 	for(unsigned n=0; n<el_pt->nnode(); n++){
		// 		//If the node is computed by the element
		// 		if(el_pt->is_node_computed(n)){
		// 			//Get the node id in our list of nodes
		// 			unsigned n_ind = node_id_map[el_pt->node_pt(n)];
		// 			//If the node is computed by more than 1 element
		// 			if(elements_computing_node[n_ind].size()>1){
		// 				//Remove it from the list of computed nodes for this element
		// 				el_pt->do_not_compute_node(n);
		// 				//Remove the element id from the vector of ids of elements which compute this node
		// 				for(unsigned e1=0; e1<elements_computing_node[n_ind].size(); e1++){
		// 					if(elements_computing_node[n_ind][e1] == e){
		// 						elements_computing_node[n_ind].erase(elements_computing_node[n_ind].begin() + e1);
		// 					}
		// 				}
		// 				//We let the loop know that we reduced an element
		// 				element_was_reduceable = true;
		// 				//Once we have removed a node from the computation of this element then stop removing nodes
		// 				break;
		// 			}
		// 		}
		// 	}
		// 	//If we have got to this point and the computation of a node could not be removed from
		// 	//	the element then the element is not reduceable further and we remove it from the list
		// 	//	of elements we check
		// 	if(!element_was_reduceable){num_computed_nodes[e] = 0;}
		// 	num_pass++;
		// }


		//Recalculate things just to make sure
		node_id_map.clear();
		node_point_map.clear();
		elements_computing_node.clear();
		n_elmts = element_pts.size();
		n_node = 0;
		//Declare map: node_refs -> unique id
		// std::map<Node*, unsigned> node_id_map;
		// std::map<unsigned, Node*> node_point_map;
		//Declare Vector: Node unique id -> Vector of elements which compute that node
		// Vector<Vector<unsigned>> elements_computing_node;
		//Loop over all the elements
		for(unsigned i=0; i<n_elmts; i++){
			ELEMENT* el_pt = dynamic_cast<ELEMENT*>(element_pts[i]);
			unsigned n_el_node = el_pt->nnode();
			//Loop over all the node points
			for(unsigned l=0; l<n_el_node; l++){
				//If the node is new
				if(node_id_map.find(el_pt->node_pt(l)) == node_id_map.end()){
					//if the node is computed by the element
					if(el_pt->is_node_computed(l)){
						//Add it to the map of node_refs to a unique node id
						node_id_map[el_pt->node_pt(l)] = n_node;
						node_point_map[n_node] = el_pt->node_pt(l);
						n_node++;
						//Add the element id to the Vector of element ids for that node
						elements_computing_node.resize(n_node);
						elements_computing_node[n_node-1].push_back(i);
					}
				}
				//If the node is not new
				else{
					//if the node is computed by the element
					if(el_pt->is_node_computed(l)){
						//Add the element id to the Vector of element ids for that node
						elements_computing_node[node_id_map[el_pt->node_pt(l)]].push_back(i);
					}
				}
			}
		}

		oomph_info << "Final number of elements computing each detected node:" << std::endl;
		oomph_info << "Node id : Number of elements" << std::endl;
		//Report on the number of elements computing each node
		for(unsigned l=0; l<n_node; l++){
			oomph_info << l << " : " << elements_computing_node[l].size() << std::endl;
		}

		oomph_info << "Final number of nodes computed by each element:" << std::endl;
		oomph_info << "Element id : Number of nodes" << std::endl;
		//Report on the number of elements computing each node
		for(unsigned i=0; i<element_pts.size(); i++){
			oomph_info << i << " : " << dynamic_cast<ELEMENT*>(element_pts[i])->n_computed_node() << std::endl;
		}

		oomph_info << "Completed computation reduction of cell interface mesh of point nodes. Process required " << num_pass << " passes to complete." << std::endl;
	}


}


}

#endif