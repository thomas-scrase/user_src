//Combine the monodomain_elements with the monodomain_d_expansion_elements
//to form the MonodomainWithDElements

#ifndef OOMPH_MONODOMAIN_WITH_D_EXPANSION
#define OOMPH_MONODOMAIN_WITH_D_EXPANSION

// Config header generated by autoconfig
#ifdef HAVE_CONFIG_H
  #include <oomph-lib-config.h>
#endif

#include "../monodomain/monodomain_elements.h"
#include "../toms_utilities/storage_enrichment_elements.h"

namespace oomph
{
  ////////////////////////////////////////////////////////////////////////
  ////////////////////////////////////////////////////////////////////////
  ////////////////////////////////////////////////////////////////////////
  //======================================================================
  //Q ELEMENTS
  //======================================================================
  ////////////////////////////////////////////////////////////////////////
  ////////////////////////////////////////////////////////////////////////
  ////////////////////////////////////////////////////////////////////////

  template<unsigned DIM, unsigned NNODE_1D>
  class QMonodomainWithDELement : public virtual QMonodomainElement<DIM, NNODE_1D>,
                                  public virtual QStorageEnrichmentElement<DIM, DIM*DIM, NNODE_1D>
  {
    public:
      QMonodomainWithDELement() : QMonodomainElement<DIM, NNODE_1D>(),
                                  QStorageEnrichmentElement<DIM, DIM*DIM, NNODE_1D>()
      { }

      //identify the indexes of the data
      unsigned u_index_monodomain()           const {return 0;}
      unsigned min_index_storage_enrichment() const {return 1;}
      unsigned max_index_storage_enrichment() const {return 1 + DIM*DIM;}

      unsigned required_nvalue(const unsigned &n) const
      {return (QMonodomainElement<DIM, NNODE_1D>::required_nvalue(n) +
              QStorageEnrichmentElement<DIM, DIM*DIM, NNODE_1D>::required_nvalue(n));}

      void get_diff_monodomain(const unsigned& ipt,
                                const Vector<double> &s,
                                const Vector<double>& x,
                                DenseMatrix<double>& D) const
      {
        //The number of nodes in the element
        unsigned n_node = this->nnode();
        //The shape function
        Shape psi(n_node);
        //Its values corresponding to the nodes
        this->shape(s,psi);

        //loop over the rows
        for(unsigned i=0; i<DIM; i++){
          //Loop over the columns
          for(unsigned j=0; j<DIM; j++){
            //set the value to zero
            D(i,j) = 0.0;
            //loop over the nodes
            for(unsigned l=0; l<n_node; l++){
              //add the nodal contribution, data is at Min_position + DIM*(number of rows already added) + location on this row
              D(i,j) += this->nodal_value(l, this->min_index_storage_enrichment() + i*DIM + j)*psi[l];
            }
          }
        }
      }

      void output(std::ostream &outfile) {FiniteElement::output(outfile);}

      void output(std::ostream &outfile, const unsigned &nplot){
        //vector of local coordinates
        Vector<double> s(DIM);
        Vector<double> xi(DIM);

        // Tecplot header info
        outfile << this->tecplot_zone_string(nplot);
        
        const unsigned n_node = this->nnode();
        Shape psi(n_node);
        DShape dpsidx(n_node,DIM);

        // Loop over plot points
        unsigned num_plot_points=this->nplot_points(nplot);
        for (unsigned iplot=0;iplot<num_plot_points;iplot++){
          // Get local coordinates of plot point
          this->get_s_plot(iplot,nplot,s);
           
          // Get the Lagrangian coordinate
          this->interpolated_x(s,xi);

          // Output the position of the plot point
          for(unsigned i=0;i<DIM;i++) {outfile << xi[i] << " ";}

          outfile << this->interpolated_u_monodomain(s) << " ";

          (void)this->dshape_eulerian(s,psi,dpsidx);
          Vector<double> interpolated_dudx(DIM,0.0);
          double dudt = 0.0;
          for(unsigned n=0;n<n_node;n++){
            const double u_ = this->nodal_value(n,this->u_index_monodomain());

            dudt += this->du_dt_monodomain(n)*psi(n);

            for(unsigned i=0;i<DIM;i++){
              interpolated_dudx[i] += u_*dpsidx(n,i);
            }
          }

          outfile << dudt << " ";
          for(unsigned i=0;i<DIM;i++){
            outfile << interpolated_dudx[i]  << " ";
          }


          DenseMatrix<double> Dprint(DIM);
          get_diff_monodomain(0, s, xi, Dprint);
          for(unsigned i=0; i<DIM; i++){
            for(unsigned j=i; j<DIM; j++){
              outfile << Dprint(i,j) << " ";
            }
          }
          outfile << std::endl;
        }

        this->write_tecplot_zone_footer(outfile, nplot);
      }

      /// \short C-style output function: Broken default
      void output(FILE* file_pt){FiniteElement::output(file_pt);}

      ///  \short C-style output function: Broken default
      void output(FILE* file_pt, const unsigned &n_plot){FiniteElement::output(file_pt,n_plot);}

      /// \short Output function for an exact solution: Broken default
      void output_fct(std::ostream &outfile, const unsigned &Nplot,
                      FiniteElement::SteadyExactSolutionFctPt 
                      exact_soln_pt)
      {FiniteElement::output_fct(outfile,Nplot,exact_soln_pt);}

      /// \short Output function for a time-dependent exact solution:
      /// Broken default.
      void output_fct(std::ostream &outfile, const unsigned &Nplot,
                      const double& time,
                      FiniteElement::UnsteadyExactSolutionFctPt 
                      exact_soln_pt)
      {FiniteElement::output_fct(outfile,Nplot,time,exact_soln_pt);}

      /// \short Validate against exact solution at given time
      /// Solution is provided via function pointer.
      /// Plot at a given number of plot points and compute L2 error
      /// and L2 norm of velocity solution over element
      /// Call the broken default
      void compute_error( std::ostream &outfile,
                          FiniteElement::UnsteadyExactSolutionFctPt exact_soln_pt,
                          const double& time,
                          double& error, double& norm)
      {FiniteElement::compute_error(outfile,exact_soln_pt,time,error,norm);}
     
      /// \short Validate against exact solution.
      /// Solution is provided via function pointer.
      /// Plot at a given number of plot points and compute L2 error
      /// and L2 norm of velocity solution over element
      /// Call the broken default
      void compute_error( std::ostream &outfile,
                          FiniteElement::SteadyExactSolutionFctPt exact_soln_pt,
                          double& error, double& norm)
      {FiniteElement::compute_error(outfile,exact_soln_pt,error,norm);}

      /// \short Calculate the contribution to the residual vector.
      /// We assume that the vector has been initialised to zero
      /// before this function is called.
      void fill_in_contribution_to_residuals(Vector<double> &residuals){
        MonodomainEquations<DIM>::fill_in_contribution_to_residuals(residuals);
        StorageEnrichmentEquations<DIM*DIM>::fill_in_contribution_to_residuals(residuals);
      }

      ///\short Compute the element's residual Vector and the jacobian matrix
      /// We assume that the residuals vector and jacobian matrix have been
      /// initialised to zero before calling this function
      void fill_in_contribution_to_jacobian(Vector<double> &residuals,
                                            DenseMatrix<double> &jacobian)
      {
        MonodomainEquations<DIM>::fill_in_contribution_to_jacobian(residuals, jacobian);
        StorageEnrichmentEquations<DIM*DIM>::fill_in_contribution_to_jacobian(residuals, jacobian);
      }

      // Add the element's contribution to its residuals vector,
      /// jacobian matrix and mass matrix
      void fill_in_contribution_to_jacobian_and_mass_matrix(Vector<double> &residuals,
                                                            DenseMatrix<double> &jacobian, 
                                                            DenseMatrix<double> &mass_matrix)
      {
        MonodomainEquations<DIM>::fill_in_contribution_to_jacobian_and_mass_matrix(residuals, jacobian, mass_matrix);
        StorageEnrichmentEquations<DIM*DIM>::fill_in_contribution_to_jacobian_and_mass_matrix(residuals, jacobian, mass_matrix);
      }

  };

  //Q FACE GEOMETRIES

  template<unsigned DIM, unsigned NNODE_1D>
  class FaceGeometry<QMonodomainWithDELement<DIM, NNODE_1D> >:
  public virtual QElement<DIM-1, NNODE_1D>
  {
  public:
    FaceGeometry() : QElement<DIM-1, NNODE_1D>() {}
  };

  template<unsigned NNODE_1D>
  class FaceGeometry<QMonodomainWithDELement<1, NNODE_1D> >:
  public virtual PointElement
  {
  public:
    FaceGeometry() : PointElement() {}
  };



  //REFINEABLE QMONODOMAINWITHD


  ////////////////////////////////////////////////////////////////////////
  ////////////////////////////////////////////////////////////////////////
  ////////////////////////////////////////////////////////////////////////
  //======================================================================
  //T ELEMENTS
  //======================================================================
  ////////////////////////////////////////////////////////////////////////
  ////////////////////////////////////////////////////////////////////////
  ////////////////////////////////////////////////////////////////////////

  template<unsigned DIM, unsigned NNODE_1D>
  class TMonodomainWithDELement : public virtual TMonodomainElement<DIM, NNODE_1D>,
                                  public virtual TStorageEnrichmentElement<DIM, DIM*DIM, NNODE_1D>
  {
    public:
      TMonodomainWithDELement() : TMonodomainElement<DIM, NNODE_1D>(),
                                  TStorageEnrichmentElement<DIM, DIM*DIM, NNODE_1D>()
      { }

      //identify the indexes of the diffusion matrix data
      unsigned diff_min_index_monodomain() const {return (this->u_index_monodomain()+1);}

      unsigned required_nvalue(const unsigned &n) const
      {return (TMonodomainElement<DIM, NNODE_1D>::required_nvalue(n) +
              TStorageEnrichmentElement<DIM, DIM*DIM, NNODE_1D>::required_nvalue(n));}

      void get_diff_monodomain(const unsigned& ipt,
                                const Vector<double> &s,
                                const Vector<double>& x,
                                DenseMatrix<double>& D) const
      {
        //The number of nodes in the element
        unsigned n_node = this->nnode();
        //The shape function
        Shape psi(n_node);
        //Its values corresponding to the nodes
        this->shape(s,psi);

        //loop over the rows
        for(unsigned i=0; i<DIM; i++){
          //Loop over the columns
          for(unsigned j=0; j<DIM; j++){
            //set the value to zero
            D(i,j) = 0.0;
            //loop over the nodes
            for(unsigned l=0; l<n_node; l++){
              //add the nodal contribution, data is at Min_position + DIM*(number of rows already added) + location on this row
              D(i,j) += this->nodal_value(l, this->min_index_storage_enrichment() + i*DIM + j)*psi[l];
            }
          }
        }
      }

      void output(std::ostream &outfile) {FiniteElement::output(outfile);}

      void output(std::ostream &outfile, const unsigned &nplot){
        //vector of local coordinates
        Vector<double> s(DIM);
        Vector<double> xi(DIM);

        // Tecplot header info
        outfile << this->tecplot_zone_string(nplot);
        
        const unsigned n_node = this->nnode();
        Shape psi(n_node);
        DShape dpsidx(n_node,DIM);

        // Loop over plot points
        unsigned num_plot_points=this->nplot_points(nplot);
        for (unsigned iplot=0;iplot<num_plot_points;iplot++){
          // Get local coordinates of plot point
          this->get_s_plot(iplot,nplot,s);
           
          // Get the Lagrangian coordinate
          this->interpolated_x(s,xi);

          // Output the position of the plot point
          for(unsigned i=0;i<DIM;i++) {outfile << xi[i] << " ";}

          outfile << this->interpolated_u_monodomain(s) << " ";

          (void)this->dshape_eulerian(s,psi,dpsidx);
          Vector<double> interpolated_dudx(DIM,0.0);
          double dudt = 0.0;
          for(unsigned n=0;n<n_node;n++){
            const double u_ = this->nodal_value(n,this->u_index_monodomain());

            dudt += this->du_dt_monodomain(n)*psi(n);

            for(unsigned i=0;i<DIM;i++){
              interpolated_dudx[i] += u_*dpsidx(n,i);
            }
          }

          outfile << dudt << " ";
          for(unsigned i=0;i<DIM;i++){
            outfile << interpolated_dudx[i]  << " ";
          }


          DenseMatrix<double> Dprint(DIM);
          get_diff_monodomain(0, s, xi, Dprint);
          for(unsigned i=0; i<DIM; i++){
            for(unsigned j=i; j<DIM; j++){
              outfile << Dprint(i,j) << " ";
            }
          }
          outfile << std::endl;
        }

        this->write_tecplot_zone_footer(outfile, nplot);
      }

      /// \short C-style output function: Broken default
      void output(FILE* file_pt){FiniteElement::output(file_pt);}

      ///  \short C-style output function: Broken default
      void output(FILE* file_pt, const unsigned &n_plot){FiniteElement::output(file_pt,n_plot);}

      /// \short Output function for an exact solution: Broken default
      void output_fct(std::ostream &outfile, const unsigned &Nplot,
                     FiniteElement::SteadyExactSolutionFctPt 
                     exact_soln_pt)
      {FiniteElement::output_fct(outfile,Nplot,exact_soln_pt);}

      /// \short Output function for a time-dependent exact solution:
      /// Broken default.
      void output_fct(std::ostream &outfile, const unsigned &Nplot,
                     const double& time,
                     FiniteElement::UnsteadyExactSolutionFctPt 
                     exact_soln_pt)
      {FiniteElement::output_fct(outfile,Nplot,time,exact_soln_pt);}

      /// \short Validate against exact solution at given time
      /// Solution is provided via function pointer.
      /// Plot at a given number of plot points and compute L2 error
      /// and L2 norm of velocity solution over element
      /// Call the broken default
      void compute_error(std::ostream &outfile,
                        FiniteElement::UnsteadyExactSolutionFctPt exact_soln_pt,
                        const double& time,
                        double& error, double& norm)
      {FiniteElement::compute_error(outfile,exact_soln_pt,time,error,norm);}
     
      /// \short Validate against exact solution.
      /// Solution is provided via function pointer.
      /// Plot at a given number of plot points and compute L2 error
      /// and L2 norm of velocity solution over element
      /// Call the broken default
      void compute_error(std::ostream &outfile,
                        FiniteElement::SteadyExactSolutionFctPt exact_soln_pt,
                        double& error, double& norm)
      {FiniteElement::compute_error(outfile,exact_soln_pt,error,norm);}

      /// \short Calculate the contribution to the residual vector.
      /// We assume that the vector has been initialised to zero
      /// before this function is called.
      void fill_in_contribution_to_residuals(Vector<double> &residuals){
        MonodomainEquations<DIM>::fill_in_contribution_to_residuals(residuals);
        StorageEnrichmentEquations<DIM*DIM>::fill_in_contribution_to_residuals(residuals);
      }

      ///\short Compute the element's residual Vector and the jacobian matrix
      /// We assume that the residuals vector and jacobian matrix have been
      /// initialised to zero before calling this function
      void fill_in_contribution_to_jacobian(Vector<double> &residuals,
                                       DenseMatrix<double> &jacobian)
      {
        MonodomainEquations<DIM>::fill_in_contribution_to_jacobian(residuals, jacobian);
        StorageEnrichmentEquations<DIM*DIM>::fill_in_contribution_to_jacobian(residuals, jacobian);
      }

      // Add the element's contribution to its residuals vector,
      /// jacobian matrix and mass matrix
      void fill_in_contribution_to_jacobian_and_mass_matrix(
        Vector<double> &residuals, DenseMatrix<double> &jacobian, 
        DenseMatrix<double> &mass_matrix)
      {
        MonodomainEquations<DIM>::fill_in_contribution_to_jacobian_and_mass_matrix(residuals, jacobian, mass_matrix);
        StorageEnrichmentEquations<DIM*DIM>::fill_in_contribution_to_jacobian_and_mass_matrix(residuals, jacobian, mass_matrix);
      }

  };

  //T Face geometries
  template<unsigned DIM, unsigned NNODE_1D>
  class FaceGeometry<TMonodomainWithDELement<DIM, NNODE_1D> >:
  public virtual TElement<DIM-1, NNODE_1D>
  {
  public:
    FaceGeometry() : TElement<DIM-1, NNODE_1D>() {}
  };

  template<unsigned NNODE_1D>
  class FaceGeometry<TMonodomainWithDELement<1, NNODE_1D> >:
  public virtual PointElement
  {
  public:
    FaceGeometry() : PointElement() {}
  };

  //REFINEABLE TMONODOMAINWITHD
}


#endif