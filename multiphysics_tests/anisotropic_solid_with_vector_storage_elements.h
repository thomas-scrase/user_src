//Since the vector data does not change we do not finite difference
// in order to find the entries of the jacobian matrix as we normally would


#ifndef OOMPH_ANISOTROPIC_SOLID_WITH_VECTOR_ELASTICITY_ELEMENTS
#define OOMPH_ANISOTROPIC_SOLID_WITH_VECTOR_ELASTICITY_ELEMENTS

// Config header generated by autoconfig
#ifdef HAVE_CONFIG_H
  #include <oomph-lib-config.h>
#endif

#include "../anisotropic_solid/anisotropic_solid_elements.h"
#include "../toms_utilities/storage_enrichment_elements.h"

namespace oomph
{	
	////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////
	//======================================================================
	//Q ELEMENTS
	//======================================================================
	////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////

	template<unsigned DIM, unsigned NNODE_1D>
	class QAnisotropicWithVectPVDElement	:	public virtual QAnisotropicPVDElement<DIM, NNODE_1D>,	//ADD PIN VECTS AT CONSTRUCTION
												public virtual QStorageEnrichmentElement<DIM, DIM*DIM, NNODE_1D>
	{
	public:
		QAnisotropicWithVectPVDElement() : QAnisotropicPVDElement<DIM, NNODE_1D>(),	//ADD PIN VECTS AT CONSTRUCTION
											QStorageEnrichmentElement<DIM, DIM*DIM, NNODE_1D>()
		{	}
		// ~QAnisotropicWithVectPVDElement();
		
		unsigned required_nvalue(const unsigned &n) const
		{return (QAnisotropicPVDElement<DIM, NNODE_1D>::required_nvalue(n) +
				QStorageEnrichmentElement<DIM, DIM*DIM, NNODE_1D>::required_nvalue(n));}

		void anisotropic_matrix(const unsigned& ipt,
                               const Vector<double> &s,
                               const Vector<double>& xi,
                               const DenseMatrix<double> &g, 
                               const DenseMatrix<double> &G,
                               DenseMatrix<double>& A)
		{
			//number of nodes to loop over for contribution
			const unsigned n_node = this->nnode();
			//our shape function
			Shape psi(n_node);
			//get it's values for the different nodes
			this->shape(s, psi);

			//resize A since we always provide DIM vectors of length DIM
			A.resize(DIM, DIM);
			//loop over vectors
			for(unsigned vec = 0; vec < DIM; vec++){
				//loop over dims
				for(unsigned d = 0; d < DIM; d++){
					//loop over nodes
					for(unsigned l = 0; l < n_node; l++){
						//add the nodal contribution, data is at Min_position + DIM*(number of vectors already added) + dim_of_this_vector_value
						A(d, vec) += this->nodal_value(l, (this->min_index_storage_enrichment() + vec*DIM + d) )*psi[l];
					}
				}
			}
		}

		void output(std::ostream &outfile) {FiniteElement::output(outfile);}

		void output(std::ostream &outfile, const unsigned &nplot)
		{
			//vector of local coordinates
		   	Vector<double> s(DIM);
		   	Vector<double> xi(DIM);
		   
		   	// Tecplot header info
		   	outfile << this->tecplot_zone_string(nplot);
		   
		   	// Loop over plot points
		   	unsigned num_plot_points=this->nplot_points(nplot);
		   	for (unsigned iplot=0;iplot<num_plot_points;iplot++)
		    {
		    	// Get local coordinates of plot point
		     	this->get_s_plot(iplot,nplot,s);
		     
		     	// Get the Lagrangian coordinate
		     	this->interpolated_xi(s,xi);

		     	// Output the position of the plot point
		     	for(unsigned i=0;i<DIM;i++) {outfile << this->interpolated_x(s,i) << " ";}

		     	// Output the vectors
		    }
		   outfile << std::endl;
		   
		   // Write tecplot footer (e.g. FE connectivity lists)
		   this->write_tecplot_zone_footer(outfile,nplot);
		}

		void output(FILE* file_pt){FiniteElement::output(file_pt);}
		void output(FILE* file_pt, const unsigned &n_plot){FiniteElement::output(file_pt,n_plot);}
		void output_fct(std::ostream &outfile, const unsigned &Nplot,FiniteElement::SteadyExactSolutionFctPt exact_soln_pt){FiniteElement::output_fct(outfile,Nplot,exact_soln_pt);}
		void output_fct(std::ostream &outfile, const unsigned &Nplot,const double& time,FiniteElement::UnsteadyExactSolutionFctPt exact_soln_pt){FiniteElement::output_fct(outfile,Nplot,time,exact_soln_pt);}
		void compute_error(std::ostream &outfile,FiniteElement::SteadyExactSolutionFctPt exact_soln_pt,double& error, double& norm){FiniteElement::compute_error(outfile,exact_soln_pt,error,norm);}
		
		void fill_in_contribution_to_residuals(Vector<double> &residuals)
		{
			AnisotropicPVDEquations<DIM>::fill_in_contribution_to_residuals(residuals);
			StorageEnrichmentEquations<DIM*DIM>::fill_in_contribution_to_residuals(residuals);
		}

		void fill_in_contribution_to_jacobian(Vector<double> &residuals,DenseMatrix<double> &jacobian)
		{
			AnisotropicPVDEquations<DIM>::fill_in_contribution_to_jacobian(residuals,jacobian);
			StorageEnrichmentEquations<DIM*DIM>::fill_in_contribution_to_jacobian(residuals,jacobian);
		}

		void fill_in_contribution_to_jacobian_and_mass_matrix(Vector<double> &residuals, DenseMatrix<double> &jacobian, DenseMatrix<double> &mass_matrix)
  		{
		   FiniteElement::fill_in_contribution_to_jacobian_and_mass_matrix(residuals,jacobian,mass_matrix);
		}
	};

	// //Face Geometries
	template<unsigned DIM, unsigned NNODE_1D>
	class FaceGeometry<QAnisotropicWithVectPVDElement<DIM, NNODE_1D> >:
	public virtual SolidQElement<DIM-1,NNODE_1D>
	{
	public:
		FaceGeometry() : SolidQElement<DIM-1,NNODE_1D>() {}
	};

	template<unsigned NNODE_1D>
	class FaceGeometry<QAnisotropicWithVectPVDElement<1, NNODE_1D> >:
	public virtual PointElement
	{
	public:
		FaceGeometry() : PointElement() {}
	};

	////////////////////////////////////////////////////////////////////////
	//======================================================================
	//Q WITH PRESSURE
	//======================================================================
	////////////////////////////////////////////////////////////////////////
	//NNODE_1D HAS NO EFFECT, ENFORCED THAT NNODE_1D=3 FOR QUADRATIC INTERPOLATION OF PRESSURE DOFS
	template<unsigned DIM>
	class QAnisotropicWithVectPVDElementWithPressure	:	public virtual QAnisotropicPVDElementWithPressure<DIM>,	//ADD PIN VECTS AT CONSTRUCTION
															public virtual QStorageEnrichmentElement<DIM, DIM*DIM, 3>
	{
	public:
		QAnisotropicWithVectPVDElementWithPressure() : QAnisotropicPVDElementWithPressure<DIM>(),	//ADD PIN VECTS AT CONSTRUCTION
														QStorageEnrichmentElement<DIM, DIM*DIM, 3>()
		{	}

		// ~QAnisotropicWithVectPVDElementWithPressure();
		
		unsigned required_nvalue(const unsigned &n) const
		{return (QStorageEnrichmentElement<DIM, DIM*DIM, 3>::required_nvalue(n) +
				 QAnisotropicPVDElementWithPressure<DIM>::required_nvalue(n));} 

		void anisotropic_matrix(const unsigned& ipt,
                               const Vector<double> &s,
                               const Vector<double>& xi,
                               const DenseMatrix<double> &g, 
                               const DenseMatrix<double> &G,
                               DenseMatrix<double>& A)
		{
			//number of nodes to loop over for contribution
			const unsigned n_node = this->nnode();
			//our shape function
			Shape psi(n_node);
			//get it's values for the different nodes
			this->shape(s, psi);

			//resize A since we always provide DIM vectors of length DIM
			A.resize(DIM, DIM);
			//loop over vectors
			for(unsigned vec = 0; vec < DIM; vec++){
				//loop over dims
				for(unsigned d = 0; d < DIM; d++){
					//loop over nodes
					for(unsigned l = 0; l < n_node; l++){
						//add the nodal contribution, data is at Min_position + DIM*(number of vectors already added) + dim_of_this_vector_value
						A(d, vec) += this->nodal_value(l, (this->min_index_storage_enrichment() + vec*DIM + d) )*psi[l];
					}
				}
			}
		}

		void output(std::ostream &outfile) {FiniteElement::output(outfile);}

		void output(std::ostream &outfile, const unsigned &nplot)
		{
			//vector of local coordinates
		   	Vector<double> s(DIM);
		   	Vector<double> xi(DIM);
		   
		   	// Tecplot header info
		   	outfile << this->tecplot_zone_string(nplot);
		   
		   	// Loop over plot points
		   	unsigned num_plot_points=this->nplot_points(nplot);
		   	for (unsigned iplot=0;iplot<num_plot_points;iplot++)
		    {
		    	// Get local coordinates of plot point
		     	this->get_s_plot(iplot,nplot,s);
		     
		     	// Get the Lagrangian coordinate
		     	this->interpolated_xi(s,xi);

		     	// Output the position of the plot point
		     	for(unsigned i=0;i<DIM;i++) {outfile << this->interpolated_x(s,i) << " ";}

		     	// Output the vectors

		    }
		   outfile << std::endl;
		   
		   // Write tecplot footer (e.g. FE connectivity lists)
		   this->write_tecplot_zone_footer(outfile,nplot);
		}

		void output(FILE* file_pt){FiniteElement::output(file_pt);}
		void output(FILE* file_pt, const unsigned &n_plot){FiniteElement::output(file_pt,n_plot);}
		void output_fct(std::ostream &outfile, const unsigned &Nplot,FiniteElement::SteadyExactSolutionFctPt exact_soln_pt){FiniteElement::output_fct(outfile,Nplot,exact_soln_pt);}
		void output_fct(std::ostream &outfile, const unsigned &Nplot,const double& time,FiniteElement::UnsteadyExactSolutionFctPt exact_soln_pt){FiniteElement::output_fct(outfile,Nplot,time,exact_soln_pt);}
		void compute_error(std::ostream &outfile,FiniteElement::SteadyExactSolutionFctPt exact_soln_pt,double& error, double& norm){FiniteElement::compute_error(outfile,exact_soln_pt,error,norm);}
		
		void fill_in_contribution_to_residuals(Vector<double> &residuals)
		{
			AnisotropicPVDEquationsWithPressure<DIM>::fill_in_contribution_to_residuals(residuals);
			StorageEnrichmentEquations<DIM*DIM>::fill_in_contribution_to_residuals(residuals);
		}

		void fill_in_contribution_to_jacobian(Vector<double> &residuals,DenseMatrix<double> &jacobian)
		{
			AnisotropicPVDEquationsWithPressure<DIM>::fill_in_contribution_to_jacobian(residuals,jacobian);
			StorageEnrichmentEquations<DIM*DIM>::fill_in_contribution_to_jacobian(residuals,jacobian);
		}

		void fill_in_contribution_to_jacobian_and_mass_matrix(Vector<double> &residuals, DenseMatrix<double> &jacobian, DenseMatrix<double> &mass_matrix)
  		{
		   FiniteElement::fill_in_contribution_to_jacobian_and_mass_matrix(residuals,jacobian,mass_matrix);
		}

	};

	// //Face Geometries
	template<unsigned DIM>
	class FaceGeometry<QAnisotropicWithVectPVDElementWithPressure<DIM> >:
	public virtual SolidQElement<DIM-1,3>
	{
	public:
		FaceGeometry() : SolidQElement<DIM-1,3>() {}
	};

	template<>
	class FaceGeometry<QAnisotropicWithVectPVDElementWithPressure<1> >:
	public virtual PointElement
	{
	public:
		FaceGeometry() : PointElement() {}
	};

	////////////////////////////////////////////////////////////////////////
	//======================================================================
	//Q WITH CONTINUOUS PRESSURE
	//======================================================================
	////////////////////////////////////////////////////////////////////////

	template<unsigned DIM>
	class QAnisotropicWithVectPVDElementWithContinuousPressure	:	public virtual QAnisotropicPVDElementWithContinuousPressure<DIM>,	//ADD PIN VECTS AT CONSTRUCTION
																	public virtual QStorageEnrichmentElement<DIM, DIM*DIM, 3>
	{
	public:
		QAnisotropicWithVectPVDElementWithContinuousPressure() : QAnisotropicPVDElementWithContinuousPressure<DIM>(),	//ADD PIN VECTS AT CONSTRUCTION
											QStorageEnrichmentElement<DIM, DIM*DIM, 3>()
		{	}
		// ~QAnisotropicWithVectPVDElementWithContinuousPressure();
		
		unsigned required_nvalue(const unsigned &n) const
		{return (QStorageEnrichmentElement<DIM, DIM*DIM, 3>::required_nvalue(n) +
				 QAnisotropicPVDElementWithContinuousPressure<DIM>::required_nvalue(n));} 

		//!!!!!!!!!!!!!!!!!!!!!!11
		unsigned vect_min_index_anisotropic_solid_vector_expansion() const {return (this->solid_p_nodal_index() + 1);}

		void anisotropic_matrix(const unsigned& ipt,
                               const Vector<double> &s,
                               const Vector<double>& xi,
                               const DenseMatrix<double> &g, 
                               const DenseMatrix<double> &G,
                               DenseMatrix<double>& A)
		{
			//number of nodes to loop over for contribution
			const unsigned n_node = this->nnode();
			//our shape function
			Shape psi(n_node);
			//get it's values for the different nodes
			this->shape(s, psi);

			//resize A since we always provide DIM vectors of length DIM
			A.resize(DIM, DIM);
			//loop over vectors
			for(unsigned vec = 0; vec < DIM; vec++){
				//loop over dims
				for(unsigned d = 0; d < DIM; d++){
					//loop over nodes
					for(unsigned l = 0; l < n_node; l++){
						//add the nodal contribution, data is at Min_position + DIM*(number of vectors already added) + dim_of_this_vector_value
						A(d, vec) += this->nodal_value(l, (this->min_index_storage_enrichment() + vec*DIM + d) )*psi[l];
					}
				}
			}
		}

		void output(std::ostream &outfile) {FiniteElement::output(outfile);}

		void output(std::ostream &outfile, const unsigned &nplot)
		{
			//vector of local coordinates
		   	Vector<double> s(DIM);
		   	Vector<double> xi(DIM);
		   
		   	// Tecplot header info
		   	outfile << this->tecplot_zone_string(nplot);
		   
		   	// Loop over plot points
		   	unsigned num_plot_points=this->nplot_points(nplot);
		   	for (unsigned iplot=0;iplot<num_plot_points;iplot++)
		    {
		    	// Get local coordinates of plot point
		     	this->get_s_plot(iplot,nplot,s);
		     
		     	// Get the Lagrangian coordinate
		     	this->interpolated_xi(s,xi);

		     	// Output the position of the plot point
		     	for(unsigned i=0;i<DIM;i++) {outfile << this->interpolated_x(s,i) << " ";}

		     	// Output the vectors

		    }
		   outfile << std::endl;
		   
		   // Write tecplot footer (e.g. FE connectivity lists)
		   this->write_tecplot_zone_footer(outfile,nplot);
		}

		void output(FILE* file_pt){FiniteElement::output(file_pt);}
		void output(FILE* file_pt, const unsigned &n_plot){FiniteElement::output(file_pt,n_plot);}
		void output_fct(std::ostream &outfile, const unsigned &Nplot,FiniteElement::SteadyExactSolutionFctPt exact_soln_pt){FiniteElement::output_fct(outfile,Nplot,exact_soln_pt);}
		void output_fct(std::ostream &outfile, const unsigned &Nplot,const double& time,FiniteElement::UnsteadyExactSolutionFctPt exact_soln_pt){FiniteElement::output_fct(outfile,Nplot,time,exact_soln_pt);}
		void compute_error(std::ostream &outfile,FiniteElement::SteadyExactSolutionFctPt exact_soln_pt,double& error, double& norm){FiniteElement::compute_error(outfile,exact_soln_pt,error,norm);}
		
		void fill_in_contribution_to_residuals(Vector<double> &residuals)
		{
			AnisotropicPVDEquationsWithPressure<DIM>::fill_in_contribution_to_residuals(residuals);
			StorageEnrichmentEquations<DIM*DIM>::fill_in_contribution_to_residuals(residuals);
		}

		void fill_in_contribution_to_jacobian(Vector<double> &residuals,DenseMatrix<double> &jacobian)
		{
			AnisotropicPVDEquationsWithPressure<DIM>::fill_in_contribution_to_jacobian(residuals,jacobian);
			StorageEnrichmentEquations<DIM*DIM>::fill_in_contribution_to_jacobian(residuals,jacobian);
		}

		void fill_in_contribution_to_jacobian_and_mass_matrix(Vector<double> &residuals, DenseMatrix<double> &jacobian, DenseMatrix<double> &mass_matrix)
  		{
		   FiniteElement::fill_in_contribution_to_jacobian_and_mass_matrix(residuals,jacobian,mass_matrix);
		}
	};

	//Face elements
	template<unsigned DIM>
	class FaceGeometry<QAnisotropicWithVectPVDElementWithContinuousPressure<DIM> >:
	public virtual SolidQElement<DIM-1,3>
	{
	public:
		FaceGeometry() : SolidQElement<DIM-1,3>() {}
	};

	template<>
	class FaceGeometry<QAnisotropicWithVectPVDElementWithContinuousPressure<1> >:
	public virtual PointElement
	{
	public:
		FaceGeometry() : PointElement() {}
	};

	//REFINEABLE QELEMENTS








































	////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////
	//======================================================================
	//T ELEMENTS
	//======================================================================
	////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////

	template<unsigned DIM, unsigned NNODE_1D>
	class TAnisotropicWithVectPVDElement	:	public virtual TAnisotropicPVDElement<DIM, NNODE_1D>,	//ADD PIN VECTS AT CONSTRUCTION
												public virtual TStorageEnrichmentElement<DIM, DIM*DIM, NNODE_1D>
	{
	public:
		TAnisotropicWithVectPVDElement() : TAnisotropicPVDElement<DIM, NNODE_1D>(),	//ADD PIN VECTS AT CONSTRUCTION
											TStorageEnrichmentElement<DIM, DIM*DIM, NNODE_1D>()
		{	}
		// ~TAnisotropicWithVectPVDElement();
		
		unsigned required_nvalue(const unsigned &n) const
		{return (TStorageEnrichmentElement<DIM, DIM*DIM, NNODE_1D>::required_nvalue(n) +
				 TAnisotropicPVDElement<DIM, NNODE_1D>::required_nvalue(n));}


		void anisotropic_matrix(const unsigned& ipt,
                               const Vector<double> &s,
                               const Vector<double>& xi,
                               const DenseMatrix<double> &g, 
                               const DenseMatrix<double> &G,
                               DenseMatrix<double>& A)
		{
			//number of nodes to loop over for contribution
			const unsigned n_node = this->nnode();
			//our shape function
			Shape psi(n_node);
			//get it's values for the different nodes
			this->shape(s, psi);

			//resize A since we always provide DIM vectors of length DIM
			A.resize(DIM, DIM);
			//loop over vectors
			for(unsigned vec = 0; vec < DIM; vec++){
				//loop over dims
				for(unsigned d = 0; d < DIM; d++){
					//loop over nodes
					for(unsigned l = 0; l < n_node; l++){
						//add the nodal contribution, data is at Min_position + DIM*(number of vectors already added) + dim_of_this_vector_value
						A(d, vec) += this->nodal_value(l, (this->min_index_storage_enrichment() + vec*DIM + d) )*psi[l];
					}
				}
			}
		}

		void output(std::ostream &outfile) {FiniteElement::output(outfile);}

		void output(std::ostream &outfile, const unsigned &nplot)
		{
			//vector of local coordinates
		   	Vector<double> s(DIM);
		   	Vector<double> xi(DIM);
		   
		   	// Tecplot header info
		   	outfile << this->tecplot_zone_string(nplot);
		   
		   	// Loop over plot points
		   	unsigned num_plot_points=this->nplot_points(nplot);
		   	for (unsigned iplot=0;iplot<num_plot_points;iplot++)
		    {
		    	// Get local coordinates of plot point
		     	this->get_s_plot(iplot,nplot,s);
		     
		     	// Get the Lagrangian coordinate
		     	this->interpolated_xi(s,xi);

		     	// Output the position of the plot point
		     	for(unsigned i=0;i<DIM;i++) 
		      	{outfile << this->interpolated_x(s,i) << " ";}

		     	// Output the vectors

		    }
		   outfile << std::endl;
		   
		   // Write tecplot footer (e.g. FE connectivity lists)
		   this->write_tecplot_zone_footer(outfile,nplot);
		}

		void output(FILE* file_pt){FiniteElement::output(file_pt);}
		void output(FILE* file_pt, const unsigned &n_plot){FiniteElement::output(file_pt,n_plot);}
		void output_fct(std::ostream &outfile, const unsigned &Nplot,FiniteElement::SteadyExactSolutionFctPt exact_soln_pt){FiniteElement::output_fct(outfile,Nplot,exact_soln_pt);}
		void output_fct(std::ostream &outfile, const unsigned &Nplot,const double& time,FiniteElement::UnsteadyExactSolutionFctPt exact_soln_pt){FiniteElement::output_fct(outfile,Nplot,time,exact_soln_pt);}
		void compute_error(std::ostream &outfile,FiniteElement::SteadyExactSolutionFctPt exact_soln_pt,double& error, double& norm){FiniteElement::compute_error(outfile,exact_soln_pt,error,norm);}
		
		void fill_in_contribution_to_residuals(Vector<double> &residuals)
		{
			AnisotropicPVDEquations<DIM>::fill_in_contribution_to_residuals(residuals);
			StorageEnrichmentEquations<DIM*DIM>::fill_in_contribution_to_residuals(residuals);
		}

		void fill_in_contribution_to_jacobian(Vector<double> &residuals,DenseMatrix<double> &jacobian)
		{
			AnisotropicPVDEquations<DIM>::fill_in_contribution_to_jacobian(residuals,jacobian);
			StorageEnrichmentEquations<DIM*DIM>::fill_in_contribution_to_jacobian(residuals,jacobian);
		}

		void fill_in_contribution_to_jacobian_and_mass_matrix(Vector<double> &residuals, DenseMatrix<double> &jacobian, DenseMatrix<double> &mass_matrix)
  		{
		   FiniteElement::fill_in_contribution_to_jacobian_and_mass_matrix(residuals,jacobian,mass_matrix);
		}
	};

	//T Face geometries
	template<unsigned DIM, unsigned NNODE_1D>
	class FaceGeometry<TAnisotropicWithVectPVDElement<DIM, NNODE_1D> >:
	public virtual SolidTElement<DIM-1,NNODE_1D>
	{
	public:
		FaceGeometry() : SolidTElement<DIM-1,NNODE_1D>() {}
	};

	template<unsigned NNODE_1D>
	class FaceGeometry<TAnisotropicWithVectPVDElement<1, NNODE_1D> >:
	public virtual PointElement
	{
	public:
		FaceGeometry() : PointElement() {}
	};

	////////////////////////////////////////////////////////////////////////
	//======================================================================
	//T WITH CONTINUOUS PRESSURE
	//======================================================================
	////////////////////////////////////////////////////////////////////////

	template<unsigned DIM>
	class TAnisotropicWithVectPVDElementWithContinuousPressure	:	public virtual TAnisotropicPVDElementWithContinuousPressure<DIM>,	//ADD PIN VECTS AT CONSTRUCTION
																	public virtual TStorageEnrichmentElement<DIM, DIM*DIM, 3>
	{
	public:
		TAnisotropicWithVectPVDElementWithContinuousPressure() : TAnisotropicPVDElementWithContinuousPressure<DIM>(),	//ADD PIN VECTS AT CONSTRUCTION
											TStorageEnrichmentElement<DIM, DIM*DIM, 3>()
		{	}
		// ~TAnisotropicWithVectPVDElementWithContinuousPressure();
		
		unsigned required_nvalue(const unsigned &n) const
		{return (TStorageEnrichmentElement<DIM, DIM*DIM, 3>::required_nvalue(n) +
				 TAnisotropicPVDElementWithContinuousPressure<DIM>::required_nvalue(n));} 

		//!!!!!!!!!!!!!!!!!!!!!!11
		unsigned vect_min_index_anisotropic_solid_vector_expansion() const {return (this->solid_p_nodal_index() + 1);}

		void anisotropic_matrix(const unsigned& ipt,
                               const Vector<double> &s,
                               const Vector<double>& xi,
                               const DenseMatrix<double> &g, 
                               const DenseMatrix<double> &G,
                               DenseMatrix<double>& A)
		{
			//number of nodes to loop over for contribution
			const unsigned n_node = this->nnode();
			//our shape function
			Shape psi(n_node);
			//get it's values for the different nodes
			this->shape(s, psi);

			//resize A since we always provide DIM vectors of length DIM
			A.resize(DIM, DIM);
			//loop over vectors
			for(unsigned vec = 0; vec < DIM; vec++){
				//loop over dims
				for(unsigned d = 0; d < DIM; d++){
					//loop over nodes
					for(unsigned l = 0; l < n_node; l++){
						//add the nodal contribution, data is at Min_position + DIM*(number of vectors already added) + dim_of_this_vector_value
						A(d, vec) += this->nodal_value(l, (this->min_index_storage_enrichment() + vec*DIM + d) )*psi[l];
					}
				}
			}
		}

		void output(std::ostream &outfile) {FiniteElement::output(outfile);}

		void output(std::ostream &outfile, const unsigned &nplot)
		{
			//vector of local coordinates
		   	Vector<double> s(DIM);
		   	Vector<double> xi(DIM);
		   
		   	// Tecplot header info
		   	outfile << this->tecplot_zone_string(nplot);
		   
		   	// Loop over plot points
		   	unsigned num_plot_points=this->nplot_points(nplot);
		   	for (unsigned iplot=0;iplot<num_plot_points;iplot++)
		    {
		    	// Get local coordinates of plot point
		     	this->get_s_plot(iplot,nplot,s);
		     
		     	// Get the Lagrangian coordinate
		     	this->interpolated_xi(s,xi);

		     	// Output the position of the plot point
		     	for(unsigned i=0;i<DIM;i++) {outfile << this->interpolated_x(s,i) << " ";}

		     	// Output the vectors

		    }
		   outfile << std::endl;
		   
		   // Write tecplot footer (e.g. FE connectivity lists)
		   this->write_tecplot_zone_footer(outfile,nplot);
		}

		void output(FILE* file_pt){FiniteElement::output(file_pt);}
		void output(FILE* file_pt, const unsigned &n_plot){FiniteElement::output(file_pt,n_plot);}
		void output_fct(std::ostream &outfile, const unsigned &Nplot,FiniteElement::SteadyExactSolutionFctPt exact_soln_pt){FiniteElement::output_fct(outfile,Nplot,exact_soln_pt);}
		void output_fct(std::ostream &outfile, const unsigned &Nplot,const double& time,FiniteElement::UnsteadyExactSolutionFctPt exact_soln_pt){FiniteElement::output_fct(outfile,Nplot,time,exact_soln_pt);}
		void compute_error(std::ostream &outfile,FiniteElement::SteadyExactSolutionFctPt exact_soln_pt,double& error, double& norm){FiniteElement::compute_error(outfile,exact_soln_pt,error,norm);}
		
		void fill_in_contribution_to_residuals(Vector<double> &residuals)
		{
			AnisotropicPVDEquationsWithPressure<DIM>::fill_in_contribution_to_residuals(residuals);
			StorageEnrichmentEquations<DIM*DIM>::fill_in_contribution_to_residuals(residuals);
		}

		void fill_in_contribution_to_jacobian(Vector<double> &residuals,DenseMatrix<double> &jacobian)
		{
			AnisotropicPVDEquationsWithPressure<DIM>::fill_in_contribution_to_jacobian(residuals,jacobian);
			StorageEnrichmentEquations<DIM*DIM>::fill_in_contribution_to_jacobian(residuals,jacobian);
		}

		void fill_in_contribution_to_jacobian_and_mass_matrix(Vector<double> &residuals, DenseMatrix<double> &jacobian, DenseMatrix<double> &mass_matrix)
  		{
		   FiniteElement::fill_in_contribution_to_jacobian_and_mass_matrix(residuals,jacobian,mass_matrix);
		}
	};

	//Face Geometries
	template<unsigned DIM>
	class FaceGeometry<TAnisotropicWithVectPVDElementWithContinuousPressure<DIM> >:
	public virtual SolidTElement<DIM-1,3>
	{
	public:
		FaceGeometry() : SolidTElement<DIM-1,3>() {}
	};

	template<>
	class FaceGeometry<TAnisotropicWithVectPVDElementWithContinuousPressure<1> >:
	public virtual PointElement
	{
	public:
		FaceGeometry() : PointElement() {}
	};

	//Refineable TElements
}

#endif