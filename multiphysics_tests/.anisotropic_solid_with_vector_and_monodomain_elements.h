//======================================================================
//Elements which contain Anisotropic Solid with Vector Storage and
//Monodomain Capabilities...
//Changes:
//		+	get_diff_monodomain is overridden to compute D at each
//			solve using the anisotropy vectors and diffusion_coefficients
//		+	Storage is added for the diffusion_coefficients and an inte-
//			rpolating function for which is added.
//
//STORAGE LOCATIONS:
//				0			1						1+NVECT*DIM
//				u_mono 		anisotropic vectors 	diffusion coefficients
//======================================================================



#ifndef OOMPH_ANISOTROPIC_SOLID_WITH_VECTOR_AND_MONODOMAIN_ELASTICITY_ELEMENTS
#define OOMPH_ANISOTROPIC_SOLID_WITH_VECTOR_AND_MONODOMAIN_ELASTICITY_ELEMENTS

// Config header generated by autoconfig
#ifdef HAVE_CONFIG_H
  #include <oomph-lib-config.h>
#endif

#include "../monodomain/monodomain_elements.h"
#include "../anisotropic_solid/anisotropic_solid_elements.h"
#include "../anisotropic_solid/anisotropic_solid_with_vector_storage_elements.h"
#include "diffusion_coefficient_expansion_elements.h"

namespace oomph
{	
	////////////////////////////////////////////////////////////////////////
  	////////////////////////////////////////////////////////////////////////
  	////////////////////////////////////////////////////////////////////////
  	//======================================================================
  	//Q ELEMENTS
  	//======================================================================
  	////////////////////////////////////////////////////////////////////////
  	////////////////////////////////////////////////////////////////////////
  	////////////////////////////////////////////////////////////////////////

	template<unsigned DIM, unsigned NVECT, unsigned NNODE_1D>
	class QAnisotropicWithVectAndMonoPVDElement : 	public virtual QAnisotropicWithVectPVDElement<DIM, NVECT, NNODE_1D>,
													public virtual QMonodomainElement<DIM, NNODE_1D>,
													public virtual QDiffusionCoefficientExpansionElement<DIM, NVECT, NNODE_1D>
	{
	public:
		QAnisotropicWithVectAndMonoPVDElement() : 	QAnisotropicWithVectPVDElement<DIM, NVECT, NNODE_1D>(),
													QMonodomainElement<DIM, NNODE_1D>(),
													QDiffusionCoefficientExpansionElement<DIM, NVECT, NNODE_1D>()
		{	}
		// ~QAnisotropicWithVectAndMonoPVDElement();

		unsigned required_nvalue(const unsigned &n) const
		{return (QAnisotropicWithVectPVDElement<DIM, NVECT, NNODE_1D>::required_nvalue(n) +
				QMonodomainElement<DIM, NNODE_1D>::required_nvalue(n) +
				QDiffusionCoefficientExpansionElement<DIM, NVECT, NNODE_1D>::required_nvalue(n));}

		unsigned vect_min_index_anisotropic_solid_vector_expansion() const {return (this->u_index_monodomain() + 1);}

		//Storage indexes for the 
		unsigned diffusion_coefficient_min_index_expansion() const {return this->vect_max_index_anisotropic_solid_vector_expansion() + 1;}

		void get_diff_monodomain(const unsigned& ipt,
                            	const Vector<double> &s,
                                const Vector<double>& x,
                                DenseMatrix<double>& D) const
		{
			//setup the shape functions and their derivatives
			unsigned n_node = this->nnode();
			const unsigned n_position_type = this->nnodal_position_type();
			Shape psi(n_node, n_position_type);
			DShape dpsidxi(n_node,n_position_type,DIM);
			(void) this->dshape_lagrangian(s,psi,dpsidxi);

			Vector<double> vect(DIM);
			double dcoeff;

			//zero D first
			for(unsigned i=0; i<DIM; i++){
					for(unsigned j=0; j<DIM; j++){
						D(i,j) = 0.0;
				}
			}

			for(unsigned v=0; v<NVECT; v++){
				this->interpolated_vector_anisotropic_solid_vector_expansion(ipt, s, x, v, vect);
				this->interpolated_diffusion_coefficient(ipt, s, x, v, dcoeff);

				for(unsigned i=0; i<DIM; i++){
					for(unsigned j=0; j<DIM; j++){
						D(i,j) += vect[i]*vect[j]*dcoeff;
					}
				}
			}
		}

		void output(std::ostream &outfile) {FiniteElement::output(outfile);}

		void output(std::ostream &outfile, const unsigned &nplot)
		{
			//vector of local coordinates
			Vector<double> s(DIM);
			Vector<double> xi(DIM);
			   
			// Tecplot header info
			outfile << this->tecplot_zone_string(nplot);
			   
			// Loop over plot points
			unsigned num_plot_points=this->nplot_points(nplot);
			for (unsigned iplot=0;iplot<num_plot_points;iplot++)
			{
				// Get local coordinates of plot point
				this->get_s_plot(iplot,nplot,s);
				     
				// Get the Lagrangian coordinate
				this->interpolated_xi(s,xi);

				for(unsigned i=0;i<DIM;i++) {outfile << this->interpolated_x(s,i) << " ";}

				// Output the vectors
		      	Vector<double> Vect(DIM);
		     	for(int i=0; i<NVECT;i++){
		     		this->interpolated_vector_anisotropic_solid_vector_expansion(0,s,xi,i,Vect);
		     		for(int j=0; j<DIM; j++){
		     			outfile << Vect[j] << " ";
		     		}
		     	}
		     	DenseMatrix<double> Dprint(DIM);
		     	get_diff_monodomain(0, s, xi, Dprint);
		     	for(unsigned i=0; i<DIM; i++){
		     		for(unsigned j=i; j<DIM; j++){
		     			outfile << Dprint(i,j) << " ";
		     		}
		     	}
			}

		     outfile << std::endl;

		     this->write_tecplot_zone_footer(outfile,nplot);
		}

		void output(FILE* file_pt){FiniteElement::output(file_pt);}

		void output(FILE* file_pt, const unsigned &n_plot){FiniteElement::output(file_pt,n_plot);}

		void output_fct(std::ostream &outfile, const unsigned &Nplot,FiniteElement::SteadyExactSolutionFctPt exact_soln_pt){FiniteElement::output_fct(outfile,Nplot,exact_soln_pt);}

		void output_fct(std::ostream &outfile, const unsigned &Nplot,const double& time,FiniteElement::UnsteadyExactSolutionFctPt exact_soln_pt){FiniteElement::output_fct(outfile,Nplot,time,exact_soln_pt);}
	
		// void compute_norm(double& el_norm){QUnsteadyHeatElement<DIM,3>::compute_norm(el_norm);}

		void compute_error(std::ostream &outfile,FiniteElement::UnsteadyExactSolutionFctPt exact_soln_pt,const double& time,double& error, double& norm){FiniteElement::compute_error(outfile,exact_soln_pt,time,error,norm);}

		void compute_error(std::ostream &outfile,FiniteElement::SteadyExactSolutionFctPt exact_soln_pt,double& error, double& norm){FiniteElement::compute_error(outfile,exact_soln_pt,error,norm);}

		void fill_in_contribution_to_residuals(Vector<double> &residuals)
		{
			AnisotropicPVDEquations<DIM>::fill_in_contribution_to_residuals(residuals);
			AnisotropicSolidVectorExpansionEquations<DIM,NVECT>::fill_in_contribution_to_residuals(residuals);
			DiffusionCoefficientExpansionEquations<DIM,NVECT>::fill_in_contribution_to_residuals(residuals);
			MonodomainEquations<DIM>::fill_in_contribution_to_residuals(residuals);
		}

		void fill_in_contribution_to_jacobian(Vector<double> &residuals,DenseMatrix<double> &jacobian)
		{
			FiniteElement::fill_in_contribution_to_jacobian(residuals,jacobian);
		}

		void fill_in_contribution_to_jacobian_and_mass_matrix(Vector<double> &residuals, DenseMatrix<double> &jacobian, DenseMatrix<double> &mass_matrix)
  		{
		   FiniteElement::fill_in_contribution_to_jacobian_and_mass_matrix(residuals,jacobian,mass_matrix);
		}
	};

	//Face Geometries
	template<unsigned DIM, unsigned NVECT, unsigned NNODE_1D>
	class FaceGeometry<QAnisotropicWithVectAndMonoPVDElement<DIM, NVECT,NNODE_1D> >:
	public virtual SolidQElement<DIM-1,NNODE_1D>
	{
	public:
		FaceGeometry() : SolidQElement<DIM-1,NNODE_1D>() {}
	};

	template<unsigned NVECT, unsigned NNODE_1D>
	class FaceGeometry<QAnisotropicWithVectAndMonoPVDElement<1, NVECT, NNODE_1D> >:
	public virtual PointElement
	{
	public:
		FaceGeometry() : PointElement() {}
	};

	////////////////////////////////////////////////////////////////////////
	//======================================================================
	//Q WITH PRESSURE
	//======================================================================
	////////////////////////////////////////////////////////////////////////
	template<unsigned DIM, unsigned NVECT>
	class QAnisotropicWithVectAndMonoPVDElementWithPressure : public virtual QAnisotropicWithVectPVDElementWithPressure<DIM, NVECT>,
															public virtual QMonodomainElement<DIM, 3>,
															public virtual QDiffusionCoefficientExpansionElement<DIM, NVECT, 3>
	{
	public:
		QAnisotropicWithVectAndMonoPVDElementWithPressure() : QAnisotropicWithVectPVDElementWithPressure<DIM, NVECT>(),
															QMonodomainElement<DIM, 3>(),
															QDiffusionCoefficientExpansionElement<DIM, NVECT, 3>()
		{	}
		// ~QAnisotropicWithVectAndMonoPVDElementWithPressure();

		unsigned required_nvalue(const unsigned &n) const
		{return (QAnisotropicWithVectPVDElementWithPressure<DIM, NVECT>::required_nvalue(n) +
				QMonodomainElement<DIM, 3>::required_nvalue(n) +
				QDiffusionCoefficientExpansionElement<DIM, NVECT, 3>::required_nvalue(n));}

		// unsigned u_index_monodomain() const {return 1;}

		unsigned vect_min_index_anisotropic_solid_vector_expansion() const {return (this->u_index_monodomain() + 1);}

		//Storage indexes for the 
		unsigned diffusion_coefficient_min_index_expansion() const {return this->vect_max_index_anisotropic_solid_vector_expansion();}

		void get_diff_monodomain(const unsigned& ipt,
                            	const Vector<double> &s,
                                const Vector<double>& x,
                                DenseMatrix<double>& D) const
		{
			//setup the shape functions and their derivatives
			unsigned n_node = this->nnode();
			const unsigned n_position_type = this->nnodal_position_type();
			Shape psi(n_node, n_position_type);
			DShape dpsidxi(n_node,n_position_type,DIM);
			(void) this->dshape_lagrangian(s,psi,dpsidxi);

			Vector<double> vect(DIM);
			double dcoeff;

			//zero D first
			for(unsigned i=0; i<DIM; i++){
					for(unsigned j=0; j<DIM; j++){
						D(i,j) = 0.0;
				}
			}

			for(unsigned v=0; v<NVECT; v++){
				this->interpolated_vector_anisotropic_solid_vector_expansion(ipt, s, x, v, vect);
				this->interpolated_diffusion_coefficient(ipt, s, x, v, dcoeff);

				for(unsigned i=0; i<DIM; i++){
					for(unsigned j=0; j<DIM; j++){
						D(i,j) += vect[i]*vect[j]*dcoeff;
					}
				}
			}
		}

		void output(std::ostream &outfile) {FiniteElement::output(outfile);}

		void output(std::ostream &outfile, const unsigned &nplot)
		{
			//vector of local coordinates
			unsigned Dim = this->dim();
			Vector<double> s(DIM);
			Vector<double> xi(DIM);
			DenseMatrix<double> stress_or_strain(Dim, Dim);
			double gamma;
			unsigned ipt=0;

			// Tecplot header info
			outfile << this->tecplot_zone_string(nplot);
			   
			// Loop over plot points
			unsigned num_plot_points=this->nplot_points(nplot);
			for (unsigned iplot=0;iplot<num_plot_points;iplot++)
			{
				//Ouput local coordinates of plot point
				this->get_s_plot(iplot,nplot,s);
				this->interpolated_x(s,xi);
				for(unsigned i=0;i<DIM;i++) {outfile << this->interpolated_x(s,i) << " ";}

				//Output the Lagrangian coordinate
				// for(unsigned i=0;i<DIM;i++) {outfile << this->interpolated_xi(s,i) << " ";} //!!!

				//!!!!!
				//Output Isotropic growth
			   	// this->get_isotropic_growth(ipt,s,xi,gamma);
				// outfile << gamma << " ";
			   	this->get_strain(s,stress_or_strain);
			   	for(unsigned i=0;i<Dim;i++){
			    	for(unsigned j=0;j<=i;j++){
			       		outfile << stress_or_strain(j,i) << " " ;
			      	}
			    }
				//!!!!!

				// Output the vectors
		      	Vector<double> Vect(DIM);
		     	for(int i=0; i<NVECT;i++){
		     		this->interpolated_vector_anisotropic_solid_vector_expansion(0,s,xi,i,Vect);
		     		for(int j=0; j<DIM; j++){
		     			outfile << Vect[j] << " ";
		     		}
		     	}

		     	outfile << this->interpolated_u_monodomain(s) << " ";
			    const unsigned n_node = this->nnode();
	 			Shape psi(n_node);
	 			DShape dpsidx(n_node,Dim);
			    (void)this->dshape_eulerian(s,psi,dpsidx);
			   	Vector<double> interpolated_dudx(Dim,0.0);
			   	double dudt = 0.0;
			   	for(unsigned n=0;n<n_node;n++){
			    	const double u_ = this->nodal_value(n,0);
					dudt += this->du_dt_monodomain(n)*psi(n);
			    	for(unsigned i=0;i<Dim;i++){
			    		interpolated_dudx[i] += u_*dpsidx(n,i);
			    	}
			    }

			   	outfile << dudt << " ";

			   	for(unsigned i=0;i<Dim;i++){
			    	outfile << interpolated_dudx[i]  << " ";
			    }

		     	//Output diffusion matrix
		     	DenseMatrix<double> Dprint(DIM);
		     	get_diff_monodomain(0, s, xi, Dprint);
		     	for(unsigned i=0; i<DIM; i++){
		     		for(unsigned j=i; j<DIM; j++){
		     			outfile << Dprint(i,j) << " ";
		     		}
		     	}

		     	outfile << std::endl;
			}

		     this->write_tecplot_zone_footer(outfile,nplot);
		}

		void output(FILE* file_pt){FiniteElement::output(file_pt);}

		void output(FILE* file_pt, const unsigned &n_plot){FiniteElement::output(file_pt,n_plot);}

		void output_fct(std::ostream &outfile, const unsigned &Nplot,FiniteElement::SteadyExactSolutionFctPt exact_soln_pt){FiniteElement::output_fct(outfile,Nplot,exact_soln_pt);}

		void output_fct(std::ostream &outfile, const unsigned &Nplot,const double& time,FiniteElement::UnsteadyExactSolutionFctPt exact_soln_pt){FiniteElement::output_fct(outfile,Nplot,time,exact_soln_pt);}
	
		// void compute_norm(double& el_norm){QUnsteadyHeatElement<DIM,3>::compute_norm(el_norm);}

		void compute_error(std::ostream &outfile,FiniteElement::UnsteadyExactSolutionFctPt exact_soln_pt,const double& time,double& error, double& norm){FiniteElement::compute_error(outfile,exact_soln_pt,time,error,norm);}

		void compute_error(std::ostream &outfile,FiniteElement::SteadyExactSolutionFctPt exact_soln_pt,double& error, double& norm){FiniteElement::compute_error(outfile,exact_soln_pt,error,norm);}

		void fill_in_contribution_to_residuals(Vector<double> &residuals)
		{
			AnisotropicPVDEquationsWithPressure<DIM>::fill_in_contribution_to_residuals(residuals);
			AnisotropicSolidVectorExpansionEquations<DIM,NVECT>::fill_in_contribution_to_residuals(residuals);
			DiffusionCoefficientExpansionEquations<DIM,NVECT>::fill_in_contribution_to_residuals(residuals);
			MonodomainEquations<DIM>::fill_in_contribution_to_residuals(residuals);
		}

		void fill_in_contribution_to_jacobian(Vector<double> &residuals,DenseMatrix<double> &jacobian)
		{
			FiniteElement::fill_in_contribution_to_jacobian(residuals,jacobian);
		}

		void fill_in_contribution_to_jacobian_and_mass_matrix(Vector<double> &residuals, DenseMatrix<double> &jacobian, DenseMatrix<double> &mass_matrix)
  		{
		   FiniteElement::fill_in_contribution_to_jacobian_and_mass_matrix(residuals,jacobian,mass_matrix);
		}
	};

	//Face Geometries
	template<unsigned DIM, unsigned NVECT>
	class FaceGeometry<QAnisotropicWithVectAndMonoPVDElementWithPressure<DIM, NVECT> >:
	public virtual SolidQElement<DIM-1,3>
	{
	public:
		FaceGeometry() : SolidQElement<DIM-1,3>() {}
	};

	template<unsigned NVECT>
	class FaceGeometry<QAnisotropicWithVectAndMonoPVDElementWithPressure<1, NVECT> >:
	public virtual PointElement
	{
	public:
		FaceGeometry() : PointElement() {}
	};

	////////////////////////////////////////////////////////////////////////
	//======================================================================
	//Q WITH CONTINUOUS PRESSURE
	//======================================================================
	////////////////////////////////////////////////////////////////////////

	//REFINEABLE QELEMENTS

	


































































	////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////
	//======================================================================
	//T ELEMENTS
	//======================================================================
	////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////

	template<unsigned DIM, unsigned NVECT, unsigned NNODE_1D>
	class TAnisotropicWithVectAndMonoPVDElement : public virtual TAnisotropicWithVectPVDElement<DIM, NVECT, NNODE_1D>,
												public virtual TMonodomainElement<DIM, NNODE_1D>,
												public virtual TDiffusionCoefficientExpansionElement<DIM, NVECT, NNODE_1D>
	{
	public:
		TAnisotropicWithVectAndMonoPVDElement() : TAnisotropicWithVectPVDElement<DIM, NVECT, NNODE_1D>(),
													TMonodomainElement<DIM, NNODE_1D>(),
													TDiffusionCoefficientExpansionElement<DIM, NVECT, NNODE_1D>()
		{	}
		// ~TAnisotropicWithVectAndMonoPVDElement();

		unsigned required_nvalue(const unsigned &n) const
		{return (TAnisotropicWithVectPVDElement<DIM, NVECT, NNODE_1D>::required_nvalue(n) +
				TMonodomainElement<DIM, NNODE_1D>::required_nvalue(n) +
				TDiffusionCoefficientExpansionElement<DIM, NVECT, NNODE_1D>::required_nvalue(n));}

		unsigned vect_min_index_anisotropic_solid_vector_expansion() const {return (this->u_index_monodomain() + 1);}

		//Storage indexes for the 
		unsigned diffusion_coefficients_min_index() const {return this->vect_max_index_anisotropic_solid_vector_expansion();}

		void get_diff_monodomain(const unsigned& ipt,
                            	const Vector<double> &s,
                                const Vector<double>& x,
                                DenseMatrix<double>& D) const
		{
			//setup the shape functions and their derivatives
			unsigned n_node = this->nnode();
			const unsigned n_position_type = this->nnodal_position_type();
			Shape psi(n_node, n_position_type);
			DShape dpsidxi(n_node,n_position_type,DIM);
			(void) this->dshape_lagrangian(s,psi,dpsidxi);

			Vector<double> vect(DIM);
			double dcoeff;

			//zero D first
			for(unsigned i=0; i<DIM; i++){
					for(unsigned j=0; j<DIM; j++){
						D(i,j) = 0.0;
				}
			}

			for(unsigned v=0; v<NVECT; v++){
				this->interpolated_vector_anisotropic_solid_vector_expansion(ipt, s, x, v, vect);
				this->interpolated_diffusion_coefficient(ipt, s, x, v, dcoeff);

				for(unsigned i=0; i<DIM; i++){
					for(unsigned j=0; j<DIM; j++){
						D(i,j) += vect[i]*vect[j]*dcoeff;
					}
				}
			}
		}

		void output(std::ostream &outfile) {FiniteElement::output(outfile);}

		void output(std::ostream &outfile, const unsigned &nplot)
		{
			//vector of local coordinates
			Vector<double> s(DIM);
			Vector<double> xi(DIM);
			   
			// Tecplot header info
			outfile << this->tecplot_zone_string(nplot);
			   
			// Loop over plot points
			unsigned num_plot_points=this->nplot_points(nplot);
			for (unsigned iplot=0;iplot<num_plot_points;iplot++)
			{
				// Get local coordinates of plot point
				this->get_s_plot(iplot,nplot,s);
				     
				// Get the Lagrangian coordinate
				this->interpolated_xi(s,xi);

				for(unsigned i=0;i<DIM;i++) {outfile << this->interpolated_x(s,i) << " ";}

				// Output the vectors
		      	Vector<double> Vect(DIM);
		     	for(int i=0; i<NVECT;i++){
		     		this->interpolated_vector_anisotropic_solid_vector_expansion(0,s,xi,i,Vect);
		     		for(int j=0; j<DIM; j++){
		     			outfile << Vect[j] << " ";
		     		}
		     	}
		     	DenseMatrix<double> Dprint(DIM);
		     	get_diff_monodomain(0, s, xi, Dprint);
		     	for(unsigned i=0; i<DIM; i++){
		     		for(unsigned j=i; j<DIM; j++){
		     			outfile << Dprint(i,j) << " ";
		     		}
		     	}
			}

		     outfile << std::endl;

		     this->write_tecplot_zone_footer(outfile,nplot);
		}

		void output(FILE* file_pt){FiniteElement::output(file_pt);}

		void output(FILE* file_pt, const unsigned &n_plot){FiniteElement::output(file_pt,n_plot);}

		void output_fct(std::ostream &outfile, const unsigned &Nplot,FiniteElement::SteadyExactSolutionFctPt exact_soln_pt){FiniteElement::output_fct(outfile,Nplot,exact_soln_pt);}

		void output_fct(std::ostream &outfile, const unsigned &Nplot,const double& time,FiniteElement::UnsteadyExactSolutionFctPt exact_soln_pt){FiniteElement::output_fct(outfile,Nplot,time,exact_soln_pt);}
	
		// void compute_norm(double& el_norm){QUnsteadyHeatElement<DIM,3>::compute_norm(el_norm);}

		void compute_error(std::ostream &outfile,FiniteElement::UnsteadyExactSolutionFctPt exact_soln_pt,const double& time,double& error, double& norm){FiniteElement::compute_error(outfile,exact_soln_pt,time,error,norm);}

		void compute_error(std::ostream &outfile,FiniteElement::SteadyExactSolutionFctPt exact_soln_pt,double& error, double& norm){FiniteElement::compute_error(outfile,exact_soln_pt,error,norm);}

		void fill_in_contribution_to_residuals(Vector<double> &residuals)
		{
			AnisotropicPVDEquations<DIM>::fill_in_contribution_to_residuals(residuals);
			AnisotropicSolidVectorExpansionEquations<DIM,NVECT>::fill_in_contribution_to_residuals(residuals);
			DiffusionCoefficientExpansionEquations<DIM,NVECT>::fill_in_contribution_to_residuals(residuals);
			MonodomainEquations<DIM>::fill_in_contribution_to_residuals(residuals);
		}

		void fill_in_contribution_to_jacobian(Vector<double> &residuals,DenseMatrix<double> &jacobian)
		{
			FiniteElement::fill_in_contribution_to_jacobian(residuals,jacobian);
		}

		void fill_in_contribution_to_jacobian_and_mass_matrix(Vector<double> &residuals, DenseMatrix<double> &jacobian, DenseMatrix<double> &mass_matrix)
  		{
		   FiniteElement::fill_in_contribution_to_jacobian_and_mass_matrix(residuals,jacobian,mass_matrix);
		}
	};

	//Face Geometries
	template<unsigned DIM, unsigned NVECT, unsigned NNODE_1D>
	class FaceGeometry<TAnisotropicWithVectAndMonoPVDElement<DIM, NVECT,NNODE_1D> >:
	public virtual SolidTElement<DIM-1,NNODE_1D>
	{
	public:
		FaceGeometry() : SolidTElement<DIM-1,NNODE_1D>() {}
	};

	template<unsigned NVECT, unsigned NNODE_1D>
	class FaceGeometry<TAnisotropicWithVectAndMonoPVDElement<1, NVECT, NNODE_1D> >:
	public virtual PointElement
	{
	public:
		FaceGeometry() : PointElement() {}
	};

	////////////////////////////////////////////////////////////////////////
	//======================================================================
	//T WITH CONTINUOUS PRESSURE
	//======================================================================
	////////////////////////////////////////////////////////////////////////

	//REFINEABLE TELEMENTS
}

#endif