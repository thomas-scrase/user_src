#ifndef OOMPH_ELECTRO_MECHANICAL_FLUID_MULTIPHYSICS_ELEMENTS_HEADER
#define OOMPH_ELECTRO_MECHANICAL_FLUID_MULTIPHYSICS_ELEMENTS_HEADER
	
// Config header generated by autoconfig
#ifdef HAVE_CONFIG_H
  #include <oomph-lib-config.h>
#endif

#include "../cell_solvers/cell_solvers_fully_segregated.h"
// #include "../anisotropic_constitutive/anisotropic_constitutive_laws.h"
#include "../anisotropic_solid/anisotropic_solid_elements.h"

namespace oomph
{
	template<class SOLID_ELEMENT, class EXT_CELL_SOLVER_ELEMENT>
	class AnisotropicSolidElementWithExternalCellElement :
	public virtual SOLID_ELEMENT,
	public virtual ElementWithExternalElement
	{
	public:
		AnisotropicSolidElementWithExternalCellElement() :
		SOLID_ELEMENT(),
		ElementWithExternalElement()
		{
			ElementWithExternalElement::set_ninteraction(1);
		}

		void fill_in_contribution_to_residuals(Vector<double>& residuals, DenseMatrix<double>& jacobian)
		{
			SOLID_ELEMENT::fill_in_contribution_to_residuals(residuals, jacobian);
		}

		void fill_in_contribution_to_jacobian(Vector<double>& residuals, DenseMatrix<double>& jacobian)
		{
			SOLID_ELEMENT::fill_in_contribution_to_jacobian(residuals, jacobian);
			// FiniteElement::fill_in_contribution_to_jacobian(residuals, jacobian);
		}

		void identify_field_data_for_interactions(std::set<std::pair<Data*,unsigned> > &paired_field_data) override
		{
			FiniteElement::identify_field_data_for_interactions(paired_field_data);
		}

		void describe_local_dofs(std::ostream &out, const std::string &current_string) const
		{
			SOLID_ELEMENT::describe_local_dofs(out, current_string);
		}

		//Get the preferential vectors from the external cell element
		inline void preferential_vectors(const unsigned& ipt,
                                     const Vector<double> &s,
                                     const Vector<double>& xi,
                                     Vector<Vector<double>>& A) override
		{
			//Get preferential vectors from the external cell element
			dynamic_cast<EXT_CELL_SOLVER_ELEMENT*>(this->external_element_pt(0, ipt))->get_interpolated_cell_alignment(this->external_element_local_coord(0, ipt), A);
		#ifdef PARANOID
			for(unsigned i=0; i<A.size(); i++)
			{
				double len = 0;
				for(unsigned j=0; j<A[i].size(); j++)
				{
					len += (A[i])[j]*(A[i])[j];
				}
				if(std::abs(len-1.0)>1e-9)
				{
					oomph_info << len << std::endl;
					for(unsigned j=0; j<A[i].size(); j++)
					{
						oomph_info << (A[i])[j] << std::endl;
					}
					throw OomphLibError("Preferential vector in anisotropic solid is not normal",
															OOMPH_CURRENT_FUNCTION,
															OOMPH_EXCEPTION_LOCATION);
				}
			}
		#endif
		}

		//Get the strain generated by the cell model in each of the preferential vector directions,
		// we assume that there is no strain generated other than in the first (fibre) preferential
		// vector direction
		inline void driving_strain(const unsigned& ipt,
                               const Vector<double>& s,
                               const Vector<double>& xi,
                               Vector<double>& V) override
		{
			V.resize(this->dim(), 0.0);
			V[0] = (dynamic_cast<EXT_CELL_SOLVER_ELEMENT*>(this->external_element_pt(0, ipt)))->get_interpolated_active_strain_from_cell_model(this->external_element_local_coord(0, ipt));
		}

	};


	//Explicit definition of the face geometry
	template<class SOLID_ELEMENT, class EXT_CELL_SOLVER_ELEMENT>
	class FaceGeometry<AnisotropicSolidElementWithExternalCellElement<SOLID_ELEMENT, EXT_CELL_SOLVER_ELEMENT>> : public virtual FaceGeometry<SOLID_ELEMENT>
	{
	public:
		FaceGeometry() : FaceGeometry<SOLID_ELEMENT>() {}
		
	};

}

#endif