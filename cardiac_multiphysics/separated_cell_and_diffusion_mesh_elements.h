#ifndef	OOMPH_SEPARATED_CELL_AND_DIFFUSION_MESH_ELEMENTS_HEADER
#define OOMPH_SEPARATED_CELL_AND_DIFFUSION_MESH_ELEMENTS_HEADER

// Config header generated by autoconfig
#ifdef HAVE_CONFIG_H
  #include <oomph-lib-config.h>
#endif

// #include "../toms_utilities/diff_augmented_cell_wrapper.h"

//oomph-lib headers
#include "../generic/refineable_quad_element.h"
#include "../generic/refineable_brick_element.h"
#include "../generic/error_estimator.h"

#include "../cell_solvers/cell_solvers_fully_partitioned.h"

// //Solid elements for the external solid element for geometric data
// #include "../anisotropic_solid/anisotropic_solid_elements.h"


// namespace oomph
// {
// 	//Cell solver with external diffusion element

// 	template<class CELL_SOLVER_ELEMENT, class EXT_DIFFUSION_ELEMENT>
// 	class CellElementWithExternalDiffusionElement :
// 		public virtual CELL_SOLVER_ELEMENT,
// 		public virtual ElementWithExternalElement
// 	{
// 	public:
// 		CellElementWithExternalDiffusionElement() :
// 		CELL_SOLVER_ELEMENT(),
// 		ElementWithExternalElement()
// 		{
// 			ElementWithExternalElement::set_ninteraction(1);
// 		}

// 		//Since the diffusion is external we override this function and instead get the membrane potential from the external element
// 		inline double get_nodal_membrane_potential_BaseCellMembranePotential(const unsigned &n) const override
// 		{
// 			// oomph_info << "Calling correct get_nodal_membrane_potential_BaseCellMembranePotential\nfor single cell solve" << std::endl;
// 			//Get the integral point at the node
// 			unsigned ipt = this->ipt_at_node(n);
// 			// oomph_info << "Cell get nodal vm from ext element, ipt at node " << ipt << std::endl;

// 			//Pointer to the external diffusion element
// 			EXT_DIFFUSION_ELEMENT* ext_elem_pt = dynamic_cast<EXT_DIFFUSION_ELEMENT*>(this->external_element_pt(0, ipt));

// 			//Local coordinate of the integral point within the external element
// 			Vector<double> s(this->dim(), 0.0);
// 			s = this->external_element_local_coord(0, ipt);

// 			const double val = ext_elem_pt->get_interpolated_membrane_potential_BaseCellMembranePotential(s);
// 			// oomph_info << "cell get nodal vm from ext element: " << val << std::endl;

// 			//Get the interpolated membrane potential in the external element
// 			return val;
// 		}



// 		void fill_in_contribution_to_residuals(Vector<double>& residuals, DenseMatrix<double>& jacobian)
// 		{
// 			CELL_SOLVER_ELEMENT::fill_in_contribution_to_residuals(residuals, jacobian);
// 		}

// 		void fill_in_contribution_to_jacobian(Vector<double>& residuals, DenseMatrix<double>& jacobian) override
// 		{
// 			CELL_SOLVER_ELEMENT::fill_in_contribution_to_jacobian(residuals, jacobian);
// 		}

// 		void identify_field_data_for_interactions(std::set<std::pair<Data*,unsigned> > &paired_field_data) override
// 		{
// 			FiniteElement::identify_field_data_for_interactions(paired_field_data);
// 		}

// 		void describe_local_dofs(std::ostream &out, const std::string &current_string) const override
// 		{
// 			CELL_SOLVER_ELEMENT::describe_local_dofs(out, current_string);
// 		}
// 	};




// 	//Diffusion element with external cell element
// 	template<class DIFFUSION_ELEMENT, class EXT_CELL_SOLVER_ELEMENT>
// 	class DiffusionElementWithExternalCellElement :
// 		public virtual DIFFUSION_ELEMENT,
// 		public virtual ElementWithExternalElement
// 	{
// 	public:
// 		DiffusionElementWithExternalCellElement() :
// 		DIFFUSION_ELEMENT(),
// 		ElementWithExternalElement()
// 		{
// 			ElementWithExternalElement::set_ninteraction(1);
// 		}

// 		//We need to override this function becase the predicted vm is no longer stored/accessed through the nodes of this element but rather stored/accessed by the
// 		// external cell solver element
// 		inline void get_interpolated_predicted_vm_and_dpredicted_vm_dx(double &interpolated_pred_vm, Vector<double> &interpolated_dpred_vm_dx, const Vector<double>& s, const unsigned& ipt, const Shape &psi, const DShape &dpsidx) const override
// 		{
// 			//Zero the data
// 			interpolated_pred_vm = 0;
// 			for(unsigned j=0;j<this->dim();j++)
// 			{
// 				interpolated_dpred_vm_dx[j] = 0.0;
// 			}

// 			//Pointer to the external cell element
// 			EXT_CELL_SOLVER_ELEMENT* ext_elem_pt = dynamic_cast<EXT_CELL_SOLVER_ELEMENT*>(this->external_element_pt(0, ipt));

// 			//Local coordinate of the integral point within the external element
// 			Vector<double> ext_s(this->dim(), 0.0);
// 			ext_s = this->external_element_local_coord(0, ipt);

// 			//Get the interpolated predicted membrane potential in the external element
// 			ext_elem_pt->get_interpolated_predicted_vm_and_dpredicted_vm_dx(interpolated_pred_vm, interpolated_dpred_vm_dx, ext_s);



// 			// //Zero the data
// 			// interpolated_pred_vm = 1;
// 			// for(unsigned j=0;j<this->dim();j++)
// 			// {
// 			// 	interpolated_dpred_vm_dx[j] = 0.0;
// 			// }


// 			// oomph_info << "interpolated predicted vm values" << std::endl;
// 			// oomph_info << interpolated_pred_vm << std::endl;
// 			// oomph_info << interpolated_dpred_vm_dx[0] << std::endl;

// 		}


// 		//Update the node-wise value of membrane potential by the value at that point from the external element
// 		void update_membrane_potential_at_nodes()
// 		{
// 			oomph_info << "Nodal vals after update from single cell model: " << std::endl;
// 			//Loop over the nodes
// 			const unsigned n_node = this->nnode();
// 			for(unsigned l=0; l<n_node; l++)
// 			{
// 				//Get the integral point at the node
// 				unsigned ipt = this->ipt_at_node(l);
// 				// oomph_info << "Diffusion update node vm, ipt at node " << ipt << std::endl;

// 				//Pointer to the external cell element
// 				EXT_CELL_SOLVER_ELEMENT* ext_elem_pt = dynamic_cast<EXT_CELL_SOLVER_ELEMENT*>(this->external_element_pt(0, ipt));

// 				//Local coordinate of the integral point within the external element
// 				Vector<double> s(this->dim(), 0.0);
// 				s = this->external_element_local_coord(0, ipt);

// 				//Get the interpolated predicted membrane potential in the external element
// 				const double val = ext_elem_pt->get_interpolated_predicted_vm_from_cell_model(s);

// 				// oomph_info << "Update vm at node: " << val << std::endl;

// 				//Set the nodal value to that value
// 				this->update_nodal_membrane_potential_BaseCellMembranePotential(l,val);
// 				oomph_info << this->node_pt(l)->value(this->vm_index_BaseCellMembranePotential()) << std::endl;
// 			}
// 		}



// 		void fill_in_contribution_to_residuals(Vector<double>& residuals, DenseMatrix<double>& jacobian)
// 		{
// 			DIFFUSION_ELEMENT::fill_in_contribution_to_residuals(residuals, jacobian);
// 		}

// 		void fill_in_contribution_to_jacobian(Vector<double>& residuals, DenseMatrix<double>& jacobian)
// 		{
// 			DIFFUSION_ELEMENT::fill_in_contribution_to_jacobian(residuals, jacobian);
// 		}

// 		void identify_field_data_for_interactions(std::set<std::pair<Data*,unsigned> > &paired_field_data) override
// 		{
// 			FiniteElement::identify_field_data_for_interactions(paired_field_data);
// 		}

// 		void describe_local_dofs(std::ostream &out, const std::string &current_string) const
// 		{
// 			DIFFUSION_ELEMENT::describe_local_dofs(out, current_string);
// 		}
// 	};

// }


















namespace oomph
{
	//Cell solver with external diffusion element
	// Add a dof to each of the nodes which represents the projected membrane
	// potential from the external diffusion element. Projected value is
	// calculated through minimising (=0?) the difference of the interpolated
	// projected value in this element and the actual value in the external
	// element

	template<class CELL_SOLVER_ELEMENT, class EXT_DIFFUSION_ELEMENT>
	class CellElementWithExternalDiffusionElement :
		public virtual CELL_SOLVER_ELEMENT,
		public virtual ElementWithExternalElement
	{
	public:
		CellElementWithExternalDiffusionElement() :
		CELL_SOLVER_ELEMENT(),
		ElementWithExternalElement()
		{
			ElementWithExternalElement::set_ninteraction(1);
		}

		//We have added a dof to the element
		inline unsigned required_nvalue(const unsigned &n) const
		{
			return (CELL_SOLVER_ELEMENT::required_nvalue(n)+1);
		}

		//The index at which the projected membrane potential is stored in the nodes
		inline virtual unsigned projected_vm_index_CellElementWithExternalDiffusionElement() const
		{
			return 0;
		}

		//Indent the index of the underlying elements dofs by 1
		inline unsigned vm_index_BaseCellMembranePotential() const override
		{
			return (projected_vm_index_CellElementWithExternalDiffusionElement()+1);
		}


		//Since the diffusion is external we override this function and instead get the membrane potential from the external element
		inline double get_nodal_membrane_potential_BaseCellMembranePotential(const unsigned &n) const override
		{
			//grab the value at the correct node
			return (this->node_pt(n)->value(projected_vm_index_CellElementWithExternalDiffusionElement()));
		}

		//Pin the projected vm index in all nodes
		inline void pin_all_projected_degrees_of_freedom() const
		{
			const unsigned n_node = this->nnode();
			for(unsigned l=0; l<n_node; l++)
			{
				this->node_pt(l)->pin(projected_vm_index_CellElementWithExternalDiffusionElement());
			}
		}

		//unpin the projected vm index in all nodes
		inline void unpin_all_projected_degrees_of_freedom() const
		{
			const unsigned n_node = this->nnode();
			for(unsigned l=0; l<n_node; l++)
			{
				this->node_pt(l)->unpin(projected_vm_index_CellElementWithExternalDiffusionElement());
			}
		}
		

		//Resisuals and jacobian of the projected vm dofs
		void fill_in_generic_residual_contribution_CellElementWithExternalDiffusionElement(Vector<double> &residuals,
																																											DenseMatrix<double> &jacobian, 
																																											DenseMatrix<double> &mass_matrix,
																																											unsigned flag)
		{
			//Find out how many nodes there are
			const unsigned n_node = this->nnode();

			//Index of the degree of freedom
			const unsigned projected_vm_nodal_index = projected_vm_index_CellElementWithExternalDiffusionElement();

			//Set up memory for the shape and test functions
			Shape psi(n_node), test(n_node);
			DShape dpsidx(n_node,this->dim()), dtestdx(n_node,this->dim());

			//Set the value of n_intpt
			const unsigned n_intpt = this->integral_pt()->nweight();

			//Set the Vector to hold local coordinates
			Vector<double> s(this->dim());

			//Integers used to store the local equation number and local unknown
			//indices for the residuals and jacobians
			int local_eqn=0, local_unknown=0;

			//Loop over the integration points
			for(unsigned ipt=0;ipt<n_intpt;ipt++)
			{
				//Assign values of s
				for(unsigned i=0;i<this->dim();i++) s[i] = this->integral_pt()->knot(ipt,i);

				//Get the integral weight
				double w = this->integral_pt()->weight(ipt);

				//If the integral weight happens to be zero, skip it
				if(w<1e-9){continue;}

				//Call the derivatives of the shape and test functions
				double J = 
				this->dshape_and_dtest_eulerian_at_knot_BaseCellMembranePotential(ipt,psi,dpsidx,test,dtestdx);

				//Premultiply the weights and the Jacobian
				double W = w*J;

				//Calculate the interpolated projected vm
				double interpolated_projected_vm = 0.0;
				for(unsigned l=0; l<n_node; l++)
				{
					interpolated_projected_vm += (this->raw_nodal_value(l, projected_vm_nodal_index))*psi(l);
				}
				double external_element_vm = (dynamic_cast<EXT_DIFFUSION_ELEMENT*>(this->external_element_pt(0, ipt))
																				->get_interpolated_membrane_potential_BaseCellMembranePotential(this->external_element_local_coord(0, ipt)));

				//Loop over the test functions
				for(unsigned l=0; l<n_node; l++)
				{
					//Set the local equation number
					local_eqn = this->nodal_local_eqn(l,projected_vm_nodal_index);

					/*IF it's not a boundary condition*/
					if(local_eqn >= 0)
					{
						// residuals[local_eqn] -= (interpolated_projected_vm-external_element_vm)*(interpolated_projected_vm-external_element_vm)*test(l)*W;
						residuals[local_eqn] -= (interpolated_projected_vm-external_element_vm)*test(l)*W;

						//Calculate the jacobian
						if(flag)
						{
							//Loop over the test functions again
							for(unsigned l2=0;l2<n_node;l2++)
							{
								//Set the number of the unknown
								local_unknown = this->nodal_local_eqn(l2,projected_vm_nodal_index);

								//If it is not a boundary condition
								if(local_unknown >= 0)
								{
									//Jacobian of projected vm
									// jacobian(local_eqn, local_unknown) -= 2.0*(interpolated_projected_vm-external_element_vm)*test(l)*psi(l2)*W;
									jacobian(local_eqn, local_unknown) -= test(l)*psi(l2)*W;

									//We don't care about altering the jacobian of the external element Vm because we don't want to modify it. 	
									//We just want to set the projected vm to be equal to it
								}
							}
						}
					}
				}
			}
		}


		void fill_in_contribution_to_residuals(Vector<double>& residuals)
		{
			//Residuals of base diffusion element (although it's probably just a zero-diffusion element)
			CELL_SOLVER_ELEMENT::fill_in_contribution_to_residuals(residuals);

			//Residuals of projected vm
			fill_in_generic_residual_contribution_CellElementWithExternalDiffusionElement(
				residuals, GeneralisedElement::Dummy_matrix, GeneralisedElement::Dummy_matrix, 0);
		}

		void fill_in_contribution_to_jacobian(Vector<double>& residuals, DenseMatrix<double>& jacobian) override
		{
			//Jacobian of base diffusion element (although it's probably just a zero-diffusion element)
			CELL_SOLVER_ELEMENT::fill_in_contribution_to_jacobian(residuals, jacobian);

			//Jacobian of projected vm
			fill_in_generic_residual_contribution_CellElementWithExternalDiffusionElement(
				residuals, jacobian, GeneralisedElement::Dummy_matrix, 1);
		}

		void identify_field_data_for_interactions(std::set<std::pair<Data*,unsigned> > &paired_field_data) override
		{
			FiniteElement::identify_field_data_for_interactions(paired_field_data);
		}

		void describe_local_dofs(std::ostream &out, const std::string &current_string) const override
		{
			CELL_SOLVER_ELEMENT::describe_local_dofs(out, current_string);
		}
	};




	//Diffusion element with external cell element
	template<class DIFFUSION_ELEMENT, class EXT_CELL_SOLVER_ELEMENT>
	class DiffusionElementWithExternalCellElement :
		public virtual DIFFUSION_ELEMENT,
		public virtual ElementWithExternalElement
	{
	public:
		DiffusionElementWithExternalCellElement() :
		DIFFUSION_ELEMENT(),
		ElementWithExternalElement()
		{
			ElementWithExternalElement::set_ninteraction(1);
		}

		//We have added a dof to the element
		inline unsigned required_nvalue(const unsigned &n) const
		{
			return (DIFFUSION_ELEMENT::required_nvalue(n)+1);
		}

		//The index at which the projected membrane potential is stored in the nodes
		inline virtual unsigned projected_predicted_vm_index_DiffusionElementWithExternalCellElement() const
		{
			return 0;
		}

		//Indent the index of the underlying elements dofs by 1
		inline unsigned vm_index_BaseCellMembranePotential() const override
		{
			return (projected_predicted_vm_index_DiffusionElementWithExternalCellElement() + 1);
		}

		//The nodal predicted vm is now just the projected predicted vm
		// inline virtual double get_nodal_predicted_vm_BaseCellMembranePotential(const unsigned &l) const override
		// {
		// 	return (this->node_pt(l)->value(projected_predicted_vm_index_DiffusionElementWithExternalCellElement()));
		// }

		double get_nodal_cell_vm_BaseCellMembranePotential(const unsigned &l) const override
		{
			return (this->node_pt(l)->value(projected_predicted_vm_index_DiffusionElementWithExternalCellElement()));
		}



		//Pin the projected vm index in all nodes
		inline void pin_all_projected_degrees_of_freedom() const
		{
			const unsigned n_node = this->nnode();
			for(unsigned l=0; l<n_node; l++)
			{
				this->node_pt(l)->pin(projected_predicted_vm_index_DiffusionElementWithExternalCellElement());
			}
		}

		//unpin the projected vm index in all nodes
		inline void unpin_all_projected_degrees_of_freedom() const
		{
			const unsigned n_node = this->nnode();
			for(unsigned l=0; l<n_node; l++)
			{
				this->node_pt(l)->unpin(projected_predicted_vm_index_DiffusionElementWithExternalCellElement());
			}
		}

		// /// \short Get the function value u in Vector.
		// /// Note: Given the generality of the interface (this function
		// /// is usually called from black-box documentation or interpolation routines),
		// /// the values Vector sets its own size in here.
		// /// Let's define this, it is only required if the base diffusion equations are refineable, but
		// ///  we may as well define it rather than having to deal with refineable and non-refineable
		// ///  elements separately
		// void get_interpolated_values(const unsigned& t, const Vector<double>&s, Vector<double>& values)
		// {
		// 	//Number of dofs
		// 	const unsigned nvalue = this->required_nvalue(0);

		// 	// Set size of Vector:
		// 	values.resize(nvalue);

		// 	//Find out how many nodes there are
		// 	const unsigned n_node = this->nnode();

		// 	//Find the nodal index at which the unknown is stored
		// 	const unsigned vm_nodal_index = this->vm_index_BaseCellMembranePotential();

		// 	// Shape functions
		// 	Shape psi(n_node);

		// 	//Find values of shape function
		// 	this->shape(s,psi);

		// 	//Initialise the value of u
		// 	values[0] = 0.0;

		// 	//Calculate value
		// 	for(unsigned l=0;l<n_node;l++) 
		// 	{
		// 		for(unsigned i=0; i<nvalue; i++)
		// 		{
		// 			values[i] += this->nodal_value(t,l,projected_predicted_vm_index_DiffusionElementWithExternalCellElement()+i)*psi[l]; 
		// 		}
		// 	}
		// }



		// //Update the node-wise value of membrane potential by the value at that point from the external element
		// //THIS WON'T WORK. I DON'T KNOW HOW TO DO THIS WITHOUT A NEWTON SOLVE.
		// // THE ONLY REASON WE WANT TO DO AN UPDATE IS TO ENSURE THAT AT THE TIME OF OUTPUT VM IN THIS ELEMENT
		// // IS CONSISTENT WITH VM IN THE EXTERNAL ELEMENT.
		// // JUST CHANGE OUTPUT TO GRAB THE CELL MEMBRANE POTENTIAL INSTEAD, OR PUT A SWITCH IN SO THE USER CAN DECIDE
		// void update_membrane_potential_at_nodes()
		// {
		// 	// oomph_info << "Nodal vals after update from single cell model: " << std::endl;
		// 	// //Loop over the nodes
		// 	// const unsigned n_node = this->nnode();
		// 	// for(unsigned l=0; l<n_node; l++)
		// 	// {
		// 	// 	//Get the integral point at the node
		// 	// 	unsigned ipt = this->ipt_at_node(l);
		// 	// 	// oomph_info << "Diffusion update node vm, ipt at node " << ipt << std::endl;

		// 	// 	//Pointer to the external cell element
		// 	// 	EXT_CELL_SOLVER_ELEMENT* ext_elem_pt = dynamic_cast<EXT_CELL_SOLVER_ELEMENT*>(this->external_element_pt(0, ipt));

		// 	// 	//Local coordinate of the integral point within the external element
		// 	// 	Vector<double> s(this->this->dim()(), 0.0);
		// 	// 	s = this->external_element_local_coord(0, ipt);

		// 	// 	//Get the interpolated predicted membrane potential in the external element
		// 	// 	const double val = ext_elem_pt->get_interpolated_predicted_vm_from_cell_model(s);

		// 	// 	// oomph_info << "Update vm at node: " << val << std::endl;

		// 	// 	//Set the nodal value to that value
		// 	// 	this->update_nodal_membrane_potential_BaseCellMembranePotential(l,val);
		// 	// 	oomph_info << this->node_pt(l)->value(this->vm_index_BaseCellMembranePotential()) << std::endl;
		// 	// }
		// }


		//Resisuals and jacobian of the projected predicted vm dofs
		virtual void fill_in_generic_residual_contribution_DiffusionElementWithExternalCellElement(Vector<double> &residuals,
																																											DenseMatrix<double> &jacobian, 
																																											DenseMatrix<double> &mass_matrix,
																																											unsigned flag)
		{
			//Find out how many nodes there are
			const unsigned n_node = this->nnode();

			//Index of the degree of freedom
			const unsigned projected_predicted_vm_nodal_index = projected_predicted_vm_index_DiffusionElementWithExternalCellElement();

			//Set up memory for the shape and test functions
			Shape psi(n_node), test(n_node);
			DShape dpsidx(n_node,this->dim()), dtestdx(n_node,this->dim());

			//Set the value of n_intpt
			const unsigned n_intpt = this->integral_pt()->nweight();

			//Set the Vector to hold local coordinates
			Vector<double> s(this->dim());

			//Integers used to store the local equation number and local unknown
			//indices for the residuals and jacobians
			int local_eqn=0, local_unknown=0;

			//Loop over the integration points
			for(unsigned ipt=0;ipt<n_intpt;ipt++)
			{
				//Assign values of s
				for(unsigned i=0;i<this->dim();i++) s[i] = this->integral_pt()->knot(ipt,i);

				//Get the integral weight
				double w = this->integral_pt()->weight(ipt);

				//If the integral weight happens to be zero, skip it
				if(w<1e-9){continue;}

				//Call the derivatives of the shape and test functions
				double J = 
				this->dshape_and_dtest_eulerian_at_knot_BaseCellMembranePotential(ipt,psi,dpsidx,test,dtestdx);

				//Premultiply the weights and the Jacobian
				double W = w*J;

				//Calculate the interpolated projected predicted vm
				double interpolated_projected_predicted_vm = 0.0;
				for(unsigned l=0; l<n_node; l++)
				{
					interpolated_projected_predicted_vm += (this->raw_nodal_value(l, projected_predicted_vm_nodal_index))*psi(l);
				}
				double external_element_predicted_vm = (dynamic_cast<EXT_CELL_SOLVER_ELEMENT*>(this->external_element_pt(0, ipt))
																				->get_interpolated_predicted_vm_from_cell_model(this->external_element_local_coord(0, ipt)));

				//Loop over the test functions
				for(unsigned l=0; l<n_node; l++)
				{
					//Set the local equation number
					local_eqn = this->nodal_local_eqn(l,projected_predicted_vm_nodal_index);

					/*IF it's not a boundary condition*/
					if(local_eqn >= 0)
					{
						// residuals[local_eqn] -= (interpolated_projected_predicted_vm-external_element_predicted_vm)*(interpolated_projected_predicted_vm-external_element_predicted_vm)*test(l)*W;
						residuals[local_eqn] -= (interpolated_projected_predicted_vm-external_element_predicted_vm)*test(l)*W;

						//Calculate the jacobian
						if(flag)
						{
							//Loop over the test functions again
							for(unsigned l2=0;l2<n_node;l2++)
							{
								//Set the number of the unknown
								local_unknown = this->nodal_local_eqn(l2,projected_predicted_vm_nodal_index);

								//If it is not a boundary condition
								if(local_unknown >= 0)
								{
									//Jacobian of projected predicted vm
									// jacobian(local_eqn, local_unknown) -= 2.0*(interpolated_projected_predicted_vm-external_element_predicted_vm)*test(l)*psi(l2)*W;
									jacobian(local_eqn, local_unknown) -= test(l)*psi(l2)*W;
								}
							}
						}
					}
				}
			}
		}


		unsigned nscalar_paraview() const
		{
			return 2;
		}

		void scalar_value_paraview(std::ofstream& file_out,
									const unsigned& i,
									const unsigned& nplot) const
		{
			//Vector of local coordinates
			Vector<double> s(this->dim());

			const unsigned n_node = this->nnode();
			Shape psi(n_node), test(n_node);
			DShape dpsidx(n_node,this->dim()), dtestdx(n_node,this->dim());

			// Loop over plot points
			unsigned num_plot_points=this->nplot_points_paraview(nplot);
			for (unsigned iplot=0;iplot<num_plot_points;iplot++){
				// Get local coordinates of plot point
				this->get_s_plot(iplot,nplot,s);

				if(i==0)
				{
					file_out << this->get_interpolated_membrane_potential_BaseCellMembranePotential(s) << std::endl;
				}
				if(i==1)
				{
					double J = this->dshape_and_dtest_eulerian_at_knot_BaseCellMembranePotential(iplot,psi,dpsidx,test,dtestdx);

					double interpolated_predvm = 0.0;
					Vector<double> interpolated_dpredvmdx(3, 0.0);

					this->get_interpolated_predicted_vm_and_dpredicted_vm_dx(interpolated_predvm, interpolated_dpredvmdx, s, iplot, psi, dpsidx);

					file_out << interpolated_predvm << std::endl;
				}
			}
		}

		void scalar_value_fct_paraview(std::ofstream& file_out,
										const unsigned& i,
										const unsigned& nplot,
										FiniteElement::SteadyExactSolutionFctPt
										exact_soln_pt) const
		{
			scalar_value_paraview(file_out,i,nplot);
		}

		std::string scalar_name_paraview(const unsigned& i) const
		{
			if(i==0) return "Vm";
			if(i==1) return "Projected predicted Vm";
		}


		void fill_in_contribution_to_residuals(Vector<double>& residuals)
		{
			DIFFUSION_ELEMENT::fill_in_contribution_to_residuals(residuals);

			//Residuals of projected predicted vm
			fill_in_generic_residual_contribution_DiffusionElementWithExternalCellElement(
				residuals, GeneralisedElement::Dummy_matrix, GeneralisedElement::Dummy_matrix, 0);
		}

		void fill_in_contribution_to_jacobian(Vector<double>& residuals, DenseMatrix<double>& jacobian)
		{
			DIFFUSION_ELEMENT::fill_in_contribution_to_jacobian(residuals, jacobian);

			//Jacobian of projected predicted vm
			fill_in_generic_residual_contribution_DiffusionElementWithExternalCellElement(
				residuals, jacobian, GeneralisedElement::Dummy_matrix, 1);
		}

		void identify_field_data_for_interactions(std::set<std::pair<Data*,unsigned> > &paired_field_data) override
		{
			FiniteElement::identify_field_data_for_interactions(paired_field_data);
		}

		void describe_local_dofs(std::ostream &out, const std::string &current_string) const
		{
			DIFFUSION_ELEMENT::describe_local_dofs(out, current_string);
		}
	};






	//Refineable diffusion element with external cell element
	template<class DIFFUSION_ELEMENT, class EXT_CELL_SOLVER_ELEMENT>
	class RefineableDiffusionElementWithExternalCellElement :
		public virtual DiffusionElementWithExternalCellElement<DIFFUSION_ELEMENT, EXT_CELL_SOLVER_ELEMENT>,
		public virtual RefineableElement,
		public virtual ElementWithZ2ErrorEstimator
	{
	public:
		RefineableDiffusionElementWithExternalCellElement() :
		DiffusionElementWithExternalCellElement<DIFFUSION_ELEMENT, EXT_CELL_SOLVER_ELEMENT>(),
		RefineableElement(),
		ElementWithZ2ErrorEstimator()
		{

		}

		/// Number of continuously interpolated values: 1
		unsigned ncont_interpolated_values() const {return this->required_nvalue(0);}

		/// \short Number of vertex nodes in the element
		unsigned nvertex_node() const
		{
			return DiffusionElementWithExternalCellElement<DIFFUSION_ELEMENT, EXT_CELL_SOLVER_ELEMENT>::nvertex_node();
		}

		/// \short Pointer to the j-th vertex node in the element
		Node* vertex_node_pt(const unsigned& j) const
		{
			return DiffusionElementWithExternalCellElement<DIFFUSION_ELEMENT, EXT_CELL_SOLVER_ELEMENT>::vertex_node_pt(j);
		}

		/// Rebuild from sons: empty
		void rebuild_from_sons(Mesh* &mesh_pt) {}

		/// \short Order of recovery shape functions for Z2 error estimation:
		/// Same order as shape functions.
		unsigned nrecovery_order()
		{
			return (this->nnode_1d()-1);
		}

		///  \short Perform additional hanging node procedures for variables
		/// that are not interpolated by all nodes. Empty.
		void further_setup_hanging_nodes(){}


		/// Number of 'flux' terms for Z2 error estimation 
		unsigned num_Z2_flux_terms() {return this->dim();}


		//The nodal predicted vm is now just the projected predicted vm
		// inline virtual double get_nodal_predicted_vm_BaseCellMembranePotential(const unsigned &l) const
		// {
		// 	return (this->nodal_value(l,DiffusionElementWithExternalCellElement<DIFFUSION_ELEMENT, EXT_CELL_SOLVER_ELEMENT>::projected_predicted_vm_index_DiffusionElementWithExternalCellElement()));
		// }

		double get_nodal_cell_vm_BaseCellMembranePotential(const unsigned &l) const override
		{
			return (this->nodal_value(l,DiffusionElementWithExternalCellElement<DIFFUSION_ELEMENT, EXT_CELL_SOLVER_ELEMENT>::projected_predicted_vm_index_DiffusionElementWithExternalCellElement()));
		}

		/// \short Get the function value u in Vector.
		/// Note: Given the generality of the interface (this function
		/// is usually called from black-box documentation or interpolation routines),
		/// the values Vector sets its own size in here.
		void get_interpolated_values(const unsigned& t, const Vector<double>&s, Vector<double>& values)
		{
			//Number of dofs
			const unsigned nvalue = this->required_nvalue(0);

			// Set size of Vector:
			values.resize(nvalue);

			//Find out how many nodes there are
			const unsigned n_node = this->nnode();

			//Find the nodal index at which the unknown is stored
			const unsigned vm_nodal_index = this->vm_index_BaseCellMembranePotential();

			// Shape functions
			Shape psi(n_node);

			//Find values of shape function
			this->shape(s,psi);

			//Initialise the values
			for(unsigned i=0; i<nvalue; i++)
			{
				values[i] = 0.0;
			}

			//Calculate value
			for(unsigned l=0;l<n_node;l++) 
			{
				for(unsigned i=0; i<nvalue; i++)
				{
					values[i] += this->nodal_value(t,l,DiffusionElementWithExternalCellElement<DIFFUSION_ELEMENT, EXT_CELL_SOLVER_ELEMENT>::projected_predicted_vm_index_DiffusionElementWithExternalCellElement()+i)*psi[l]; 
				}
			}
		}



		//Resisuals and jacobian of the projected predicted vm dofs
		void fill_in_generic_residual_contribution_DiffusionElementWithExternalCellElement(Vector<double> &residuals,
																																											DenseMatrix<double> &jacobian, 
																																											DenseMatrix<double> &mass_matrix,
																																											unsigned flag) override
		{
			//Find out how many nodes there are
			const unsigned n_node = this->nnode();

			//Index of the degree of freedom
			const unsigned projected_predicted_vm_nodal_index = DiffusionElementWithExternalCellElement<DIFFUSION_ELEMENT, EXT_CELL_SOLVER_ELEMENT>::projected_predicted_vm_index_DiffusionElementWithExternalCellElement();

			//Set up memory for the shape and test functions
			Shape psi(n_node), test(n_node);
			DShape dpsidx(n_node,this->dim()), dtestdx(n_node,this->dim());

			//Set the value of n_intpt
			const unsigned n_intpt = this->integral_pt()->nweight();

			//Set the Vector to hold local coordinates
			Vector<double> s(this->dim());

			//Integers used to store the local equation number and local unknown
			//indices for the residuals and jacobians
			int local_eqn=0, local_unknown=0;

			// Local storage for pointers to hang_info objects
			HangInfo *hang_info_pt=0, *hang_info2_pt=0;

			//Loop over the integration points
			for(unsigned ipt=0;ipt<n_intpt;ipt++)
			{
				//Assign values of s
				for(unsigned i=0;i<this->dim();i++) s[i] = this->integral_pt()->knot(ipt,i);

				//Get the integral weight
				double w = this->integral_pt()->weight(ipt);

				//If the integral weight happens to be zero, skip it
				if(w<1e-9){continue;}

				//Call the derivatives of the shape and test functions
				double J = 
				this->dshape_and_dtest_eulerian_at_knot_BaseCellMembranePotential(ipt,psi,dpsidx,test,dtestdx);

				//Premultiply the weights and the Jacobian
				double W = w*J;

				//Calculate the interpolated projected predicted vm
				double interpolated_projected_predicted_vm = 0.0;
				for(unsigned l=0; l<n_node; l++)
				{
					interpolated_projected_predicted_vm += (this->raw_nodal_value(l, projected_predicted_vm_nodal_index))*psi(l);
				}
				double external_element_predicted_vm = (dynamic_cast<EXT_CELL_SOLVER_ELEMENT*>(this->external_element_pt(0, ipt))
																				->get_interpolated_predicted_vm_from_cell_model(this->external_element_local_coord(0, ipt)));

				//Loop over the test functions
				for(unsigned l=0; l<n_node; l++)
				{
					//Local variables to store the number of master nodes and 
					//the weight associated with the shape function if the node is hanging
					unsigned n_master=1; double hang_weight=1.0;
					//Local bool (is the node hanging)
					bool is_node_hanging = this->node_pt(l)->is_hanging();
					//If the node is hanging, get the number of master nodes
					if(is_node_hanging)
					{
						hang_info_pt = this->node_pt(l)->hanging_pt();
						n_master = hang_info_pt->nmaster();
					}
					//Otherwise there is just one master node, the node itself
					else
					{
						n_master = 1;
					}

					//Loop over the number of master nodes
					for(unsigned m=0;m<n_master;m++)
					{
						//Get the local equation number and hang_weight
						//If the node is hanging
						if(is_node_hanging)
						{
							//Fill in residual and jacobian contribution for u
							//Set the local equation number
							local_eqn = this->local_hang_eqn(hang_info_pt->master_node_pt(m),projected_predicted_vm_nodal_index);
							//Read out the weight from the master node
							hang_weight = hang_info_pt->master_weight(m);
						}
						//If the node is not hanging
						else
						{
							//The local equation number comes from the node itself
							//Set the local equation number
							local_eqn = this->nodal_local_eqn(l,projected_predicted_vm_nodal_index);
							//The hang weight is one
							hang_weight = 1.0;
						}

						/*IF it's not a boundary condition*/
						if(local_eqn >= 0)
						{
							// residuals[local_eqn] -= (interpolated_projected_predicted_vm-external_element_predicted_vm)*(interpolated_projected_predicted_vm-external_element_predicted_vm)*test(l)*W;
							residuals[local_eqn] -= (interpolated_projected_predicted_vm-external_element_predicted_vm)*test(l)*W*hang_weight;

							//Calculate the jacobian
							if(flag)
							{
								//Local variables to store the number of master nodes
								//and the weights associated with each hanging node
								unsigned n_master2=1; double hang_weight2=1.0;

								//Loop over the test functions again
								for(unsigned l2=0;l2<n_node;l2++)
								{
									//Local bool (is the node hanging)
									bool is_node2_hanging = this->node_pt(l2)->is_hanging();
									//If the node is hanging, get the number of master nodes
									if(is_node2_hanging)
									{
										hang_info2_pt = this->node_pt(l2)->hanging_pt();
										n_master2 = hang_info2_pt->nmaster();
									}
									//Otherwise there is one master node, the node itself
									else
									{
										n_master2 = 1;
									}

									//Loop over the master nodes
									for(unsigned m2=0;m2<n_master2;m2++)
									{
										//Get the local unknown and weight
										//If the node is hanging
										if(is_node2_hanging)
										{
											//Read out the local unknown from the master node
											local_unknown = 
											this->local_hang_eqn(hang_info2_pt->master_node_pt(m2),projected_predicted_vm_nodal_index);
											//Read out the hanging weight from the master node
											hang_weight2 = hang_info2_pt->master_weight(m2);
										}
										//If the node is not hanging
										else{
											//The local unknown number comes from the node
											local_unknown = this->nodal_local_eqn(l2,projected_predicted_vm_nodal_index);
											//The hang weight is one
											hang_weight2 = 1.0;
										}

										//If it is not a boundary condition
										if(local_unknown >= 0)
										{
											//Jacobian of projected predicted vm
											// jacobian(local_eqn, local_unknown) -= 2.0*(interpolated_projected_predicted_vm-external_element_predicted_vm)*test(l)*psi(l2)*W;
											jacobian(local_eqn, local_unknown) -= test(l)*psi(l2)*W*hang_weight*hang_weight2;
										}
									}
								}
							}
						}
					}
				}
			}
		}


		void fill_in_contribution_to_residuals(Vector<double>& residuals)
		{
			DIFFUSION_ELEMENT::fill_in_contribution_to_residuals(residuals);

			//Residuals of projected predicted vm
			fill_in_generic_residual_contribution_DiffusionElementWithExternalCellElement(
				residuals, GeneralisedElement::Dummy_matrix, GeneralisedElement::Dummy_matrix, 0);
		}

		void fill_in_contribution_to_jacobian(Vector<double>& residuals, DenseMatrix<double>& jacobian)
		{
			DIFFUSION_ELEMENT::fill_in_contribution_to_jacobian(residuals, jacobian);

			//Jacobian of projected predicted vm
			fill_in_generic_residual_contribution_DiffusionElementWithExternalCellElement(
				residuals, jacobian, GeneralisedElement::Dummy_matrix, 1);
		}

		void identify_field_data_for_interactions(std::set<std::pair<Data*,unsigned> > &paired_field_data) override
		{
			FiniteElement::identify_field_data_for_interactions(paired_field_data);
		}

		void describe_local_dofs(std::ostream &out, const std::string &current_string) const
		{
			DIFFUSION_ELEMENT::describe_local_dofs(out, current_string);
		}
	};



	namespace separated_cell_and_diffusion_domain_helper_functions
	{
	

	//Set membrane potential to projected predicted membrane potential.
	//Used to assign initial conditions
	template<class ELEMENT_TYPE>
	void set_membrane_potential_to_projected_predicted_value(Vector<GeneralisedElement*>& element_pt)
	{
		//Loop over the elements
		for(GeneralisedElement* e_pt : element_pt)
		{
			//Cast to the element type provided
			ELEMENT_TYPE* elem_pt = dynamic_cast<ELEMENT_TYPE*>(e_pt);

			//Loop over the nodes in the element
			const unsigned n_node = elem_pt->nnode();
			for(unsigned l=0; l<n_node; l++)
			{
				//Set the value of the vm dof in the node to the projected predicted dof of the node
				// elem_pt->node_pt(l)->set_value(elem_pt->vm_index_BaseCellMembranePotential(), elem_pt->get_nodal_predicted_vm_BaseCellMembranePotential(l));
				elem_pt->node_pt(l)->set_value(elem_pt->vm_index_BaseCellMembranePotential(), elem_pt->get_nodal_cell_vm_BaseCellMembranePotential(l));
			}
		}
	}

	template<class ELEMENT_TYPE>
	void pin_all_projected_degrees_of_freedom(Vector<GeneralisedElement*>& element_pt)
	{
		//Loop over the elements
		for(GeneralisedElement* e_pt : element_pt)
		{
			//Set the value of the vm dof in the node to the projected predicted dof of the node
			dynamic_cast<ELEMENT_TYPE*>(e_pt)->pin_all_projected_degrees_of_freedom();
		}
	}

	template<class ELEMENT_TYPE>
	void unpin_all_projected_degrees_of_freedom(Vector<GeneralisedElement*>& element_pt)
	{
		//Loop over the elements
		for(GeneralisedElement* e_pt : element_pt)
		{
			//Set the value of the vm dof in the node to the projected predicted dof of the node
			dynamic_cast<ELEMENT_TYPE*>(e_pt)->unpin_all_projected_degrees_of_freedom();
		}
	}



	}




} //end namespace

#endif