//LIC// ====================================================================
//LIC// 
//LIC// ====================================================================



#ifndef OOMPH_CELL_MODEL_BASE_FULLY_SEGREGATED_HEADER
#define OOMPH_CELL_MODEL_BASE_FULLY_SEGREGATED_HEADER

// Config header generated by autoconfig
#ifdef HAVE_CONFIG_H
  #include <oomph-lib-config.h>
#endif

//OOMPH-LIB includes
#include "../generic/nodes.h"
#include "../generic/oomph_utilities.h"
#include "../generic/matrices.h"
#include "../generic/Qelements.h"
#include "../generic/Telements.h"

// #include "../toms_utilities/toms_explicit_timestepping_methods.h"

#include <boost/numeric/odeint.hpp>


#include "../cell_membrane_potential/cell_membrane_potential_elements.h"


namespace oomph{



	class ConductingCellFunctionsBase
	{
	public:

		ConductingCellFunctionsBase() : StimFctPt(0)
		{}

		~ConductingCellFunctionsBase(){}
		
		//Define the function template used for forcing terms and stuff
		typedef double (*CellInterfaceScalarFctPt)
		(const unsigned& ipt, const Vector<double>& s, const Vector<double>& x, const double& t);

		/////////////////////////////////////////////////////////////////////////////////
		//Get other variables
		//	these could be, for example:
		//	 strain in the tissue,
		//	 oxygen concentration,
		//	 variables which could be assigned node-wise, or could be the result of some computation and exist in a continuum
		//We leave this virtual since it's very implementation dependent, it could simply use function pointers to get the
		//	data we need as is seen in other source functions, or it could call on external elements to interpolate data
		//	from their own computation, or it could be any other exotic structure you like.
		/////////////////////////////////////////////////////////////////////////////////
		inline virtual void get_other_variables(const unsigned& ipt,
									            const Vector<double> &s,
									            const Vector<double>& x,
															const unsigned &l,
															const double &t,
															Vector<double> &Variables) const
		{

		}


		CellInterfaceScalarFctPt StimFctPt;


		inline double get_stimulus(const unsigned& ipt,
						            const Vector<double> &s,
						            const Vector<double>& x,
												const double &t) const
		{
			if(StimFctPt==nullptr){
				// oomph_info << "not stimulating" << std::endl;
				return 0.0;
			}
			else{
				// oomph_info << "Stimulating" << std::endl;
				return (*StimFctPt)(ipt,s,x,t);
			}
		}


		CellInterfaceScalarFctPt& Stimulus_Function_Pt()
		{
			return StimFctPt;
		}

		CellInterfaceScalarFctPt Stimulus_Function_Pt() const
		{
			return StimFctPt;
		}


	};

	typedef boost::numeric::ublas::vector< double > Boost_State_Type;
	typedef boost::numeric::ublas::matrix< double > boost_matrix_type;

	// typedef boost::numeric::odeint::runge_kutta_cash_karp54< Boost_State_Type > controlled_error_stepper_type;
	typedef boost::numeric::odeint::runge_kutta_fehlberg78< Boost_State_Type > controlled_error_stepper_type;
	typedef boost::numeric::odeint::rosenbrock4< Boost_State_Type > implicit_controlled_error_stepper_type;



	class CellModelBaseFullySegregated
	{
	public:
		CellModelBaseFullySegregated() : active_strain_index(-1), Integral_Iion(0.0), Base_Cell_Sources_Pt(0), Base_Node_Pt(0),
																		Non_this_pointer(this)
		{
			//Resize the variable names vectors to zero
			Names_Of_Cell_Variables.resize(0);
			Names_Of_Other_Parameters.resize(0);
			Names_Of_Other_Variables.resize(0);
			Names_Of_Output_Data.resize(0);
		}
		virtual ~CellModelBaseFullySegregated(){}
		

		/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		//BEGIN functions which need to be overridden by a user

		//Get the v-th variables initial condition for cell_type,
		//	these MUST be written in the same order that you write the Names_Of_Cell_Variables vector entries.
		virtual double return_initial_state_variable(const unsigned &v, const unsigned &cell_type)
		{
			//Broken by default
			throw OomphLibError("return_initial_state_variable: This function has not been implemented yet",
				OOMPH_CURRENT_FUNCTION,
				OOMPH_EXCEPTION_LOCATION);
		}


		//Get the initial membrane potential for the cell_type-th cell type
		virtual double return_initial_membrane_potential(const unsigned &cell_type)
		{
			//Broken by default
			throw OomphLibError("return_initial_membrane_potential: This function has not been implemented yet",
				OOMPH_CURRENT_FUNCTION,
				OOMPH_EXCEPTION_LOCATION);
		}


		//Calculate the derivatives of the cell variables, also calculate the trans membrane current
		//	We provide the membrane current, the contemporary cell variable valyues, the time (just in case)
		//	the timestep (for rush larson methods), the cell type,
		//	other parameters (which represets time independent variables, e.g. a drug concentration or ion channel blockade),
		//	other variables (generally time dependent variables, e.g. strain in the tissue)
		//
		//	The function is to calculate the time derivatives of the cell variables, and populate the Variable_Derivatives,
		//	 the user must use the same keyword names as the variable, e.g. CellVariables[sxs], Variable_Derivatives[sxs] = (...)
		//	The user also provides the Iion which is the total transmembrane ionic current, which must be in pA/pF, i.e. current per capacitance
		//	 this way the membrane capacitance doesn't need to be passed to any other methods and the computations are neater.
		virtual void Calculate_Derivatives(const double &Vm,
											const Vector<double> &CellVariables,
											const double &t,
											const unsigned &cell_type,
											const double &Istim,
											const Vector<double> &Other_Parameters,
											const Vector<double> &Other_Variables,
											Vector<double> &Variable_Derivatives,
											double &Iion) 
		{
			//Broken by default
			throw OomphLibError("Calculate_Derivatives: This function has not been implemented yet",
				OOMPH_CURRENT_FUNCTION,
				OOMPH_EXCEPTION_LOCATION);
		}


		//Generate an unordered map of data required by things outside of the cell model, this could be
		//	active strain, or perhaps ion channel currents, or ionic species concentrations, we want to keep track of
		virtual void get_optional_output(const double &Vm,
									const Vector<double> &CellVariables,
									const double &t,
									const unsigned &cell_type,
									const double &Istim,
									const Vector<double> &Other_Parameters,
									const Vector<double> &Other_Variables,
									Vector<double> &Out)
		{
			//Broken by default
			throw OomphLibError("get_optional_output: This function has not been implemented yet",
				OOMPH_CURRENT_FUNCTION,
				OOMPH_EXCEPTION_LOCATION);
		}

		//END functions which need to be overridden by a user
		/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


		double get_predicted_vm() const
		{
			return MyVm;
		}

		double set_predicted_vm(const double& new_vm)
		{
			return MyVm = new_vm;
		}



		double get_Integral_Iion() const
		{
			return Integral_Iion;
		}



		double get_cell_variable(const unsigned& i)
		{
			return Cell_Variables[i];
		}

		double get_active_strain() const
		{
			#ifdef PARANOID
			//If the user has failed to specify at which index the active strain is stored at then we throw an error 
			if(active_strain_index<0){
				throw OomphLibError("You appear to be attempting to access active strain stored in a cell element\nbut you haven't set the index at which it is stored. Please make sure that you override\nget_index_of_active_strain() to return the correct index you have stored it at.",
			                       	OOMPH_CURRENT_FUNCTION,
			                       	OOMPH_EXCEPTION_LOCATION);
			}
			#endif
			return Output_Data[active_strain_index];
		}

		void set_cell_type(const unsigned &cell_type){
			Cell_Type = cell_type;
		}

		void set_other_data(const unsigned &var, const double &value){
			Other_Parameters[var] = value;
		}


		double get_additional_data_val(const unsigned &n)
		{
			#ifdef PARANOID
			if(n>Num_Output_Data-1)
			{
				throw OomphLibError("Index of requested output data too large.",
			                       	OOMPH_CURRENT_FUNCTION,
			                       	OOMPH_EXCEPTION_LOCATION);
			}
			#endif
			return Output_Data[n];
		}


		const void output_membrane_potential(std::ostream &outfile){
			outfile << MyVm << " ";
		}

		const void output_global_coord(std::ostream &outfile){
			const unsigned dim=X.size();
			for(unsigned i=0; i<dim; i++){
				outfile << X[i] << " ";
			}
		}

		const void output_cell_variables(std::ostream &outfile){
			for(unsigned i=0; i<Num_Cell_Vars; i++){
				outfile << Cell_Variables[i] << " ";
			}
		}


		const void output_additional_data(std::ostream &outfile){
			for(unsigned i=0; i<Num_Output_Data; i++){
				outfile << Output_Data[i] << " ";
			}
		}

		const void output_cell_type(std::ostream &outfile){
			outfile << Cell_Type << " ";
		}



		const void output_names_of_cell_variables(std::ostream &outfile){
			for(unsigned i=0; i<Num_Cell_Vars; i++){
				outfile << Names_Of_Cell_Variables[i] << " ";
			}
		}

		const void output_names_of_additional_data(std::ostream &outfile){
			for(unsigned i=0; i<Num_Output_Data; i++){
				outfile << Names_Of_Output_Data[i] << " ";
			}
		}




		//The names given to the cell variables, we use this because it's more user friendly,
		// it means a user does not need to also provide the number of cell variables, and they
		// can just call the variables by name rather than worrying about index
		const std::vector<std::string>& names_of_cell_variables() const
		{
			return Names_Of_Cell_Variables;
		}

		//The names of the other parameters passed to the function, we provide this for error checking,
		//	if the library is built with PARANOID then we can automatically check to ensure that the
		//	user is correctly creating the other parameters data.
		const std::vector<std::string>& names_of_other_parameters() const
		{
			return Names_Of_Other_Parameters;
		}

		//Same as above but for other variables which are in general time dependent.
		const std::vector<std::string>& names_of_other_variables() const
		{
			return Names_Of_Other_Variables;
		}

		//Same as above but for the data the cell model returns for other things to use
		const std::vector<std::string>& names_of_output_data() const 
		{
			return Names_Of_Output_Data;
		}


		const unsigned get_Num_Cell_Vars() const{
			return Num_Cell_Vars;
		}
		const unsigned get_Num_Other_Params() const{
			return 	Num_Other_Params;
		}
		const unsigned get_Num_Other_Vars() const{
			return 	Num_Other_Vars;
		}
		const unsigned get_Num_Output_Data() const{
			return 	Num_Output_Data;
		}


		//We provide an element and the coordinates within it at which this cell lives.
		//We use this information for suitably interpolating external data for computing the solution
		// to this cell model.
		//This poses a potential problem since solutions to finite element problems are not guaranteed to be
		// continuous and hence the solution within adjacent elements sharing the same node are also not
		// guaranteed to be the same. We get around this problem by assuming we are solving for a continuous
		// variable if it is to be sent to a cell model. This makes sense for things like membrane potential
		// or a concentration.
		void set_my_element_and_coordinate(ConductingCellFunctionsBase* ConductingCellFunctionsBase_Pt,
											Node* Node_pt,
											CellModelBaseFullySegregated* cell_pt,
											const unsigned& Index_of_Vm,
											const unsigned& ipt,
											const Vector<double>& s,
											const Vector<double>& x,
											const unsigned& l)
		{
			Base_Cell_Sources_Pt = ConductingCellFunctionsBase_Pt;

			Base_Node_Pt = Node_pt;

			Non_this_pointer = cell_pt;

			Base_Node_Index_of_Vm = Index_of_Vm;

			Ipt = ipt;
			S = s;
			X = x;
			L = l;
		}

		
		double get_stimulus_current(const double &t)
		{
			if(Base_Cell_Sources_Pt!=nullptr)
			{
				return (Base_Cell_Sources_Pt->get_stimulus)(Ipt, S, X, t);
			}
			else
			{
				return 0.0;
			}
		}

		void get_other_variables(const double& t, Vector<double> boost_Other_Variables)
		{
			if(Base_Cell_Sources_Pt!=nullptr)
			{
				(Base_Cell_Sources_Pt->get_other_variables)(Ipt, S, X, L, t, boost_Other_Variables);
			}
			else
			{
				//do nothing
			}
		}

		double get_base_node_membrane_potential()
		{
			if(Base_Cell_Sources_Pt!=nullptr)
			{
				return dynamic_cast<DimensionlessMembranePotentialEquationsBase*>(Base_Cell_Sources_Pt)->get_nodal_membrane_potential_BaseCellMembranePotential(L);
			}
			else
			{
				//throw an error since we explicitly asked for the membrane potential of the base node but none has been assigned
				throw OomphLibError("A cell is requesting its base node membrane potential but no such node exists.",
														OOMPH_CURRENT_FUNCTION,
														OOMPH_EXCEPTION_LOCATION);
			}
		}


		//The function used by boost when solving the cell model
		void operator() ( const Boost_State_Type &x , Boost_State_Type &dxdt , const double t )
		{
			//Things used throughout the computation
			const double boost_Vm = x[Num_Cell_Vars];
			double boost_Iion = 0.0;
			Vector<double> boost_Cell_Variables(Num_Cell_Vars, 0.0);
			Vector<double> boost_Variable_Derivatives(Num_Cell_Vars, 0.0);
			for(unsigned i=0; i<Num_Cell_Vars; i++){
				boost_Cell_Variables[i] = x[i];
				boost_Variable_Derivatives[i] = 0.0;
			}
			Vector<double> boost_Other_Variables(Num_Cell_Vars, 0.0);

			const double stimulus_current = get_stimulus_current(t);

			get_other_variables(t, boost_Other_Variables);

			Non_this_pointer->Calculate_Derivatives(boost_Vm,
																							boost_Cell_Variables,
																							t,
																							Cell_Type,
																							stimulus_current,
																							Other_Parameters,
																							boost_Other_Variables,
																							boost_Variable_Derivatives,
																							boost_Iion);

			//Fill in the derivatives to be sent back to the boost solver
			dxdt[Num_Cell_Vars] = boost_Iion;
			for(unsigned i=0; i<Num_Cell_Vars; i++){
				dxdt[i] = boost_Variable_Derivatives[i];
			}
		}


		// void first( const Boost_State_Type &x , Boost_State_Type &dxdt , const double t )
		// {
		// 	//Things used throughout the computation
		// 	const double boost_Vm = x[Num_Cell_Vars];
		// 	double boost_Iion = 0.0;
		// 	Vector<double> boost_Cell_Variables(Num_Cell_Vars, 0.0);
		// 	Vector<double> boost_Variable_Derivatives(Num_Cell_Vars, 0.0);
		// 	for(unsigned i=0; i<Num_Cell_Vars; i++){
		// 		boost_Cell_Variables[i] = x[i];
		// 		boost_Variable_Derivatives[i] = 0.0;
		// 	}
		// 	Vector<double> boost_Other_Variables(Num_Cell_Vars, 0.0);

		// 	const double stimulus_current = (Base_Cell_Sources_Pt->get_stimulus)(Ipt, S, X, t);

		// 	(Base_Cell_Sources_Pt->get_other_variables)(Ipt, S, X, L, t, boost_Other_Variables);

		// 	Non_this_pointer->Calculate_Derivatives(boost_Vm,
		// 												boost_Cell_Variables,
		// 												t,
		// 												Cell_Type,
		// 												stimulus_current,
		// 												Other_Parameters,
		// 												boost_Other_Variables,
		// 												boost_Variable_Derivatives,
		// 												boost_Iion);

		// 	//Fill in the derivatives to be sent back to the boost solver
		// 	dxdt[Num_Cell_Vars] = boost_Iion;
		// 	for(unsigned i=0; i<Num_Cell_Vars; i++){
		// 		dxdt[i] = boost_Variable_Derivatives[i];
		// 	}
		// }

		// void second( const Boost_State_Type &x , boost_matrix_type &jacobi , const double t )
		// {
		// 	//The base vector for finite differencing
		// 	Boost_State_Type dxdt0(x.size());

		// 	//Things used throughout the computation
		// 	double boost_Vm = x[Num_Cell_Vars];
		// 	double boost_Iion = 0.0;
		// 	Vector<double> boost_Cell_Variables(Num_Cell_Vars, 0.0);
		// 	Vector<double> boost_Variable_Derivatives(Num_Cell_Vars, 0.0);
		// 	for(unsigned i=0; i<Num_Cell_Vars; i++){
		// 		boost_Cell_Variables[i] = x[i];
		// 		boost_Variable_Derivatives[i] = 0.0;
		// 	}
		// 	Vector<double> boost_Other_Variables(Num_Cell_Vars, 0.0);

		// 	const double stimulus_current = (Base_Cell_Sources_Pt->get_stimulus)(Ipt, S, X, t);

		// 	(Base_Cell_Sources_Pt->get_other_variables)(Ipt, S, X, L, t, boost_Other_Variables);

		// 	Non_this_pointer->Calculate_Derivatives(boost_Vm,
		// 												boost_Cell_Variables,
		// 												t,
		// 												Cell_Type,
		// 												stimulus_current,
		// 												Other_Parameters,
		// 												boost_Other_Variables,
		// 												boost_Variable_Derivatives,
		// 												boost_Iion);


		// 	//Fill in the base derivatives
		// 	dxdt0[Num_Cell_Vars] = boost_Iion;
		// 	for(unsigned i=0; i<Num_Cell_Vars; i++){
		// 		dxdt0[i] = boost_Variable_Derivatives[i];
		// 	}

		// 	//perform the finite differencing:


		// 	//Finite difference membrane potential

		// 	//Things used throughout the computation
		// 	boost_Vm += 1e-9;

		// 	Non_this_pointer->Calculate_Derivatives(boost_Vm,
		// 												boost_Cell_Variables,
		// 												t,
		// 												Cell_Type,
		// 												stimulus_current,
		// 												Other_Parameters,
		// 												boost_Other_Variables,
		// 												boost_Variable_Derivatives,
		// 												boost_Iion);

		// 	//Fill in the base derivatives
		// 	jacobi.insert_element(Num_Cell_Vars, Num_Cell_Vars, (boost_Iion - dxdt0[Num_Cell_Vars])/(1e-9));
		// 	for(unsigned i=0; i<Num_Cell_Vars; i++){
		// 		jacobi.insert_element(i, Num_Cell_Vars, (dxdt0[i] - boost_Variable_Derivatives[i])/(1e-9));
		// 	}

		// 	boost_Vm -= 1e-9;


		// 	//Finite difference the cell variables variables

		// 	for(unsigned v=0; v<Num_Cell_Vars; v++){
		// 		//Things used throughout the computation
		// 		boost_Cell_Variables[v] += 1e-9;

		// 		Non_this_pointer->Calculate_Derivatives(boost_Vm,
		// 													boost_Cell_Variables,
		// 													t,
		// 													Cell_Type,
		// 													stimulus_current,
		// 													Other_Parameters,
		// 													boost_Other_Variables,
		// 													boost_Variable_Derivatives,
		// 													boost_Iion);

		// 		//Fill in the base derivatives
		// 		jacobi.insert_element(Num_Cell_Vars, v, (boost_Iion - dxdt0[Num_Cell_Vars])/(1e-9));
		// 		for(unsigned i=0; i<Num_Cell_Vars; i++){
		// 			jacobi.insert_element(i, v, (dxdt0[i] - boost_Variable_Derivatives[i])/(1e-9));
		// 		}

		// 		boost_Cell_Variables[v] -= 1e-9;
		// 	}

		// }


		//Take a timestep using boost solver. pass the initial time and total duration of the solve
		// the boolean use_node_vm_as_initial_value indicates whether or not the cell should use it's
		// internally stored value of vm or the value stored in the underlying oomph-lib node
		void TakeTimestep(const double &t, const double& dt, const bool &use_node_vm_as_initial_value = false)
		{
			//Fill in the current Vm and variable values
			Boost_State_Type x(Num_Cell_Vars+1, 0.0);
			//Fill in membrane potential
			// if(use_node_vm_as_initial_value){x[Num_Cell_Vars] = Base_Node_Pt->value(Base_Node_Index_of_Vm);}
			if(use_node_vm_as_initial_value)
			{
				x[Num_Cell_Vars] = get_base_node_membrane_potential();
			}
			else
			{
				x[Num_Cell_Vars] = MyVm;
			}

			//Fill in cell variables
			for(unsigned i=0; i<Num_Cell_Vars; i++){
				x[i] = Cell_Variables[i];
			}

			//Call the adaptive boost solver over the specified range, t to t+dt
			// integrate_adaptive( boost::numeric::odeint::make_controlled<controlled_error_stepper_type>(1.0e-10, 1.0e-6),
			// 						(*this), x, t, t+dt, dt);

			//Integrate over dt. This is specialised for the crank nicolson strang splitting method. If we are not getting initial vm from the underlying node then we
			// start the integration at the underlying node current time. If we are getting the initial vm from the underlying node then we expect
			// that the underlying node has taken a timestep of 2*dt so we need to push back the time value by dt and solve over dt.
			// integrate_adaptive( boost::numeric::odeint::make_controlled<controlled_error_stepper_type>(1.0e-10, 1.0e-6),
			// 						(*this), x, t - dt, t, dt);



			integrate_adaptive( boost::numeric::odeint::make_controlled<controlled_error_stepper_type>(1.0e-10, 1.0e-6),
									(*this), x, t - dt, t, dt);

			
			
				// integrate_adaptive( boost::numeric::odeint::make_controlled<controlled_error_stepper_type>(dt*dt, dt*dt),
				// 					(*this), x, t, t+dt, dt);

			// boost::numeric::odeint::euler<Boost_State_Type> Euler;
			// Euler.do_step((*this), x, t, dt);

			// boost::numeric::odeint::runge_kutta4<Boost_State_Type> RK4;
			// RK4.do_step((*this), x, t, dt);

			// boost::numeric::odeint::implicit_euler<Boost_State_Type> ImplicitEuler;
			// ImplicitEuler.do_step( (*this), x, t, dt);


			
			//Calculate the integral of membrane current by the fundamental theorem of calculus
			// Integral_Iion = (MyVm - x[Num_Cell_Vars]);
			Integral_Iion = (x[Num_Cell_Vars] - MyVm);

			// oomph_info << Integral_Iion << std::endl;

			//Unpack the data from the boost solve
			MyVm = x[Num_Cell_Vars];
			for(unsigned i=0; i<Num_Cell_Vars; i++){
				Cell_Variables[i] = x[i];
			}
		}




		void calculate_optional_output(const double &t)
		{

			const double stimulus_current = get_stimulus_current(t);

			Vector<double> Other_Variables(Num_Cell_Vars, 0.0);

			get_other_variables(t, Other_Variables);

			get_optional_output(MyVm,
												Cell_Variables,
												t,
												Cell_Type,
												stimulus_current,
												Other_Parameters,
												Other_Variables,
												Output_Data);
		}



		//Update the membrane potential of the underlying node to be consistent with that of the cell
		void update_underlying_node_membrane_potential()
		{
			#ifdef PARANOID
			if(dynamic_cast<DimensionlessMembranePotentialEquationsBase*>(Base_Cell_Sources_Pt)==nullptr){
				throw OomphLibError("No node assigned to this cell.",
			                       	OOMPH_CURRENT_FUNCTION,
			                       	OOMPH_EXCEPTION_LOCATION);
			}
			#endif
			dynamic_cast<DimensionlessMembranePotentialEquationsBase*>(Base_Cell_Sources_Pt)->update_nodal_membrane_potential_BaseCellMembranePotential(L, MyVm);
		}


		//Assign initial conditions or update the current values of variables
		//When updating the vm of the underlying node this is not done directly
		// but calls a function of the underlying element - this is because
		// the value stored in the underlying node may not actually
		// represent vm.

		void assign_initial_conditions(const bool &also_set_nodal_value = false){
			//Assign initial conditions from the cell model

			Integral_Iion = 0.0;

			
			//Cell variables
			for(unsigned i=0; i<Num_Cell_Vars; i++){
				Cell_Variables[i] = this->return_initial_state_variable(i, Cell_Type);
			}
			//Membrane potential
			MyVm = this->return_initial_membrane_potential(Cell_Type);

			if(also_set_nodal_value)
			{
				update_underlying_node_membrane_potential();
			}
		}

		//Used to update values post mpi solve to be consistent with values on other processors
		void assign_values_post_mpi_solve(const Vector<double>& vals, const double& vm, const bool &also_set_nodal_value = false){	

			//Update the integral of iion
			// Integral_Iion = (MyVm - vm);
			Integral_Iion = (vm - MyVm);

			//Membrane potential
			MyVm = vm;

			//Cell variables
			for(unsigned i=0; i<Num_Cell_Vars; i++){
				Cell_Variables[i] = vals[i];
			}

			if(also_set_nodal_value)
			{
				update_underlying_node_membrane_potential();
			}
		}


		//Assign initial conditions
		void assign_initial_conditions(const Vector<double>& vals, const double& vm, const bool &also_set_nodal_value = false){		

			//Update the integral of iion
			Integral_Iion = 0.0;

			//Membrane potential
			MyVm = vm;

			//Cell variables
			for(unsigned i=0; i<Num_Cell_Vars; i++){
				Cell_Variables[i] = vals[i];
			}

			if(also_set_nodal_value)
			{
				update_underlying_node_membrane_potential();
			}
		}




		void assign_initial_membrane_potential(const double& Vm, const bool &also_set_nodal_value = false){
			MyVm = Vm;

			if(also_set_nodal_value)
			{
				update_underlying_node_membrane_potential();
			}
		}

		void assign_initial_conditions(Vector<double>::iterator itStart, const bool &also_set_nodal_value = false)
		{
			Vector<double>::iterator it = itStart;
			
			MyVm = *(++it);
			// oomph_info << MyVm << std::endl;
			for(unsigned i=0; i<Num_Cell_Vars; i++){
				Cell_Variables[i] = *(++it);
			}

			if(also_set_nodal_value)
			{
				update_underlying_node_membrane_potential();
			}
		}

	protected:
		//The vectors of variable names, these need to be assigned at construction of the cell model.
		//	these are used for the headers of output files
		std::vector<std::string> Names_Of_Cell_Variables;
		std::vector<std::string> Names_Of_Other_Parameters;
		std::vector<std::string> Names_Of_Other_Variables;
		std::vector<std::string> Names_Of_Output_Data;

		//The number of variables, these avoid unnecessary overhead by constantly calling Names_Of_Cell_Variables.size() etc
		//	They are set automatically by the following function which must be called by the user at the end of their cell
		//	class
		unsigned Num_Cell_Vars;
		unsigned Num_Other_Params;
		unsigned Num_Other_Vars;
		unsigned Num_Output_Data;

		void FinalizeConstruction()
		{
			Num_Cell_Vars = 	Names_Of_Cell_Variables.size();
			Num_Other_Params = 	Names_Of_Other_Parameters.size();
			Num_Other_Vars = 	Names_Of_Other_Variables.size();
			Num_Output_Data = 	Names_Of_Output_Data.size();

			// std::cout << Num_Cell_Vars << std::endl;
			// std::cout << Num_Other_Params << std::endl;
			// std::cout << Num_Other_Vars << std::endl;
			// std::cout << Num_Output_Data << std::endl;

			//Allocate storage for the cell variables
			Cell_Variables.resize(Num_Cell_Vars, 0.0);
			//Allocate storage for the other parameters
			Other_Parameters.resize(Num_Other_Params, 0.0);

			Output_Data.resize(Num_Output_Data, 0.0);
		}

		int active_strain_index;

	private:

		CellModelBaseFullySegregated* Non_this_pointer;

		//The value this cell believes the membrane potential to be, since we are using segregated solvers this is a
		//	prediction given by solving the cell equations full decoupled from the diffusion
		double MyVm;

		double Integral_Iion;

		//The variables we solve for when solving the cell model
		Vector<double> Cell_Variables;



		//Other parameters that define the general behaviour of this cell, e.g. apico-basal ratio
		Vector<double> Other_Parameters;

		//Other variables generated by the cell model which might be needed by external elements
		Vector<double> Output_Data;

		//Cell type
		unsigned Cell_Type;

		//We also store an element we live in and coordinates
		
		//For the other variables and the stimulus source
		ConductingCellFunctionsBase* Base_Cell_Sources_Pt;

		//Base node this cell is attached to
		Node* Base_Node_Pt;

		//Index in the base node at which vm is stored.
		unsigned Base_Node_Index_of_Vm;

		//Location data for filling arguments of source functions
		unsigned Ipt;
		Vector<double> S;
		Vector<double> X;
		unsigned L;

	};


}

#endif