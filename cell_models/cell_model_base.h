//LIC// ====================================================================
//LIC// 
//LIC// ====================================================================



#ifndef OOMPH_CELL_MODEL_BASE_FULLY_SEGREGATED_HEADER
#define OOMPH_CELL_MODEL_BASE_FULLY_SEGREGATED_HEADER

// Config header generated by autoconfig
#ifdef HAVE_CONFIG_H
  #include <oomph-lib-config.h>
#endif

//OOMPH-LIB includes
#include "../generic/nodes.h"
#include "../generic/oomph_utilities.h"
#include "../generic/matrices.h"
#include "../generic/Qelements.h"
#include "../generic/Telements.h"

// #include "../toms_utilities/toms_explicit_timestepping_methods.h"

#include <boost/numeric/odeint.hpp>

#include <boost/numeric/odeint/stepper/bulirsch_stoer.hpp>
#include <boost/numeric/odeint/stepper/bulirsch_stoer_dense_out.hpp>


#include "../cell_membrane_potential/cell_membrane_potential_elements.h"


namespace oomph
{


namespace cellhandlenan
{
	//Handle nan in branchless manner

	//This is the arbitrary cutoff for the maximum value a derivative can be before it is assumed to be NaN
	const double ARBITRARY_CUTOFF = 1e5;

	//Returns the number if it is finite, else returns some random number up to the size of 2*arbitrary cutoff
	inline void cellhandlePossibleNan(double &x)
	{
		x = std::min(ARBITRARY_CUTOFF+((double)std::rand()/((double)RAND_MAX))*ARBITRARY_CUTOFF, x); //arguments must be this way round because std::min(x, Nan) = x but std::min(NaN, x) = NaN
	}
}

// namespace BoostSolve
// {
// 	//Should each cell check for non-finite during solve
// 	bool Check_For_Non_Finite_Values_After_Each_Cell_Solve = true;
// }
	
	static std::string  DEFAULT_PARAVIEW_OUTPUT_TYPE_MARKER = "Membrane Potential Only";
	static unsigned 	DEFAULT_PARAVIEW_OUTPUT_TYPE_NSCALAR = 1;

	class ConductingCellFunctionsBase
	{
	public:

		ConductingCellFunctionsBase() : StimFctPt(0), paraview_output_type(DEFAULT_PARAVIEW_OUTPUT_TYPE_MARKER), paraview_nscalar(DEFAULT_PARAVIEW_OUTPUT_TYPE_NSCALAR)
		{}

		~ConductingCellFunctionsBase(){}
		
		//Define the function template used for forcing terms and stuff
		typedef double (*CellInterfaceScalarFctPt)
		(const unsigned& ipt, const Vector<double>& s, const Vector<double>& x, const double& t);

		/////////////////////////////////////////////////////////////////////////////////
		//Get other variables
		//	these could be, for example:
		//	 strain in the tissue,
		//	 oxygen concentration,
		//	 variables which could be assigned node-wise, or could be the result of some computation and exist in a continuum
		//We leave this virtual since it's very implementation dependent, it could simply use function pointers to get the
		//	data we need as is seen in other source functions, or it could call on external elements to interpolate data
		//	from their own computation, or it could be any other exotic structure you like.
		/////////////////////////////////////////////////////////////////////////////////
		inline virtual void get_other_variables(const unsigned& ipt,
									            const Vector<double> &s,
									            const Vector<double>& x,
															const unsigned &l,
															const double &t,
															Vector<double> &Variables) const
		{

		}


		CellInterfaceScalarFctPt StimFctPt;


		inline double get_stimulus(const unsigned& ipt,
						            const Vector<double> &s,
						            const Vector<double>& x,
												const double &t) const
		{
			if(StimFctPt==nullptr){
				return 0.0;
			}
			else{
				return (*StimFctPt)(ipt,s,x,t);
			}
		}


		CellInterfaceScalarFctPt& Stimulus_Function_Pt()
		{
			return StimFctPt;
		}

		CellInterfaceScalarFctPt Stimulus_Function_Pt() const
		{
			return StimFctPt;
		}

		void set_paraview_output_type(const std::string& new_output_type)
		{
			paraview_output_type = new_output_type;
		}

		void default_paraview_output_type()
		{
			paraview_output_type = DEFAULT_PARAVIEW_OUTPUT_TYPE_MARKER;
		}


		void set_paraview_nscalar(const unsigned& new_paraview_nscalar)
		{
			paraview_nscalar = new_paraview_nscalar;
		}

		void default_paraview_nscalar()
		{
			paraview_nscalar = DEFAULT_PARAVIEW_OUTPUT_TYPE_NSCALAR;
		}


		void set_variable_names_broadcast_from_cell_mesh(std::vector<std::string>& new_names)
		{
			Variable_Names_BroadCast_From_Cell_Mesh = new_names;
		}

	protected:
		//Indicates what kind of outputting to do.
		//If this is set to DEFAULT_PARAVIEW_OUTPUT_TYPE_MARKER,
		// then only membrane potential is output.
		//Otherwise, it is assumed that the marker is the cell type for which data is being output
		// and interpolate_cell_variable(const unsigned& i) is called.
		std::string paraview_output_type;
		unsigned paraview_nscalar;
		std::vector<std::string> Variable_Names_BroadCast_From_Cell_Mesh;


	};

	typedef boost::numeric::ublas::vector< double > Boost_State_Type;
	typedef boost::numeric::ublas::matrix< double > boost_matrix_type;

	// typedef boost::numeric::odeint::runge_kutta_cash_karp54< Boost_State_Type > controlled_error_stepper_type;
	typedef boost::numeric::odeint::runge_kutta_fehlberg78< Boost_State_Type > controlled_error_stepper_type;
	typedef boost::numeric::odeint::rosenbrock4< Boost_State_Type > implicit_controlled_error_stepper_type;

// typedef Vector<double> Boost_State_Type;
// typedef DenseMatrix<double> boost_matrix_type;

// // typedef boost::numeric::odeint::runge_kutta_cash_karp54< Boost_State_Type > controlled_error_stepper_type;
// 	typedef boost::numeric::odeint::runge_kutta_fehlberg78< Boost_State_Type > controlled_error_stepper_type;
// 	typedef boost::numeric::odeint::rosenbrock4< Boost_State_Type > implicit_controlled_error_stepper_type;


	inline bool boostvectorcontainsnans(const Boost_State_Type& vect, const unsigned& n_vars)
	{
		for(unsigned i=0; i<n_vars; i++)
		{
			if(!std::isfinite(vect[i]))
			{
				return true;
			}
		}
		return false;
	}

	// inline bool boostvectorcontainsnans(const Boost_State_Type& vect, const unsigned& n_vars)
	// {
	// 	bool is_nan = false;
	// 	for(unsigned i=0; i<n_vars; i++)
	// 	{
	// 		//is_nan 
	// 		is_nan = (!std::isfinite(vect[i]) || is_nan);
	// 	}
	// 	return is_nan;
	// }

	// inline bool boostvectorcontainsnans(const Boost_State_Type& vect, const unsigned& n_vars)
	// {
	// 	double sum_val = 0.0;
	// 	for(unsigned i=0; i<n_vars; i++)
	// 	{
	// 		//is_nan 
	// 		sum_val+=vect[i];
	// 	}
	// 	return !std::isfinite(sum_val);
	// }


	namespace cellmodeldefaultvalues
	{
		static std::string DEFAULT_CELL_MODEL_NAME = "NONAME";


		static double Target_Solve_Error_Default = 1e-5;
	}

	class CellModelBaseFullySegregated
	{
	public:
		CellModelBaseFullySegregated() : Non_this_pointer(this), active_strain_index(-1), /*Integral_Iion(0.0)*//*Integral_Iion({0.0,0.0}),*/ /*MydVmdt(0.0)*/MydVmdt({0.0,0.0}), Base_Cell_Sources_Pt(0), Base_Node_Pt(0), Target_Solve_Error(cellmodeldefaultvalues::Target_Solve_Error_Default),
																		SingleCellUseBoostSolve(false),//by default use the Heun Euler implementation
																		Last_Used_Dt(1e9), //Last value of dt used
																		Cell_Model_Name(cellmodeldefaultvalues::DEFAULT_CELL_MODEL_NAME)
																		// BoostSolverMethod(0) //by default use RKF
																		// , BOOST_FD_STEP(1e-12)
		{
			//Resize the variable names vectors to zero
			Names_Of_Cell_Variables.resize(0);
			Names_Of_Other_Parameters.resize(0);
			Names_Of_Other_Variables.resize(0);
			Names_Of_Output_Data.resize(0);
		}
		virtual ~CellModelBaseFullySegregated(){}


		/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		//BEGIN functions which need to be overridden by a user

		//Get the v-th variables initial condition for cell_type,
		//	these MUST be written in the same order that you write the Names_Of_Cell_Variables vector entries.
		virtual double return_initial_state_variable(const unsigned &v, const unsigned &cell_type)
		{
			//Broken by default
			throw OomphLibError("return_initial_state_variable: This function has not been implemented yet",
				OOMPH_CURRENT_FUNCTION,
				OOMPH_EXCEPTION_LOCATION);
		}


		//Get the initial membrane potential for the cell_type-th cell type
		virtual double return_initial_membrane_potential(const unsigned &cell_type)
		{
			//Broken by default
			throw OomphLibError("return_initial_membrane_potential: This function has not been implemented yet",
				OOMPH_CURRENT_FUNCTION,
				OOMPH_EXCEPTION_LOCATION);
		}


		//Calculate the derivatives of the cell variables, also calculate the trans membrane current
		//	We provide the membrane current, the contemporary cell variable valyues, the time (just in case)
		//	the timestep (for rush larson methods), the cell type,
		//	other parameters (which represets time independent variables, e.g. a drug concentration or ion channel blockade),
		//	other variables (generally time dependent variables, e.g. strain in the tissue)
		//
		//	The function is to calculate the time derivatives of the cell variables, and populate the Variable_Derivatives,
		//	 the user must use the same keyword names as the variable, e.g. CellVariables[sxs], Variable_Derivatives[sxs] = (...)
		//	The user also provides the Iion which is the total transmembrane ionic current, which must be in pA/pF, i.e. current per capacitance
		//	 this way the membrane capacitance doesn't need to be passed to any other methods and the computations are neater.

		virtual void Calculate_Derivatives(const Boost_State_Type &Variables,
																			const double &t,
																			const unsigned &cell_type,
																			const double &Istim,
																			const Vector<double> &Other_Parameters,
																			const Vector<double> &Other_Variables,
																			Vector<double> &Variable_Derivatives,
																			double &Iion) 
		{
			//Broken by default
			throw OomphLibError("Calculate_Derivatives: This function has not been implemented yet",
				OOMPH_CURRENT_FUNCTION,
				OOMPH_EXCEPTION_LOCATION);
		}


		//Generate an unordered map of data required by things outside of the cell model, this could be
		//	active strain, or perhaps ion channel currents, or ionic species concentrations, we want to keep track of
		virtual void get_optional_output(const Boost_State_Type &Variables,
																		const double &t,
																		const unsigned &cell_type,
																		const double &Istim,
																		const Vector<double> &Other_Parameters,
																		const Vector<double> &Other_Variables,
																		Vector<double> &Out)
		{
			//Broken by default
			throw OomphLibError("get_optional_output: This function has not been implemented yet",
				OOMPH_CURRENT_FUNCTION,
				OOMPH_EXCEPTION_LOCATION);
		}

		//END functions which need to be overridden by a user
		/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

		//return the last value we solved up to.
		double get_time() const
		{
			// return MyLastT;
			return 0.0;
		}

		double get_predicted_vm() const
		{
			// return StateVariables[Num_Cell_Vars];
			return StateVariables.second[Num_Cell_Vars];
		}

		void set_predicted_vm(const double& new_vm)
		{
			// StateVariables[Num_Cell_Vars] = new_vm;
			StateVariables.second[Num_Cell_Vars] = new_vm;
		}


		double get_predicted_dvmdt() const
		{
			// return MydVmdt;
			return MydVmdt.second;
		}



		double get_Integral_Iion() const
		{
		// 	// return Integral_Iion;
		// 	return Integral_Iion.second;
			// return 0.0;
			throw OomphLibError("Integral Iion has been removed.",
			                       	OOMPH_CURRENT_FUNCTION,
			                       	OOMPH_EXCEPTION_LOCATION);
		}



		double get_cell_variable(const unsigned& i)
		{
			// return StateVariables[i];
			return StateVariables.second[i];
		}

		double get_active_strain() const
		{
			#ifdef PARANOID
			//If the user has failed to specify at which index the active strain is stored at then we throw an error 
			if(active_strain_index<0){
				throw OomphLibError("You appear to be attempting to access active strain stored in a cell element\nbut you haven't set the index at which it is stored. Please make sure that you override\nget_index_of_active_strain() to return the correct index you have stored it at.",
			                       	OOMPH_CURRENT_FUNCTION,
			                       	OOMPH_EXCEPTION_LOCATION);
			}
			#endif
			return Output_Data[active_strain_index];
		}

		void set_cell_type(const unsigned &cell_type){
			Cell_Type = cell_type;
		}

		unsigned get_cell_type()
		{
			return Cell_Type;
		}

		void set_other_data(const unsigned &var, const double &value){
			Other_Parameters[var] = value;
		}


		double get_additional_data_val(const unsigned &n)
		{
			#ifdef PARANOID
			if(n>Num_Output_Data-1)
			{
				throw OomphLibError("Index of requested output data too large.",
			                       	OOMPH_CURRENT_FUNCTION,
			                       	OOMPH_EXCEPTION_LOCATION);
			}
			#endif
			return Output_Data[n];
		}


		const void output_membrane_potential(std::ostream &outfile){
			// outfile << StateVariables[Num_Cell_Vars] << " ";
			outfile << StateVariables.second[Num_Cell_Vars] << " ";
		}

		const void output_global_coord(std::ostream &outfile){
			const unsigned dim=X.size();
			for(unsigned i=0; i<dim; i++){
				outfile << X[i] << " ";
			}
		}
 
		const void output_cell_variables(std::ostream &outfile){
			for(unsigned i=0; i<Num_Cell_Vars; i++){
				// outfile << StateVariables[i] << " ";
				outfile << StateVariables.second[i] << " ";
			}
		}


		const void output_additional_data(std::ostream &outfile){
			for(unsigned i=0; i<Num_Output_Data; i++){
				outfile << Output_Data[i] << " ";
			}
		}

		const void output_cell_type(std::ostream &outfile){
			outfile << Cell_Type << " ";
		}


		const std::string get_cell_model_name()
		{
			return Cell_Model_Name;
		}

		const void output_names_of_cell_variables(std::ostream &outfile){
			for(unsigned i=0; i<Num_Cell_Vars; i++){
				outfile << Names_Of_Cell_Variables[i] << " ";
			}
		}

		const void output_names_of_additional_data(std::ostream &outfile){
			for(unsigned i=0; i<Num_Output_Data; i++){
				outfile << Names_Of_Output_Data[i] << " ";
			}
		}

		//The names given to the cell variables, we use this because it's more user friendly,
		// it means a user does not need to also provide the number of cell variables, and they
		// can just call the variables by name rather than worrying about index
		const std::vector<std::string>& names_of_cell_variables() const
		{
			return Names_Of_Cell_Variables;
		}

		//The names of the other parameters passed to the function, we provide this for error checking,
		//	if the library is built with PARANOID then we can automatically check to ensure that the
		//	user is correctly creating the other parameters data.
		const std::vector<std::string>& names_of_other_parameters() const
		{
			return Names_Of_Other_Parameters;
		}

		//Same as above but for other variables which are in general time dependent.
		const std::vector<std::string>& names_of_other_variables() const
		{
			return Names_Of_Other_Variables;
		}

		//Same as above but for the data the cell model returns for other things to use
		const std::vector<std::string>& names_of_output_data() const 
		{
			return Names_Of_Output_Data;
		}


		const unsigned get_Num_Cell_Vars() const{
			return Num_Cell_Vars;
		}
		const unsigned get_Num_Other_Params() const{
			return 	Num_Other_Params;
		}
		const unsigned get_Num_Other_Vars() const{
			return 	Num_Other_Vars;
		}
		const unsigned get_Num_Output_Data() const{
			return 	Num_Output_Data;
		}


		//We provide an element and the coordinates within it at which this cell lives.
		//We use this information for suitably interpolating external data for computing the solution
		// to this cell model.
		//This poses a potential problem since solutions to finite element problems are not guaranteed to be
		// continuous and hence the solution within adjacent elements sharing the same node are also not
		// guaranteed to be the same. We get around this problem by assuming we are solving for a continuous
		// variable if it is to be sent to a cell model. This makes sense for things like membrane potential
		// or a concentration.
		void set_my_element_and_coordinate(ConductingCellFunctionsBase* ConductingCellFunctionsBase_Pt,
																				Node* Node_pt,
																				CellModelBaseFullySegregated* cell_pt,
																				const unsigned& Index_of_Vm,
																				const unsigned& ipt,
																				const Vector<double>& s,
																				const Vector<double>& x,
																				const unsigned& l)
		{
			Base_Cell_Sources_Pt = ConductingCellFunctionsBase_Pt;

			Base_Node_Pt = Node_pt;

			Non_this_pointer = cell_pt;

			Base_Node_Index_of_Vm = Index_of_Vm;

			Ipt = ipt;
			// S.resize(s.size());
			S = s;
			// X.resize(x.size());
			X = x;
			L = l;
		}


		const Node* base_node_pt()
		{
			return Base_Node_Pt;
		}

		const unsigned integral_point()
		{
			return Ipt;
		}

		const Vector<double> local_coord()
		{
			return S;
		}

		const Vector<double> global_coord()
		{
			return X;
		}

		const unsigned node_ind()
		{
			return L;
		}

		
		double get_stimulus_current(const double &t)
		{
			if(Base_Cell_Sources_Pt!=nullptr)
			{
				return (Base_Cell_Sources_Pt->get_stimulus)(Ipt, S, X, t);
			}
			else
			{
				return 0.0;
			}
		}

		void get_other_variables(const double& t, Vector<double> boost_Other_Variables)
		{
			if(Base_Cell_Sources_Pt!=nullptr)
			{
				(Base_Cell_Sources_Pt->get_other_variables)(Ipt, S, X, L, t, boost_Other_Variables);
			}
			else
			{
				//do nothing
			}
		}

		double get_base_node_membrane_potential()
		{
			if(Base_Cell_Sources_Pt!=nullptr)
			{
				return dynamic_cast<DimensionlessMembranePotentialEquationsBase*>(Base_Cell_Sources_Pt)->get_nodal_membrane_potential_BaseCellMembranePotential(L);
			}
			else
			{
				//throw an error since we explicitly asked for the membrane potential of the base node but none has been assigned
				throw OomphLibError("A cell is requesting its base node membrane potential but no such node exists.",
														OOMPH_CURRENT_FUNCTION,
														OOMPH_EXCEPTION_LOCATION);
			}
		}


		void set_target_solver_error(const double &new_target_error)
		{
			Target_Solve_Error = new_target_error;
		}

		void set_cell_use_boost_solver()
		{
			SingleCellUseBoostSolve = true;
		}

		void set_cell_not_use_boost_solver()
		{
			SingleCellUseBoostSolve = false;
		}

		// void set_boost_solver_method(const unsigned &method)
		// {
		// 	switch(method){
		// 		case 0://RKF
		// 					BoostSolverMethod = method
		// 		case 1://Explicit Euler
		// 					BoostSolverMethod = method
		// 		default:
		// 					throw OomphLibError("That is not a valid boost solver method",
		// 												OOMPH_CURRENT_FUNCTION,
		// 												OOMPH_EXCEPTION_LOCATION);
		// }

		//CALCULATE DERIVATIVES WITHOUT JACOBIAN
		//We need to check for nans/infs because boost does not do this by default for explicit timestepping methods
		void operator() ( const Boost_State_Type &x , Boost_State_Type &dxdt , const double t )
		{
			//Things used throughout the computation
			double boost_Iion = 0.0;
			Vector<double> boost_Variable_Derivatives(Num_Cell_Vars, 0.0);

			
			const double stimulus_current = get_stimulus_current(t);

			Vector<double> boost_Other_Variables(Num_Cell_Vars, 0.0);
			get_other_variables(t, boost_Other_Variables);

			Non_this_pointer->Calculate_Derivatives(x,
																							t,
																							Cell_Type,
																							stimulus_current,
																							Other_Parameters,
																							boost_Other_Variables,
																							boost_Variable_Derivatives,
																							boost_Iion);

			//Fill in the derivatives to be sent back to the boost solver
			dxdt[Num_Cell_Vars] = boost_Iion;
			for(unsigned i=0; i<Num_Cell_Vars; i++){
				dxdt[i] = boost_Variable_Derivatives[i];
			}

		}


		//CALCULATE DERIVATIVES WITH JACOBIAN

		//With time variation
		void operator()( const Boost_State_Type &  x  , boost_matrix_type &J , const double &  t)
		{
			Boost_State_Type dfdt(Num_Cell_Vars+1, 0.0);

			GeneralDerivatives(x, J, t, dfdt, false);
		}


		//Without time variation
		void operator()( const Boost_State_Type &  x  , boost_matrix_type &J , const double &  t, Boost_State_Type &dfdt )
		{
			GeneralDerivatives(x, J, t, dfdt, true);
		}
		
		
		

		//In general
		//We don't need to check for nans/infs in this case, since this will only be used for implicit methods and they check for non-finite values by default
		void GeneralDerivatives( const Boost_State_Type &  x  , boost_matrix_type &J , const double &  t, Boost_State_Type &dfdt, const bool calc_t_variation)
		{
			const double BOOST_FD_STEP=1e-9;
			//at the point we are calculating the jacobian
			double boost_Iion0 = 0.0;
			Vector<double> boost_Variable_Derivatives0(Num_Cell_Vars, 0.0);

			const double stimulus_current = get_stimulus_current(t);
			Vector<double> boost_Other_Variables(Num_Cell_Vars, 0.0);
			get_other_variables(t, boost_Other_Variables);

			Non_this_pointer->Calculate_Derivatives(x,
																							t,
																							Cell_Type,
																							stimulus_current,
																							Other_Parameters,
																							boost_Other_Variables,
																							boost_Variable_Derivatives0,
																							boost_Iion0);



			//For the finite differencing
			Boost_State_Type x1 = x;
			
			double boost_Iion1 = 0.0;
			Vector<double> boost_Variable_Derivatives1(Num_Cell_Vars, 0.0);

			for(unsigned i=0; i<Num_Cell_Vars+1; i++){
				//Increment the variable
				x1[i] += BOOST_FD_STEP;

				Non_this_pointer->Calculate_Derivatives(x1,
																							t,
																							Cell_Type,
																							stimulus_current,
																							Other_Parameters,
																							boost_Other_Variables,
																							boost_Variable_Derivatives1,
																							boost_Iion1);

				//Finite difference the variables
				for(unsigned j=0; j<Num_Cell_Vars; j++){
					J( j , i ) = (boost_Variable_Derivatives1[j] - boost_Variable_Derivatives0[j])/BOOST_FD_STEP;
				}
				//Finite difference the membrane potential
				J( Num_Cell_Vars , Num_Cell_Vars ) = (boost_Iion1 - boost_Iion0)/BOOST_FD_STEP;

				x1[i] -= BOOST_FD_STEP;
			}




			//Finite difference in time
			if(calc_t_variation)
			{
				const double t1 = t + BOOST_FD_STEP;
				const double stimulus_current1 = get_stimulus_current(t1);
				Vector<double> boost_Other_Variables1(Num_Cell_Vars, 0.0);
				get_other_variables(t1, boost_Other_Variables1);

				Non_this_pointer->Calculate_Derivatives(x,
																								t1,
																								Cell_Type,
																								stimulus_current1,
																								Other_Parameters,
																								boost_Other_Variables1,
																								boost_Variable_Derivatives1,
																								boost_Iion1);

				//Finite difference the variables
					for(unsigned i=0; i<Num_Cell_Vars; i++){
						dfdt[i] = (boost_Variable_Derivatives1[i] - boost_Variable_Derivatives0[i])/BOOST_FD_STEP;
					}
					//Finite difference the membrane potential
					dfdt[Num_Cell_Vars] = (boost_Iion1 - boost_Iion0)/BOOST_FD_STEP;
				}
		}	






		void reset_copy_variables_to_IC_values()
		{
			// Integral_Iion.second = Integral_Iion.first;

			MydVmdt.second = MydVmdt.first;

			for(unsigned i=0; i<Num_Cell_Vars; i++)
			{
				StateVariables.second[i] = StateVariables.first[i];
			}
		}

		void accept_copy_variables_as_IC_values()
		{
			// Integral_Iion.first = Integral_Iion.second;

			MydVmdt.first = MydVmdt.second;

			for(unsigned i=0; i<Num_Cell_Vars; i++)
			{
				StateVariables.first[i] = StateVariables.second[i];
			}
		}
	
		//Take a timestep using boost solver. pass the initial time and total duration of the solve
		// the boolean use_node_vm_as_initial_value indicates whether or not the cell should use it's
		// internally stored value of vm or the value stored in the underlying oomph-lib node
		void TakeTimestep(const double &t, const double& dt, const bool &use_node_vm_as_initial_value = false)
		{
			//Fill in the current Vm and variable values
			Boost_State_Type x(Num_Cell_Vars+1, 0.0);


			//Fill in membrane potential
			if(use_node_vm_as_initial_value)
			{
				x[Num_Cell_Vars] = get_base_node_membrane_potential();
			}
			else
			{
				x[Num_Cell_Vars] = StateVariables.second[Num_Cell_Vars];
			}

			//Fill in cell variables
			for(unsigned i=0; i<Num_Cell_Vars; i++)
			{
				x[i] = StateVariables.second[i];
			}


			#ifdef PARANOID
			if(boostvectorcontainsnans(x, Num_Cell_Vars+1))
			{
				oomph_info << "Initial state vector is corrupted, this shouldn't have occurred since we have checks for this at the end of each cell solve.\n Perhaps a newton solve preceeding this one resulted in NaNs..." << std::endl;
				for(unsigned i=0; i<Num_Cell_Vars+1; i++)
				{
					oomph_info << x[i] << std::endl;
				}
					//throw an error since we explicitly asked for the membrane potential of the base node but none has been assigned
				throw OomphLibError("Inherited nans/infs in cell solve.",
														OOMPH_CURRENT_FUNCTION,
														OOMPH_EXCEPTION_LOCATION);
			}
			#endif

			// if(SingleCellUseBoostSolve)
			// {
			///////////////////////////////////////////////////////////////////////////////////
			//BOOOOOST SOLVE


				// double N_solve = 0;
				// do
				// {
				// 	N_solve++;
				// 	// oomph_info << "Attempt " << N_solve << std::endl;
					
				// 	double T = t;

				// 	const unsigned N = pow(2, N_solve-1);
				// 	double DT = dt/(double)N;

				// 	//Set the value of DT stored in the cell model, used when solving equations with rush-larsen
				// 	dt_rushlarsen = DT;

				// 	//Fill in membrane potential
				// 	if(use_node_vm_as_initial_value)
				// 	{
				// 		x[Num_Cell_Vars] = get_base_node_membrane_potential();
				// 	}
				// 	else
				// 	{
				// 		x[Num_Cell_Vars] = StateVariables.second[Num_Cell_Vars];
				// 	}

				// 	//Fill in cell variables
				// 	for(unsigned i=0; i<Num_Cell_Vars; i++)
				// 	{
				// 		x[i] = StateVariables.second[i];
				// 	}


				// 	for(double k=0; k<N; k++)
				// 	{
				// 		//Controlled explicit method
				// 		// integrate_adaptive( boost::numeric::odeint::make_controlled<controlled_error_stepper_type>(1.0e-10, 1.0e-10),
				// 		// 		(*this), x, T, T+DT, DT);

				// 		//This selection of absolute and relative errors seems to perform more efficiently than the above
				// 		// integrate_adaptive( boost::numeric::odeint::make_controlled<controlled_error_stepper_type>(Target_Solve_Error, Target_Solve_Error),
				// 		// 		(*this), x, T, T+DT, DT);

				// 		// oomph_info << T << " " << T+DT << " " << DT << std::endl;

				// 		//Explicit euler
				// 		boost::numeric::odeint::euler<Boost_State_Type> Euler;
				// 		Euler.do_step((*this), x, T, DT);


				// 		//NOT WORKING YET

				// 		//Controlled implicit method
				// 		// boost::numeric::odeint::rosenbrock4_controller<boost::numeric::odeint::rosenbrock4<double>> stepper;
				// 		// integrate_adaptive(stepper, std::make_pair((*this), (*this)), x, T, T+DT, DT);

				// 		//Implicit Euler
				// 		// boost::numeric::odeint::implicit_euler<double> stepper;
				// 		// stepper.do_step(std::make_pair((*this), (*this)), x, T, DT);

				// 		T+=DT;
				// 	}

				// }
				// while(boostvectorcontainsnans(x, Num_Cell_Vars+1));



				// //FERL, max time-step 0.01ms
				// double N_solve = 1;
				// if(dt>0.01)
				// {
				// 	N_solve = std::ceil(dt/0.01);
				// }
				// do
				// {					
				// 	double T = t;

				// 	// const unsigned N_solve = pow(2, N_solve-1);
				// 	double DT = dt/(double)N_solve;

				// 	//Set the value of DT stored in the cell model, used when solving equations with rush-larsen
				// 	dt_rushlarsen = DT;

				// 	//Fill in membrane potential
				// 	if(use_node_vm_as_initial_value)
				// 	{
				// 		x[Num_Cell_Vars] = get_base_node_membrane_potential();
				// 	}
				// 	else
				// 	{
				// 		x[Num_Cell_Vars] = StateVariables.second[Num_Cell_Vars];
				// 	}

				// 	//Fill in cell variables
				// 	for(unsigned i=0; i<Num_Cell_Vars; i++)
				// 	{
				// 		x[i] = StateVariables.second[i];
				// 	}


				// 	for(double k=0; k<N_solve; k++)
				// 	{
				// 		//Controlled explicit method
				// 		// integrate_adaptive( boost::numeric::odeint::make_controlled<controlled_error_stepper_type>(1.0e-10, 1.0e-10),
				// 		// 		(*this), x, T, T+DT, DT);

				// 		//This selection of absolute and relative errors seems to perform more efficiently than the above
				// 		// integrate_adaptive( boost::numeric::odeint::make_controlled<controlled_error_stepper_type>(Target_Solve_Error, Target_Solve_Error),
				// 		// 		(*this), x, T, T+DT, DT);

				// 		// oomph_info << T << " " << T+DT << " " << DT << std::endl;
						
				// 		//Explicit euler
				// 		boost::numeric::odeint::euler<Boost_State_Type> Euler;
				// 		Euler.do_step((*this), x, T, DT);


				// 		//NOT WORKING YET

				// 		//Controlled implicit method
				// 		// boost::numeric::odeint::rosenbrock4_controller<boost::numeric::odeint::rosenbrock4<double>> stepper;
				// 		// integrate_adaptive(stepper, std::make_pair((*this), (*this)), x, T, T+DT, DT);

				// 		//Implicit Euler
				// 		// boost::numeric::odeint::implicit_euler<double> stepper;
				// 		// stepper.do_step(std::make_pair((*this), (*this)), x, T, DT);

				// 		T+=DT;
				// 	}

				// 	N_solve*=2.0;
				// }
				// while(boostvectorcontainsnans(x, Num_Cell_Vars+1));




			// 	// Explicit method
			// 	boost::numeric::odeint::bulirsch_stoer< Boost_State_Type > stepper( 1E-8 , 0.0 , 0.0 , 0.0 );
			// 	integrate_adaptive(stepper, (*this), x, t, t+dt, dt);

			// 	// Explicit euler method
			// 	boost::numeric::odeint::euler<Boost_State_Type> Euler;
			// 	Euler.do_step((*this), x, t, dt);

			// 	// Controlled Implicit method
			// 	boost::numeric::odeint::rosenbrock4_controller<boost::numeric::odeint::rosenbrock4<double>> stepper;
			// 	integrate_adaptive(stepper, std::make_pair((*this), (*this)), x, t, t+dt, dt);

			// 	// Implicit euler method
			// 	boost::numeric::odeint::implicit_euler<double> stepper;
			// 	stepper.do_step(std::make_pair((*this), (*this)), x, t, dt);
			// }


			// END BOOOOOST SOLVE
			/////////////////////////////////////////////////////////////////////////////////

			// else
			// {

			// // ///////////////////////////////////////////////////////////////////////////////////
			// //CUSTOM HEUN-EULER SOLVE
			// //Running time
			// double T = t;
			// //Initially attempted timestep
			// double DT = dt;
			// //Desired convergence
			// // static double HeunEulerTolerance = 1e-5;

			// //Heun Euler with non-finite check
			// Boost_State_Type x_np1_1(Num_Cell_Vars+1, 0.0);
			// Boost_State_Type x_np1_2(Num_Cell_Vars+1, 0.0);

			// Boost_State_Type K1(Num_Cell_Vars+1, 0.0);
			// Boost_State_Type K2(Num_Cell_Vars+1, 0.0);

			// //Error
			// double tau = 0.0;

			// //Get derivative at start point
			// (*this)(x, K1, T);

			// const double T_End = T+DT;
			// while(T<T_End)
			// {
			// 	//Calculate initial guess
			// 	for(unsigned i=0; i<Num_Cell_Vars+1; i++)
			// 	{
			// 		x_np1_1[i] = x[i]+K1[i]*DT;
			// 	}

			// 	//Calculate derivative at end point
			// 	(*this)(x_np1_1, K2, T+DT);

			// 	//Does it contain nans?
			// 	if(boostvectorcontainsnans(K2, Num_Cell_Vars+1))
			// 	{
			// 		//If it does, halve the timestep and try again
			// 		DT *= 0.5;
			// 		continue;
			// 	}


			// 	//Calculate second guess
			// 	for(unsigned i=0; i<Num_Cell_Vars+1; i++)
			// 	{
			// 		x_np1_2[i] = x[i]+0.5*DT*(K1[i]+K2[i]);
			// 	}
				

			// 	tau = 0.0;
			// 	for(unsigned i=0; i<Num_Cell_Vars+1; i++)
			// 	{
			// 		tau += std::fabs(x_np1_1[i] - x_np1_2[i]);
			// 	}

			// 	if(tau<Target_Solve_Error)
			// 	{
			// 		T+=DT;
			// 		x = x_np1_2;
			// 		K1 = K2;
			// 	}
			// 	DT = std::min(T_End-T, 0.9*DT*std::min(std::max(pow(Target_Solve_Error/(2.0*tau),0.5),0.3), 2.0));
			// }
			// //CUSTOM HEUN-EULER SOLVE
			// // ///////////////////////////////////////////////////////////////////////////////////


			///////////////////////////////////////////////////////////////////////////////////
			// //CUSTOM HEUN-EULER SOLVE WITH BOOST ERROR MEASURE
			//Running time
			double T = t;
			//Initially attempted timestep
			// double DT = dt;
			double DT = std::min(dt, Last_Used_Dt);
			//Desired convergence
			// static double HeunEulerTolerance = 1e-5;

			//Heun Euler with non-finite check
			Boost_State_Type x_np1_1(Num_Cell_Vars+1, 0.0);
			Boost_State_Type x_np1_2(Num_Cell_Vars+1, 0.0);

			Boost_State_Type K1(Num_Cell_Vars+1, 0.0);
			Boost_State_Type K2(Num_Cell_Vars+1, 0.0);

			//Error
			double tau = 0.0;
			double sk = 0.0;

			//Get derivative at start point
			(*this)(x, K1, T);

			const double T_End = T+dt;

			// oomph_info << "(" << T << ", " << T_End << "): initial dt: " << DT << std::endl;
			unsigned solve_counter = 0;
			unsigned nan_counter = 0;
			unsigned converged_counter = 0;
			unsigned diverged_counter = 0;


			while(T<T_End)
			{
				solve_counter++;
				//Calculate initial guess
				for(unsigned i=0; i<Num_Cell_Vars+1; i++)
				{
					x_np1_1[i] = x[i]+K1[i]*DT;
				}

				//Calculate derivative at end point
				(*this)(x_np1_1, K2, T+DT);

				//Does it contain nans?
				if(boostvectorcontainsnans(K2, Num_Cell_Vars+1))
				{
					// oomph_info << "\t(" << T << ", " << (T+DT) << ") Produced Nans." << std::endl;
					//If it does, halve the timestep and try again
					nan_counter++;

					DT *= 0.5;
					continue;
				}


				//Calculate second guess
				for(unsigned i=0; i<Num_Cell_Vars+1; i++)
				{
					x_np1_2[i] = x[i]+0.5*DT*(K1[i]+K2[i]);
				}
				

				tau = 0.0;
				sk = 0.0;
				for(unsigned i=0; i<Num_Cell_Vars+1; i++)
				{
					// sk = Target_Solve_Error + Target_Solve_Error * std::max(std::abs(x_np1_2[i]), std::abs(x_np1_1[i]));
					sk = 1.0 + 1.0 * std::max(std::fabs(x_np1_2[i]), std::fabs(x_np1_1[i]));
					tau += (x_np1_1[i] - x_np1_2[i])*(x_np1_1[i] - x_np1_2[i]) / sk / sk;
					// tau += std::fabs(x_np1_1[i] - x_np1_2[i]);
				}
				tau = sqrt(tau/(Num_Cell_Vars+1.0));

				if(tau<Target_Solve_Error)
				{
					// oomph_info << T << " " << T+DT << " " << DT << std::endl;
					T+=DT;
					x = x_np1_2;
					K1 = K2;
					converged_counter++;
				}
				else
				{
					// oomph_info << "\tDid not converge." << std::endl;
					diverged_counter++;
				}
				if(T<T_End)
				{
					DT = std::min(T_End-T, 0.9*DT*std::min(std::max(pow(Target_Solve_Error/(2.0*tau),0.5),0.3), 2.0));
				}
			}
			// oomph_info << "\t Took " << solve_counter << " solves. " << nan_counter << " " << converged_counter << " " << diverged_counter << std::endl;
			Last_Used_Dt = DT;
			//CUSTOM HEUN-EULER SOLVE
			///////////////////////////////////////////////////////////////////////////////////





			///////////////////////////////////////////////////////////////////////////////////
			// //Toms version of Mountris and Pueyo
			// Boost_State_Type K1(Num_Cell_Vars+1, 0.0);
			// Boost_State_Type K2(Num_Cell_Vars+1, 0.0);
			// (*this)(x, K1, t);
			// Boost_State_Type X1(Num_Cell_Vars+1, 0.0);

			// static double QG_FD = 1e-3;

			// for(unsigned i=0; i<Num_Cell_Vars+1; i++)
			// {
			// 	X1[i] = x[i] + K1[i]*QG_FD;
			// }

			// (*this)(X1, K2, t+QG_FD);

			// double max_err = 0.0;
			// for(unsigned i=0; i<Num_Cell_Vars+1; i++)
			// {
			// 	max_err = std::max(max_err, std::abs(K2[i]-K1[i]));
			// }

			// double DT = std::min(2.0*Target_Solve_Error/max_err, dt);

			// // unsigned K = unsigned(dt/DT);
			// // oomph_info << DT << " " << K << " " << dt_final << std::endl;
			// // oomph_info << DT << " " << K << std::endl;

			// double T=t;

			// // for(unsigned i=0;i<K;i++)
			// while(T<t+dt)
			// {
			// 	DT = std::min(DT, t+dt-T);
			// 	if(DT<0.0)
			// 	{
			// 		throw OomphLibError("Why is DT negative??",
			// 											OOMPH_CURRENT_FUNCTION,
			// 											OOMPH_EXCEPTION_LOCATION);
			// 	}
			// 	if(T>=t+dt)
			// 	{
			// 		break;
			// 	}

			// 	for(unsigned i=0; i<Num_Cell_Vars+1; i++)
			// 	{
			// 		X1[i] = x[i] + K1[i]*DT;
			// 	}

			// 	//Calculate the derivative at the newly calculated point
			// 	(*this)(x, K2, T);

			// 	//If that derivative contains no nans...
			// 	if(!boostvectorcontainsnans(K2, Num_Cell_Vars+1))
			// 	{
			// 		//Accept it, advance time and the solution
			// 		T+=DT;
			// 		x=X1;
			// 		K1=K2;
			// 	}
			// 	else
			// 	{
			// 		//Re-calculate the time-step by getting a new measure of the error
			// 		for(unsigned i=0; i<Num_Cell_Vars+1; i++)
			// 		{
			// 			X1[i] = x[i] + K1[i]*QG_FD;
			// 		}
			// 		(*this)(X1, K2, T+QG_FD);
			// 		max_err = 0.0;
			// 		for(unsigned i=0; i<Num_Cell_Vars+1; i++)
			// 		{
			// 			max_err = std::max(max_err, std::abs(K2[i]-K1[i]));
			// 		}
			// 		DT = std::min(2.0*Target_Solve_Error/max_err, t+dt-T);

			// 		if(DT<1e-12)
			// 		{
			// 			throw OomphLibError("DT of (almost) zero was requested??",
			// 												OOMPH_CURRENT_FUNCTION,
			// 												OOMPH_EXCEPTION_LOCATION);
			// 		}

			// 		// K = unsigned((t+dt-T)/DT);

			// 		// oomph_info << "Recalculating DT (NaNs) " << T << " " << DT << " " << K << std::endl;
			// 	}
			// }


			//Toms version of Mountris and Pueyo with dynamically changing dt
			// Boost_State_Type K1(Num_Cell_Vars+1, 0.0);
			// Boost_State_Type K2(Num_Cell_Vars+1, 0.0);
			// (*this)(x, K1, t);
			// Boost_State_Type X1(Num_Cell_Vars+1, 0.0);

			// static double QG_FD = 1e-3;

			// for(unsigned i=0; i<Num_Cell_Vars+1; i++)
			// {
			// 	X1[i] = x[i] + K1[i]*QG_FD;
			// }

			// (*this)(X1, K2, t+QG_FD);

			// double max_err = 0.0;
			// for(unsigned i=0; i<Num_Cell_Vars+1; i++)
			// {
			// 	max_err = std::max(max_err, std::abs(K2[i]-K1[i]));
			// }

			// double DT = std::min(2.0*Target_Solve_Error/max_err, dt);
			// // double DT = std::min(dt, 0.9*dt*std::min(std::max(pow(Target_Solve_Error/(2.0*max_err),0.5),0.3), 2.0));

			// // unsigned K = unsigned(dt/DT);
			// // oomph_info << DT << " " << K << " " << dt_final << std::endl;
			// // oomph_info << DT << " " << K << std::endl;

			// double T=t;

			// // for(unsigned i=0;i<K;i++)
			// while(T<t+dt)
			// {
			// 	DT = std::min(DT, t+dt-T);
			// 	if(DT<0.0)
			// 	{
			// 		throw OomphLibError("Why is DT negative??",
			// 											OOMPH_CURRENT_FUNCTION,
			// 											OOMPH_EXCEPTION_LOCATION);
			// 	}
			// 	if(T>=t+dt)
			// 	{
			// 		break;
			// 	}

			// 	for(unsigned i=0; i<Num_Cell_Vars+1; i++)
			// 	{
			// 		X1[i] = x[i] + K1[i]*DT;
			// 	}

			// 	//Calculate the derivative at the newly calculated point
			// 	(*this)(x, K2, T);

			// 	//If that derivative contains no nans...
			// 	if(!boostvectorcontainsnans(K2, Num_Cell_Vars+1))
			// 	{
			// 		//Advance time and the solution

			// 		T+=DT;

			// 		x=X1;

			// 		//The error is proportional to the second derivative of x, dynamically alter DT in response
			// 		max_err = 0.0;
			// 		for(unsigned i=0; i<Num_Cell_Vars+1; i++)
			// 		{
			// 			max_err = std::max(max_err, std::abs(K2[i]-K1[i]));
			// 		}
			// 		DT = std::min(2.0*Target_Solve_Error/max_err, t+dt-T);
			// 			// DT = std::min(t+dt-T, 0.9*DT*std::min(std::max(pow(Target_Solve_Error/(2.0*max_err),0.5),0.3), 2.0));

			// 		//Accept the derivative at this point
			// 		K1=K2;
			// 	}
			// 	else
			// 	{
			// 		DT*=0.5;

			// 		if(DT<1e-12)
			// 		{
			// 			throw OomphLibError("DT of (almost) zero was requested??",
			// 												OOMPH_CURRENT_FUNCTION,
			// 												OOMPH_EXCEPTION_LOCATION);
			// 		}

			// 		// K = unsigned((t+dt-T)/DT);
			// 		// oomph_info << "Recalculating DT (NaNs) " << T << " " << DT << " " << K << std::endl;
			// 	}
			// }
			///////////////////////////////////////////////////////////////////////////////////
			
			///////////////////////////////////////////////////////////////////////////////////
			//Mountris and Pueyo, Zhilin Qu and Alan Garfinkel
			// static double dt_0 = 0.001;

			// const int k_max = std::floor(dt/dt_0);

			// const double dvdt = ((get_base_node_membrane_potential()-StateVariables.second[Num_Cell_Vars])/dt)*use_node_vm_as_initial_value + MydVmdt.second*(!use_node_vm_as_initial_value);
			
			// // const unsigned k_0 = 1 + (dvdt>0.0)*4;

			// // const unsigned k=std::min(k_max, k_0+std::floor(std::abs(dvdt)));

			// const unsigned k = std::min(std::max(1, (int)std::floor(std::abs(dvdt))), k_max);

			// double DT = dt/k;

			// double T=t;
			// Boost_State_Type K1(Num_Cell_Vars+1, 0.0);

			// for(unsigned i=0;i<k;i++)
			// {
			// 	(*this)(x, K1, T);
			// 	if(!boostvectorcontainsnans(K1, Num_Cell_Vars+1))
			// 	{
			// 		for(unsigned i=0; i<Num_Cell_Vars+1; i++)
			// 		{
			// 			x[i] += K1[i]*DT;
			// 		}
			// 	}
			// 	else
			// 	{
			// 		throw OomphLibError("Chosen dt does not converge.",
			// 											OOMPH_CURRENT_FUNCTION,
			// 											OOMPH_EXCEPTION_LOCATION);
			// 	}
			// 	T+=DT;
			// }


			// double DT = dt;

			// double T=t;
			// Boost_State_Type K1(Num_Cell_Vars+1, 0.0);
			// Boost_State_Type X(Num_Cell_Vars+1, 0.0);

			// for(unsigned i=0; i<Num_Cell_Vars+1; i++)
			// {
			// 	X[i] = x[i];
			// }

			// const double T_End = T+DT;
			// while(T<T_End)
			// {
			// 	(*this)(X, K1, T);
			// 	if(!boostvectorcontainsnans(K1, Num_Cell_Vars+1))
			// 	{
			// 		// oomph_info << "Success " << T << " " << DT << std::endl;
			// 		for(unsigned i=0; i<Num_Cell_Vars+1; i++)
			// 		{
			// 			X[i] = X[i] + K1[i]*DT;
			// 		}
			// 		T+=DT;
			// 	}
			// 	else
			// 	{
			// 		// oomph_info << "Failed " << T << " " << DT << std::endl;
			// 		for(unsigned i=0; i<Num_Cell_Vars+1; i++)
			// 		{
			// 			X[i] = x[i];
			// 		}
			// 		T=t;
			// 		DT*=0.5;
			// 	}
			// }
		
			//
			///////////////////////////////////////////////////////////////////////////////////



			// }//end use custom solver


			//Calculate the integral of membrane current by the fundamental theorem of calculus
			// Integral_Iion.second = (x[Num_Cell_Vars] - StateVariables.second[Num_Cell_Vars]);

			//Calculate the cells approximation of the derivative of Vm
			// MydVmdt.second = (x[Num_Cell_Vars] - StateVariables.second[Num_Cell_Vars])/dt;

			StateVariables.second[Num_Cell_Vars] = x[Num_Cell_Vars];
			for(unsigned i=0; i<Num_Cell_Vars; i++){
				StateVariables.second[i] = x[i];
			}
			

			//Update the most recent value of time we have solved up to
			// MyLastT = (t+dt);
		}




		void calculate_optional_output(const double &t)
		{

			const double stimulus_current = get_stimulus_current(t);

			Vector<double> Other_Variables(Num_Cell_Vars, 0.0);

			get_other_variables(t, Other_Variables);

			get_optional_output(StateVariables.second,
													t,
													Cell_Type,
													stimulus_current,
													Other_Parameters,
													Other_Variables,
													Output_Data);
		}



		//Update the membrane potential of the underlying node to be consistent with that of the cell
		void update_underlying_node_membrane_potential()
		{
			// #ifdef PARANOID
			// if(dynamic_cast<DimensionlessMembranePotentialEquationsBase*>(Base_Cell_Sources_Pt)==nullptr){
			// 	throw OomphLibError("No node assigned to this cell.",
			//                        	OOMPH_CURRENT_FUNCTION,
			//                        	OOMPH_EXCEPTION_LOCATION);
			// }
			// #endif
			// // dynamic_cast<DimensionlessMembranePotentialEquationsBase*>(Base_Cell_Sources_Pt)->update_nodal_membrane_potential_BaseCellMembranePotential(L, MyVm);
			// dynamic_cast<DimensionlessMembranePotentialEquationsBase*>(Base_Cell_Sources_Pt)->update_nodal_membrane_potential_BaseCellMembranePotential(L, StateVariables.second[Num_Cell_Vars]);
			
			// oomph_info << "Updating underlying node" << std::endl;
			// oomph_info << StateVariables.second.size() << std::endl;
			// for(unsigned i=0; i<Num_Cell_Vars+1; i++)
			// {
			// 	oomph_info << StateVariables.second[i] << std::endl;
			// }
			// oomph_info << Base_Cell_Sources_Pt << std::endl;


			if(Base_Cell_Sources_Pt!=nullptr){
				dynamic_cast<DimensionlessMembranePotentialEquationsBase*>(Base_Cell_Sources_Pt)->update_nodal_membrane_potential_BaseCellMembranePotential(L, StateVariables.second[Num_Cell_Vars]);
			}
		}

		//Update the membrane potential of the underlying node to be consistent with that of the cell
		void assign_underlying_node_additional_initial_conditions()
		{
			// #ifdef PARANOID
			// if(dynamic_cast<DimensionlessMembranePotentialEquationsBase*>(Base_Cell_Sources_Pt)==nullptr){
			// 	throw OomphLibError("No node assigned to this cell.",
			//                        	OOMPH_CURRENT_FUNCTION,
			//                        	OOMPH_EXCEPTION_LOCATION);
			// }
			// #endif
			// // dynamic_cast<DimensionlessMembranePotentialEquationsBase*>(Base_Cell_Sources_Pt)->update_nodal_membrane_potential_BaseCellMembranePotential(L, MyVm);
			// dynamic_cast<DimensionlessMembranePotentialEquationsBase*>(Base_Cell_Sources_Pt)->assign_additional_initial_conditions(L);

			if(Base_Cell_Sources_Pt!=nullptr){
				dynamic_cast<DimensionlessMembranePotentialEquationsBase*>(Base_Cell_Sources_Pt)->assign_additional_initial_conditions(L);
			}
		}

		//Assign initial conditions or update the current values of variables
		//When updating the vm of the underlying node this is not done directly
		// but calls a function of the underlying element - this is because
		// the value stored in the underlying node may not actually
		// represent vm.

		void assign_initial_conditions(const bool &also_set_nodal_value = false)
		{
			//Assign initial conditions from the cell model

			// Integral_Iion = 0.0;
			// Integral_Iion.first = 0.0;
			// Integral_Iion.second = 0.0;

			
			// //Cell variables
			// for(unsigned i=0; i<Num_Cell_Vars; i++){
			// 	StateVariables[i] = this->return_initial_state_variable(i, Cell_Type);
			// }
			// //Membrane potential
			// StateVariables[Num_Cell_Vars] = this->return_initial_membrane_potential(Cell_Type);

			//Cell variables
			for(unsigned i=0; i<Num_Cell_Vars; i++){
				StateVariables.first[i] = this->return_initial_state_variable(i, Cell_Type);
				StateVariables.second[i] = StateVariables.first[i];
			}
			//Membrane potential
			StateVariables.first[Num_Cell_Vars] = this->return_initial_membrane_potential(Cell_Type);
			StateVariables.second[Num_Cell_Vars] = StateVariables.first[Num_Cell_Vars];

			if(also_set_nodal_value)
			{
				update_underlying_node_membrane_potential();

				assign_underlying_node_additional_initial_conditions();
			}
		}

		//Used to update values post mpi solve to be consistent with values on other processors
		void assign_values_post_mpi_solve(const Vector<double>& vals, const double& vm, const bool &also_set_nodal_value = false)
		{	

			// //Update the integral of iion
			// Integral_Iion = (vm - StateVariables[Num_Cell_Vars]);

			// //Membrane potential
			// StateVariables[Num_Cell_Vars] = vm;

			// //Cell variables
			// for(unsigned i=0; i<Num_Cell_Vars; i++){
			// 	StateVariables[i] = vals[i];
			// }


			//I'm not sure which StateVariables to set here

			//Update the integral of iion
			// Integral_Iion = (vm - StateVariables.first[Num_Cell_Vars]);
			// Integral_Iion.first = (vm - StateVariables.first[Num_Cell_Vars]);
			// Integral_Iion.second = Integral_Iion.first;

			//Membrane potential
			StateVariables.first[Num_Cell_Vars] = vm;
			StateVariables.second[Num_Cell_Vars] = StateVariables.first[Num_Cell_Vars];

			//Cell variables
			for(unsigned i=0; i<Num_Cell_Vars; i++){
				StateVariables.first[i] = vals[i];
				StateVariables.second[i] = StateVariables.first[i];
			}

			if(also_set_nodal_value)
			{
				update_underlying_node_membrane_potential();
			}
		}


		//Assign initial conditions
		void assign_initial_conditions(const Vector<double>& vals, const double& vm, const bool &also_set_nodal_value = false)
		{		

			//Update the integral of iion
			// Integral_Iion = 0.0;
			// Integral_Iion.first = 0.0;
			// Integral_Iion.second = 0.0;

			// //Membrane potential
			// StateVariables[Num_Cell_Vars] = vm;

			// //Cell variables
			// for(unsigned i=0; i<Num_Cell_Vars; i++){
			// 	StateVariables[i] = vals[i];
			// }

			//Membrane potential
			StateVariables.first[Num_Cell_Vars] = vm;
			StateVariables.second[Num_Cell_Vars] = StateVariables.first[Num_Cell_Vars];

			//Cell variables
			for(unsigned i=0; i<Num_Cell_Vars; i++){
				StateVariables.first[i] = vals[i];
				StateVariables.second[i] = StateVariables.first[i];
			}

			if(also_set_nodal_value)
			{
				update_underlying_node_membrane_potential();

				assign_underlying_node_additional_initial_conditions();
			}
		}

		void assign_initial_membrane_potential(const double& Vm, const bool &also_set_nodal_value = false)
		{
			// MyVm = Vm;
			// StateVariables[Num_Cell_Vars] = Vm;

			// oomph_info << "Num_Cell_Vars " << Num_Cell_Vars << std::endl;
			// oomph_info << "StateVariables.first " << StateVariables.first.size() << std::endl;
			// oomph_info << "StateVariables.second " << StateVariables.second.size() << std::endl;

			StateVariables.first[Num_Cell_Vars] = Vm;
			StateVariables.second[Num_Cell_Vars] = StateVariables.first[Num_Cell_Vars];

			if(also_set_nodal_value)
			{
				update_underlying_node_membrane_potential();

				assign_underlying_node_additional_initial_conditions();
			}
		}

		void assign_initial_conditions(Vector<double>::iterator itStart, const bool &also_set_nodal_value = false)
		{
			Vector<double>::iterator it = itStart;
			
			// StateVariables[Num_Cell_Vars] = *(++it);
			// for(unsigned i=0; i<Num_Cell_Vars; i++){
			// 	StateVariables[i] = *(++it);
			// }

			StateVariables.first[Num_Cell_Vars] = *(++it);
			StateVariables.second[Num_Cell_Vars] = StateVariables.first[Num_Cell_Vars];
			for(unsigned i=0; i<Num_Cell_Vars; i++){
				StateVariables.first[i] = *(++it);
				StateVariables.second[i] = StateVariables.first[i];
			}

			if(also_set_nodal_value)
			{
				update_underlying_node_membrane_potential();

				assign_underlying_node_additional_initial_conditions();
			}
		}


		void save_state_to_vector(Vector<double>& state)
		{
			// state.resize(Num_Cell_Vars+1+1+1+1);
			state.resize(Num_Cell_Vars+1+1);
			for(unsigned i=0; i<Num_Cell_Vars+1; i++){
				// state[i] = StateVariables[i];
				state[i] = StateVariables.second[i];
			}
			// state[Num_Cell_Vars+1] = Integral_Iion;
			// state[Num_Cell_Vars+1] = Integral_Iion.second;

			// state[Num_Cell_Vars+2] = MyLastT;

			// state[Num_Cell_Vars+3] = MydVmdt;
			// state[Num_Cell_Vars+3] = MydVmdt.second;
			state[Num_Cell_Vars+1] = MydVmdt.second;
		}

		void save_state_to_vector(Vector<double>& state, const bool &use_node_vm)
		{
			// state.resize(Num_Cell_Vars+1+1+1+1);
			state.resize(Num_Cell_Vars+1+1);
			for(unsigned i=0; i<Num_Cell_Vars+1; i++){
				// state[i] = StateVariables[i];
				state[i] = StateVariables.second[i];
			}
			if(use_node_vm)
			{
				state[Num_Cell_Vars] = get_base_node_membrane_potential();
			}

			// state[Num_Cell_Vars+1] = Integral_Iion;
			// state[Num_Cell_Vars+1] = Integral_Iion.second;

			// state[Num_Cell_Vars+2] = MyLastT;

			// state[Num_Cell_Vars+3] = MydVmdt;
			// state[Num_Cell_Vars+3] = MydVmdt.second;
			state[Num_Cell_Vars+1] = MydVmdt.second;
		}

		void restore_state_from_vector(Vector<double>& state, const bool& also_set_nodal_value = false)
		{
			for(unsigned i=0; i<Num_Cell_Vars+1; i++){
				// StateVariables[i] = state[i];
				// StateVariables.first[i] = state[i];
				// StateVariables.second[i] = StateVariables.first[i];
				StateVariables.second[i] = state[i];
			}
			
			if(also_set_nodal_value)
			{
				update_underlying_node_membrane_potential();
			}

			// Integral_Iion = state[Num_Cell_Vars+1];
			// Integral_Iion.first = state[Num_Cell_Vars+1];
			// Integral_Iion.second = Integral_Iion.first;
			// Integral_Iion.second = state[Num_Cell_Vars+1];

			// MyLastT = state[Num_Cell_Vars+2];

			// MydVmdt = state[Num_Cell_Vars+3];
			// MydVmdt.first = state[Num_Cell_Vars+3];
			// MydVmdt.second = MydVmdt.first;
			// MydVmdt.second = state[Num_Cell_Vars+3];
			MydVmdt.second = state[Num_Cell_Vars+1];
		}

		//Same as above with std vectors
		void save_state_to_vector(std::vector<double>& state)
		{
			// state.resize(Num_Cell_Vars+1+1+1+1);
			state.resize(Num_Cell_Vars+1+1);
			for(unsigned i=0; i<Num_Cell_Vars+1; i++){
				// state[i] = StateVariables[i];
				state[i] = StateVariables.second[i];
			}
			// state[Num_Cell_Vars+1] = Integral_Iion;
			// state[Num_Cell_Vars+1] = Integral_Iion.second;

			// state[Num_Cell_Vars+2] = MyLastT;

			// state[Num_Cell_Vars+3] = MydVmdt;
			// state[Num_Cell_Vars+3] = MydVmdt.second;
			state[Num_Cell_Vars+1] = MydVmdt.second;
		}


		void restore_state_from_vector(std::vector<double>& state, const bool& also_set_nodal_value = false)
		{
			for(unsigned i=0; i<Num_Cell_Vars+1; i++){
				// StateVariables[i] = state[i];
				// StateVariables.first[i] = state[i];
				StateVariables.second[i] = state[i];
			}
				
			if(also_set_nodal_value)
			{
				update_underlying_node_membrane_potential();
			}

			// Integral_Iion = state[Num_Cell_Vars+1];
			// Integral_Iion.first = state[Num_Cell_Vars+1];
			// Integral_Iion.second = Integral_Iion.first;
			// Integral_Iion.second = state[Num_Cell_Vars+1];
			// Integral_Iion.second = Integral_Iion.first;

			// MyLastT = state[Num_Cell_Vars+2];

			// MydVmdt = state[Num_Cell_Vars+3];
			// MydVmdt.first = state[Num_Cell_Vars+3];
			// MydVmdt.second = MydVmdt.first;
			// MydVmdt.second = state[Num_Cell_Vars+3];
			MydVmdt.second = state[Num_Cell_Vars+1];
		}

	protected:
		//The vectors of variable names, these need to be assigned at construction of the cell model.
		//	these are used for the headers of output files
		std::vector<std::string> Names_Of_Cell_Variables;
		std::vector<std::string> Names_Of_Other_Parameters;
		std::vector<std::string> Names_Of_Other_Variables;
		std::vector<std::string> Names_Of_Output_Data;

		//The number of variables, these avoid unnecessary overhead by constantly calling Names_Of_Cell_Variables.size() etc
		//	They are set automatically by the following function which must be called by the user at the end of their cell
		//	class
		unsigned Num_Cell_Vars;
		unsigned Num_Other_Params;
		unsigned Num_Other_Vars;
		unsigned Num_Output_Data;

		void FinalizeConstruction()
		{
			Num_Cell_Vars = 	Names_Of_Cell_Variables.size();
			Num_Other_Params = 	Names_Of_Other_Parameters.size();
			Num_Other_Vars = 	Names_Of_Other_Variables.size();
			Num_Output_Data = 	Names_Of_Output_Data.size();

			// oomph_info << "Num_Cell_Vars " << Num_Cell_Vars << std::endl;
			

			//Allocate storage for the cell variables
			// StateVariables.resize(Num_Cell_Vars+1, 0.0);

			StateVariables.first.resize(Num_Cell_Vars+1, 0.0);
			StateVariables.second.resize(Num_Cell_Vars+1, 0.0);

			Other_Parameters.resize(Num_Other_Params, 0.0);
			Output_Data.resize(Num_Output_Data, 0.0);

			// oomph_info << "StateVariables.first " << StateVariables.first.size() << std::endl;
			// oomph_info << "StateVariables.second " << StateVariables.second.size() << std::endl;
		}

		int active_strain_index;

		double dt_rushlarsen;

		std::string Cell_Model_Name;

	private:

		double Last_Used_Dt;

		bool SingleCellUseBoostSolve;

		// unsigned BoostSolverMethod;


		double Target_Solve_Error;

		CellModelBaseFullySegregated* Non_this_pointer;

		//The value of time we have most recently solved up to
		// double MyLastT;

		//The value this cell believes the membrane potential to be, since we are using segregated solvers this is a
		//	prediction given by solving the cell equations full decoupled from the diffusion
		// double MyVm;

		// double Integral_Iion;

		// double MydVmdt;

		// Boost_State_Type StateVariables;


		// std::pair<double,double> Integral_Iion;

		std::pair<double,double> MydVmdt;

		std::pair<Boost_State_Type, Boost_State_Type> StateVariables;



		//Other parameters that define the general behaviour of this cell, e.g. apico-basal ratio
		Vector<double> Other_Parameters;

		//Other variables generated by the cell model which might be needed by external elements
		Vector<double> Output_Data;

		//Cell type
		unsigned Cell_Type;

		//We also store an element we live in and coordinates
		
		//For the other variables and the stimulus source
		ConductingCellFunctionsBase* Base_Cell_Sources_Pt;

		//Base node this cell is attached to
		Node* Base_Node_Pt;

		//Index in the base node at which vm is stored.
		unsigned Base_Node_Index_of_Vm;

		//Location data for filling arguments of source functions
		unsigned Ipt;
		Vector<double> S;
		Vector<double> X;
		unsigned L;

	};


}

#endif