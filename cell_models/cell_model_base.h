//LIC// ====================================================================
//LIC// 
//LIC// ====================================================================



#ifndef OOMPH_CELL_MODEL_BASE_FULLY_PARTITIONED_HEADER
#define OOMPH_CELL_MODEL_BASE_FULLY_PARTITIONED_HEADER

// Config header generated by autoconfig
#ifdef HAVE_CONFIG_H
  #include <oomph-lib-config.h>
#endif

//OOMPH-LIB includes
#include "../generic/nodes.h"
#include "../generic/oomph_utilities.h"
#include "../generic/matrices.h"
#include "../generic/Qelements.h"
#include "../generic/Telements.h"

// #include "../toms_utilities/toms_explicit_timestepping_methods.h"

#include <boost/numeric/odeint.hpp>

#include <boost/numeric/odeint/stepper/bulirsch_stoer.hpp>
#include <boost/numeric/odeint/stepper/bulirsch_stoer_dense_out.hpp>


#include <cvode/cvode.h>             /* prototypes for CVODE fcts., consts. */
#include <nvector/nvector_serial.h>  /* serial N_Vector types, fcts., macros */
#include <cvode/cvode_dense.h>       /* prototype for CVDense */
#include <cvode/cvode_band.h>        /* prototype for CVBand */
#include <sundials/sundials_dense.h> /* definitions DlsMat DENSE_ELEM */
#include <sundials/sundials_types.h> /* definition of type realtype */
#include <sunlinsol/sunlinsol_dense.h>
#include <sunmatrix/sunmatrix_dense.h>


#include "../cell_membrane_potential/cell_membrane_potential_elements.h"


namespace oomph
{

// namespace cellStorage
// {
// 	//By default we assume the user intends to use strang splitting so we just need 1, the actual values
// 	unsigned Number_Of_Backup_Copies_Of_Cell_Variables = 1;
// }


	namespace CellGlobalParameters
	{
		static double Default_Time_Tolerance = 1e-9;
	}
	
	static std::string  DEFAULT_PARAVIEW_OUTPUT_TYPE_MARKER = "Membrane Potential Only";
	static unsigned 	DEFAULT_PARAVIEW_OUTPUT_TYPE_NSCALAR = 1;

	//This is a base class, from which all elements which 'contain' cells must inherit from. It handles
	// several source terms for the single cell equations and handles the paraview output of the cell
	// variables.
	class ConductingCellFunctionsBase
	{
	public:
		ConductingCellFunctionsBase() : paraview_output_type(DEFAULT_PARAVIEW_OUTPUT_TYPE_MARKER), paraview_nscalar(DEFAULT_PARAVIEW_OUTPUT_TYPE_NSCALAR)
		{}

		~ConductingCellFunctionsBase(){}

		void set_paraview_output_type(const std::string& new_output_type)
		{
			paraview_output_type = new_output_type;
		}

		void default_paraview_output_type()
		{
			paraview_output_type = DEFAULT_PARAVIEW_OUTPUT_TYPE_MARKER;
		}


		void set_paraview_nscalar(const unsigned& new_paraview_nscalar)
		{
			paraview_nscalar = new_paraview_nscalar;
		}

		void default_paraview_nscalar()
		{
			paraview_nscalar = DEFAULT_PARAVIEW_OUTPUT_TYPE_NSCALAR;
		}


		void set_variable_names_broadcast_from_cell_mesh(std::vector<std::string>& new_names)
		{
			Variable_Names_BroadCast_From_Cell_Mesh = new_names;
		}

	protected:
		//Indicates what kind of outputting to do.
		//If this is set to DEFAULT_PARAVIEW_OUTPUT_TYPE_MARKER,
		// then only membrane potential is output.
		//Otherwise, it is assumed that the marker is the cell type for which data is being output
		// and interpolate_cell_variable(const unsigned& i) is called.
		std::string paraview_output_type;
		unsigned paraview_nscalar;
		std::vector<std::string> Variable_Names_BroadCast_From_Cell_Mesh;


	};



	class CellModelBaseFullyPartitioned
	{
	public:

		typedef double (*CellStimulusFctPt) (const unsigned& ipt, const Vector<double>& s, const Vector<double>& x, const double& t);

		CellStimulusFctPt &stim_func_pt() {return Stim_Funct_Pt;}


		//Paraview output stuff
		//Return the i-th paraview output: State, Output
		double get_paraview_output(const unsigned &i)
		{
			if(i<Num_Cell_Vars)
			{
				return (State[0][i]);
			}
			else
			{
				return (Output[0][i-Num_Cell_Vars]);
			}
		}		

	protected:
		/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		//BEGIN functions which need to be overridden by a user


		//Updates State according to the cell model
		virtual void TakeTimestep(const double& dt, const double& t, double* state)
		{
			//Broken by default
			throw OomphLibError("TakeTimestep: This function has not been implemented yet",
				OOMPH_CURRENT_FUNCTION,
				OOMPH_EXCEPTION_LOCATION);
		}


		//Get the v-th variables initial condition
		virtual double get_initial_state_variable(const unsigned &v)
		{
			//Broken by default
			throw OomphLibError("get_initial_state_variable: This function has not been implemented yet",
				OOMPH_CURRENT_FUNCTION,
				OOMPH_EXCEPTION_LOCATION);
		}

		virtual void get_output(double *state, double *out)
		{
			//Broken by default
			throw OomphLibError("get_output: This function has not been implemented yet",
				OOMPH_CURRENT_FUNCTION,
				OOMPH_EXCEPTION_LOCATION);
		}

		virtual unsigned index_of_membrane_potential_in_cell_data()
		{
			//Broken by default
			throw OomphLibError("You have not assigned the index at which membrane potential is stored in your cell model state",
				OOMPH_CURRENT_FUNCTION,
				OOMPH_EXCEPTION_LOCATION);
		}

		virtual double GetActiveStrain(double* state)
		{
			return 0.0;
		}
		
	public:
		virtual std::string get_cell_model_name()
		{
			//Broken by default
			throw OomphLibError("get_cell_model_name this function has not been implemented yet",
				OOMPH_CURRENT_FUNCTION,
				OOMPH_EXCEPTION_LOCATION);
		}

	protected:

		//END functions which need to be overridden by a user
		/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


		//Return the current time for the cell model
		double time()
		{
			return Time[0];
		}


		double get_stimulus(const double& t)
		{
			if(Stim_Funct_Pt==nullptr)
			{
				return 0.0;
			}
			else
			{
				return Stim_Funct_Pt(this->integral_point(), this->local_coord(), this->global_coord(), t);
			}
		}

	public:

		CellModelBaseFullyPartitioned(const unsigned& number_of_backup_values) : Stim_Funct_Pt(0), Time_Tolerance(CellGlobalParameters::Default_Time_Tolerance), Ipt(0), L(0), Base_Node_Pt(0)
		{
			//Set the number of backup values stored for each variable
			Number_Of_Backup_Values = number_of_backup_values;

			//Resize the variable names vectors to zero
			Names_Of_Cell_Variables.resize(0);
			// Names_Of_Other_Parameters.resize(0);
			// Names_Of_Other_Variables.resize(0);
			Names_Of_Output_Data.resize(0);

			//Size all the diffusion tensor and alignment variables and zero it all
			DiffusionTensor.resize(3, 3, 0.0);
			Conductance.resize(3, 0.0);
			CellAlignment.resize(3);
			for(unsigned i=0; i<3; i++)
			{
				CellAlignment[i].resize(3, 0.0);
			}

			S.resize(3, 0.0);
			X.resize(3, 0.0);
		}


		~CellModelBaseFullyPartitioned()
		{
			delete[] State[0];
			delete[] Output[0];

			delete[] State;
			delete[] Output;	
			delete[] Time;

			State = 0;
			Output = 0;
			Time = 0;
		}



		//Take a timestep and update the time-value
		void Take_Time_Step(const double& dt)
		{
			TakeTimestep(dt, Time[0], State[0]);

			Time[0] += dt;

			//Get the output from the cell model and store it
			get_output(State[0], Output[0]);
		}


		double get_active_strain()
		{
			return GetActiveStrain(State[0]);
		}

		//Get membrane potential as calculated by the cell model
		double get_membrane_potential()
		{
			return (State[0][index_of_membrane_potential_in_cell_data()]);
		}

		//Get the i-th cell variable
		double get_cell_variable(const unsigned& i)
		{
			return (State[0][i]);
		}

		//Write the membrane potential to file
		const void output_membrane_potential(std::ostream &outfile){
			outfile << (State[0][index_of_membrane_potential_in_cell_data()]) << " ";
		}

		//Write the coordinate of the cell to file
		const void output_global_coord(std::ostream &outfile){
			const unsigned dim=X.size();
			for(unsigned i=0; i<dim; i++){
				outfile << X[i] << " ";
			}
		}
 	
 		//Write the cell variables to file
		const void output_cell_variables(std::ostream &outfile){
			for(unsigned i=0; i<Num_Cell_Vars; i++){
				outfile << (State[0][i]) << " ";
			}
		}

		//Write the additional output to file
		const void output_additional_data(std::ostream &outfile){
			for(unsigned i=0; i<Num_Output_Data; i++){
				outfile << (Output[0][i]) << " ";
			}
		}

		//Output the names of the cell variables to file
		const void output_names_of_cell_variables(std::ostream &outfile){
			for(unsigned i=0; i<Num_Cell_Vars; i++){
				outfile << Names_Of_Cell_Variables[i] << " ";
			}
		}

		//Output the names of additional cell variables to file
		const void output_names_of_additional_data(std::ostream &outfile){
			for(unsigned i=0; i<Num_Output_Data; i++){
				outfile << Names_Of_Output_Data[i] << " ";
			}
		}

		//The names given to the cell variables, we use this because it's more user friendly,
		// it means a user does not need to also provide the number of cell variables, and they
		// can just call the variables by name rather than worrying about index
		const std::vector<std::string>& names_of_cell_variables() const
		{
			return Names_Of_Cell_Variables;
		}

		//Same as above but for the data the cell model returns for other things to use
		const std::vector<std::string>& names_of_output_data() const 
		{
			return Names_Of_Output_Data;
		}

		//Get the number of cell variables used by the model
		const unsigned get_Num_Cell_Vars() const{
			return Num_Cell_Vars;
		}

		//Get the number of other output variables used by the model
		const unsigned get_Num_Output_Data() const{
			return 	Num_Output_Data;
		}


		//We provide an element and the coordinates within it at which this cell lives.
		//We use this information for suitably interpolating external data for computing the solution
		// to this cell model.
		//This poses a potential problem since solutions to finite element problems are not guaranteed to be
		// continuous and hence the solution within adjacent elements sharing the same node are also not
		// guaranteed to be the same. We get around this problem by assuming we are solving for a continuous
		// variable if it is to be sent to a cell model. This makes sense for things like membrane potential
		// or a concentration.
		void set_my_element_and_coordinate(DimensionlessMembranePotentialEquationsBase* ConductingCellFunctionsBase_Pt,
																				Node* Node_pt,
																				const unsigned& ipt,
																				const Vector<double>& s,
																				const Vector<double>& x,
																				const unsigned& l)
		{
			Base_Element_Pt = ConductingCellFunctionsBase_Pt;

			Base_Node_Pt = Node_pt;

			Ipt = ipt;
			S = s;
			X = x;
			L = l;
		}

		//Some functions to let the cell get external data from the underlying element if it needs to

		const Node* base_node_pt()
		{
			return Base_Node_Pt;
		}

		const unsigned integral_point()
		{
			return Ipt;
		}

		const Vector<double> local_coord()
		{
			return S;
		}

		const Vector<double> global_coord()
		{
			return X;
		}

		const unsigned node_ind()
		{
			return L;
		}


	public:

		//ADD SET LOCATION WITH CHECKS TO ENSURE IT HASN'T ALREADY BEEN SET
		void set_local_coord(const Vector<double>& s)
		{
			if(Base_Node_Pt!=nullptr)
			{
				S = s;
			}
			else
			{
				throw OomphLibError("This cell is assigned to a node, it makes no sense to change its local coordinate",
														OOMPH_CURRENT_FUNCTION,
														OOMPH_EXCEPTION_LOCATION);
			}
		}

		void set_global_coord(const Vector<double>& x)
		{
			if(Base_Node_Pt!=nullptr)
			{
				X = x;
			}
			else
			{
				throw OomphLibError("This cell is assigned to a node, it makes no sense to change its global coordinate",
														OOMPH_CURRENT_FUNCTION,
														OOMPH_EXCEPTION_LOCATION);
			}
		}

		//ADD SET LOCATION WITH CHECKS TO ENSURE IT HASN'T ALREADY BEEN SET
		void get_local_coord(Vector<double>& s)
		{
			if(Base_Node_Pt!=nullptr)
			{
				s = S;
			}
			else
			{
				throw OomphLibError("This cell is assigned to a node, it makes no sense to change its local coordinate",
														OOMPH_CURRENT_FUNCTION,
														OOMPH_EXCEPTION_LOCATION);
			}
		}

		void get_global_coord(Vector<double>& x)
		{
			if(Base_Node_Pt!=nullptr)
			{
				x = X;
			}
			else
			{
				throw OomphLibError("This cell is assigned to a node, it makes no sense to change its global coordinate",
														OOMPH_CURRENT_FUNCTION,
														OOMPH_EXCEPTION_LOCATION);
			}
		}



		//Synchronise the time to the value passed to the function
		// As long simulations progress the value of the cell can change
		// due to roundoff error. This probably won't be an issue but best
		// to be safe??
		void synchronise_time(const double &t)
		{
			Time[0] = t;
		}

		//Set the tolerance for checking if times are consistent
		void set_Time_Tolerance(const double& new_tol)
		{
			Time_Tolerance = new_tol;
		}

		//Returns true if the time of the current solution stored in the cell
		// is the same value as that passed to the function (presumably the problem time)
		bool check_if_time_is_consistent(const double &t)
		{
			#ifdef PARANOID
			if((std::fabs(t-Time[0])>=Time_Tolerance))
			{
				oomph_info << "Checking times " << Time[0] << " and " << t << " as " << std::fabs(t-Time[0]) << std::endl;
			}
			#endif 
			return (std::fabs(t-Time[0])<Time_Tolerance);
		}

		void Store_State_In_Backup(const unsigned& r)
		{
			#ifdef PARANOID
			if(r==0)
			{
				throw OomphLibError("Cell model must not backup to backup 0 since this is the current state",
														OOMPH_CURRENT_FUNCTION,
														OOMPH_EXCEPTION_LOCATION);
			}
			#endif
			for(unsigned i=0; i<Num_Cell_Vars; i++)
			{
				(State[r][i]) = (State[0][i]);				
			}
			for(unsigned i=0; i<Num_Output_Data; i++)
			{
				(Output[r][i]) = (Output[0][i]);
			}
			(Time[r]) = (Time[0]);
		}

		void Restore_State_From_Backup(const unsigned& r)
		{
			#ifdef PARANOID
			if(r==0)
			{
				throw OomphLibError("Cell model cannot restore current state from backup 0 since this is the current state",
														OOMPH_CURRENT_FUNCTION,
														OOMPH_EXCEPTION_LOCATION);
			}
			#endif
			for(unsigned i=0; i<Num_Cell_Vars; i++)
			{
				(State[0][i]) = (State[r][i]);
			}
			for(unsigned i=0; i<Num_Output_Data; i++)
			{
				(Output[0][i]) = (Output[r][i]);
			}
			(Time[0]) = (Time[r]);
		}


		//Virtual so you can change it to whatever you like, by default just take error of membrane potential
		virtual double Get_Error_Wrt_Backup(const unsigned& r)
		{
			// return (State[r][index_of_membrane_potential_in_cell_data()] - State[0][index_of_membrane_potential_in_cell_data()]);
			double candid_err = 0.0;
			double error = 0.0;
			double sk;
			//Loop over the variables
			for(unsigned i=0; i<Num_Cell_Vars; i++)
			{
				//Check if at least one of them has an absolute value greater than zero.
				if(std::fabs(State[r][i])>1e-12 || std::fabs(State[0][i])>1e-12)
				{
					//Calculate the absolute error
					candid_err = (State[r][i] - State[0][i]);
					//The maximum absolute value of the two
					sk = std::max(std::fabs(State[r][i]), std::fabs(State[0][i]));
					//The candidate relative error
					candid_err = candid_err/sk;

					//If the candidate error is larger than the current error then it is the new error
					if(std::fabs(candid_err)>std::fabs(error))
					{
						error = candid_err;
					}
				}
			}
			//Return the computed error
			return error;
		}

		void Assign_Membrane_Potential_From_Underlying_Node()
		{
			(State[0][index_of_membrane_potential_in_cell_data()]) = dynamic_cast<DimensionlessMembranePotentialEquationsBase*>(Base_Element_Pt)->get_nodal_membrane_potential_BaseCellMembranePotential(L);
		}

		void Set_Membrane_Potential_Of_Underlying_Node()
		{
			dynamic_cast<DimensionlessMembranePotentialEquationsBase*>(Base_Element_Pt)->update_nodal_membrane_potential_BaseCellMembranePotential(L, (State[0][index_of_membrane_potential_in_cell_data()]));
		}

		//Assign initial conditions or update the current values of variables
		//When updating the vm of the underlying node this is not done directly
		// but calls a function of the underlying element - this is because
		// the value stored in the underlying node may not actually
		// represent vm.
		void assign_initial_conditions(const double &t=0)
		{
			for(unsigned r=0; r<Number_Of_Backup_Values; r++)
			{
				//Assign all variables to the initial conditions
				for(unsigned i=0; i<Num_Cell_Vars; i++)
				{
					(State[r][i]) = get_initial_state_variable(i);
				}
				(Time[r]) = t;
			}

			//Calculate output
			get_output(State[0], Output[0]);
		}

		void record_data_pre_mpi_reduce(Vector<double>& vect, const unsigned &start_index)
		{
			for(unsigned i=0; i<Num_Cell_Vars; i++)
			{
				vect[start_index + i] = State[0][i];
			}
			for(unsigned i=0; i<Num_Output_Data; i++)
			{
				vect[start_index + Num_Cell_Vars + i] = Output[0][i];
			}
			vect[start_index + Num_Cell_Vars + Num_Output_Data] = Time[0];
		}

		//Used to update values post mpi solve to be consistent with values on other processors
		void update_data_post_mpi_reduce(Vector<double>& vect, const unsigned &start_index)
		{
			for(unsigned i=0; i<Num_Cell_Vars; i++)
			{
				State[0][i] = vect[start_index+i];
			}
			for(unsigned i=0; i<Num_Output_Data; i++)
			{
				Output[0][i] = vect[start_index + Num_Cell_Vars + i];
			}

			Time[0] = vect[start_index + Num_Cell_Vars + Num_Output_Data];
		}


		//Assign the current solution from a linear combination with another backup value
		// This is useful when applying palindromic type adaptive operator schemes
		// where a higher order solution can be achieved through taking such a weighted combination
		//By default simply assumes a convex combination based on the weight 
		//It can be overridden if you want a different function
		virtual void update_data_to_be_linear_combination(const unsigned& r, const double& weight)
		{
			for(unsigned i=0; i<Num_Cell_Vars; i++)
			{
				State[0][i] = (weight*(State[0][i]) + (1.0-weight)*(State[r][i]));
			}
			for(unsigned i=0; i<Num_Output_Data; i++)
			{
				Output[0][i] = (weight*(Output[0][i]) + (1.0-weight)*(Output[r][i]));
			}
		}


		void assign_state_from_vector(std::vector<double> &vect)
		{
			for(unsigned i=0; i<Num_Cell_Vars; i++)
			{
				State[0][i] = vect[i];
			}
		}

		
		//Diffusion tensor stuff
		//We assume the cell is in 3d. This gives enough storage for any (physical) simulation.
		// index 1 is always cartesian x, 2 y, 3 z.

		void set_cell_conductance(const Vector<double>& conductance)
		{
			//Check if it is the correct dimension first
			if(conductance.size() != 3)
			{
				throw OomphLibError("There are not enough dimensions to describe the conductance of the cell, it needs to be 3d",
														OOMPH_CURRENT_FUNCTION,
														OOMPH_EXCEPTION_LOCATION);
			}
			Conductance.resize(3);
			for(unsigned dim=0; dim<3; dim++)
			{
				Conductance[dim] = conductance[dim];
			}
		}

		void set_cell_conductance(const unsigned& vect, const double& val)
		{
			Conductance[vect] = val;
		}

		void set_cell_alignment(const Vector<Vector<double>>& alignment)
		{
			//Check if it is the correct dimension first
			if(alignment.size() != 3)
			{
				throw OomphLibError("There are not enough vectors to describe the alignment of the cell at the node with the given dimension",
														OOMPH_CURRENT_FUNCTION,
														OOMPH_EXCEPTION_LOCATION);
			}

			CellAlignment.resize(3);

			for(unsigned vect=0; vect<3; vect++)
			{
				if(alignment[vect].size() != 3)
				{
					throw OomphLibError("There are not enough dimensions in the vector to describe the alignment of the cell at the node with the given dimension",
															OOMPH_CURRENT_FUNCTION,
															OOMPH_EXCEPTION_LOCATION);
				}
				CellAlignment[vect].resize(3);
				for(unsigned dim=0; dim<3; dim++)
				{
					(CellAlignment[vect])[dim] = (alignment[vect])[dim];
				}
			}
		}

		void set_cell_alignment(const unsigned& vect, const unsigned& dim, const double& val)
		{
			(CellAlignment[vect])[dim] = val;
		}



		void get_cell_alignment(Vector<Vector<double>>& alignment)
		{
			//Fill in the alignment vectors up to how many dimensions they have
			for(unsigned i=0; i<alignment.size(); i++)
			{
				for(unsigned j=0; j<alignment[0].size(); i++)
				{
					(alignment[i])[j] = (CellAlignment[i])[j];
				}
			}
		}

		double get_cell_alignment(const unsigned& vect, const unsigned& dim)
		{
			//Fill in the alignment vectors up to how many dimensions they have
			return (CellAlignment[vect])[dim];
		}

		void calculate_diffusion_tensor()
		{
			const unsigned dim = 3;
			
			DiffusionTensor.resize(dim, dim, 0.0);

			for(unsigned i=0; i<dim; i++)
			{
				for(unsigned j=0; j<dim; j++)
				{
					for(unsigned vect=0; vect<dim; vect++)
					{
						DiffusionTensor(i,j) += Conductance[vect]*(CellAlignment[vect])[i]*(CellAlignment[vect])[j];
					}
				}
			}
		}

		double get_diffusion_tensor(const unsigned& i, const unsigned& j)
		{
			return DiffusionTensor(i,j);
		}

		



	protected:
		//The vectors of variable names, these need to be assigned at construction of the cell model.
		//	these are used for the headers of output files
		std::vector<std::string> Names_Of_Cell_Variables;
		std::vector<std::string> Names_Of_Output_Data;

		//The number of variables, these avoid unnecessary overhead by constantly calling Names_Of_Cell_Variables.size() etc
		//	They are set automatically by the following function which must be called by the user at the end of their cell
		//	class
		unsigned Num_Cell_Vars;
		unsigned Num_Output_Data;

		unsigned Number_Of_Backup_Values;


		void FinalizeConstruction()
		{
			Num_Cell_Vars = 	Names_Of_Cell_Variables.size();
			Num_Output_Data = 	Names_Of_Output_Data.size();



			State = new double*[Number_Of_Backup_Values];
			Output = new double*[Number_Of_Backup_Values];
			Time = new double[Number_Of_Backup_Values];

			//Create the State and ouptut data
			double* state_values = new double[Number_Of_Backup_Values*Num_Cell_Vars];
			double* out_values = new double[Number_Of_Backup_Values*Num_Output_Data];
			// double* time_values = new double[Number_Of_Backup_Values];
	

			//We store the data differently to oomph-lib node. We want the data to be continguous
			// i.e. State[r][0], State[r][1], State[r][2], ... , State[r][n], State[r+1][0]
			//As opposed to oomph:
			//			State[0][t], State[1][t], State[2][t], ... , State[n][t], State[0][t+1]
			//This way State[0] can be passed to the time-stepper as state, then when the user
			// indexes state[i] they get the i-th variable, NOT the i-th backup value
			for(unsigned r=0; r<Number_Of_Backup_Values; r++)
			{
				State[r] = &state_values[r*Num_Cell_Vars];
				Output[r] = &out_values[r*Num_Output_Data];
				// Time[r] = time_values[r];

				//Initialise all values to zero
				for(unsigned i=0; i<Num_Cell_Vars; i++)
				{
					State[r][i] = 0.0;
				}
				for(unsigned i=0; i<Num_Output_Data; i++)
				{
					Output[r][i] = 0.0;
				}
				// Initialise time to zero
				Time[r] = 0.0;
			}
		}

	private:

		CellStimulusFctPt Stim_Funct_Pt;

		Vector<Vector<double>> CellAlignment;

		Vector<double> Conductance;

		DenseMatrix<double> DiffusionTensor;

		double Time_Tolerance;

		//Cell variables and possible backup cell variables for adaptive operator splitting,
		// must be ordered in such a way that State[r][i] gives the i-th variable at backup r
		double** State;

		//Vector of time and backup times, must be ordered in such a way that Time[r] gives
		// the time corresponding to State[r][i]
		double* Time;



		//Other variables generated by the cell model which might be needed by external elements
		// must be ordered in such a way that Output[i][r] gives the i-th variable at backup r
		double** Output;


		//We also store an element we live in and coordinates
		DimensionlessMembranePotentialEquationsBase* Base_Element_Pt;

		//Base node this cell is attached to
		Node* Base_Node_Pt;

		//Location data for filling arguments of source functions
		unsigned Ipt;
		Vector<double> S;
		Vector<double> X;
		unsigned L;

	};

}

#endif