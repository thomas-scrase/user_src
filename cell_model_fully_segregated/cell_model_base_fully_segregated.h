//LIC// ====================================================================
//LIC// Contains the base cell model class along with two simple cell models
//LIC// ZeroCell - purely for testing
//LIC// FitzHighNagumo - an old redundant model also for testing, albeit more
//LIC//		interesting
//LIC// ====================================================================



#ifndef OOMPH_CELL_MODEL_BASE_FULLY_SEGREGATED_HEADER
#define OOMPH_CELL_MODEL_BASE_FULLY_SEGREGATED_HEADER

// Config header generated by autoconfig
#ifdef HAVE_CONFIG_H
  #include <oomph-lib-config.h>
#endif

//OOMPH-LIB includes
#include "../generic/nodes.h"
#include "../generic/oomph_utilities.h"
#include "../generic/matrices.h"
#include "../generic/Qelements.h"
#include "../generic/Telements.h"


#include <boost/numeric/odeint.hpp>


namespace oomph{


	class CellModelBaseFullySegregated
	{
	public:
		CellModelBaseFullySegregated() : active_strain_index(-1)
		{
			//Resize the variable names vectors to zero
			Names_Of_Cell_Variables.resize(0);
			Names_Of_Other_Parameters.resize(0);
			Names_Of_Other_Variables.resize(0);
			Names_Of_Output_Data.resize(0);

			// std::cout << "Names of variables size at base construction " << Names_Of_Cell_Variables.size() << std::endl;
		}
		virtual ~CellModelBaseFullySegregated(){}
		

		/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		//BEGIN functions which need to be overridden by a user

		//Get the v-th variables initial condition for cell_type,
		//	these MUST be written in the same order that you write the Names_Of_Cell_Variables vector entries.
		virtual double return_initial_state_variable(const unsigned &v, const unsigned &cell_type)
		{
			//Broken by default
			throw OomphLibError("return_initial_state_variable: This function has not been implemented yet",
				OOMPH_CURRENT_FUNCTION,
				OOMPH_EXCEPTION_LOCATION);
		}


		//Get the initial membrane potential for the cell_type-th cell type
		virtual double return_initial_membrane_potential(const unsigned &cell_type)
		{
			//Broken by default
			throw OomphLibError("return_initial_membrane_potential: This function has not been implemented yet",
				OOMPH_CURRENT_FUNCTION,
				OOMPH_EXCEPTION_LOCATION);
		}


		//Calculate the derivatives of the cell variables, also calculate the trans membrane current
		//	We provide the membrane current, the contemporary cell variable valyues, the time (just in case)
		//	the timestep (for rush larson methods), the cell type,
		//	other parameters (which represets time independent variables, e.g. a drug concentration or ion channel blockade),
		//	other variables (generally time dependent variables, e.g. strain in the tissue)
		//
		//	The function is to calculate the time derivatives of the cell variables, and populate the Variable_Derivatives,
		//	 the user must use the same keyword names as the variable, e.g. CellVariables[sxs], Variable_Derivatives[sxs] = (...)
		//	The user also provides the Iion which is the total transmembrane ionic current, which must be in pA/pF, i.e. current per capacitance
		//	 this way the membrane capacitance doesn't need to be passed to any other methods and the computations are neater.
		virtual void Calculate_Derivatives(const double &Vm,
											const Vector<double> &CellVariables,
											const double &t,
											const unsigned &cell_type,
											const double &Istim,
											const Vector<double> &Other_Parameters,
											const Vector<double> &Other_Variables,

											Vector<double> &Variable_Derivatives,
											double &Iion)
		{
			//Broken by default
			throw OomphLibError("Calculate_Derivatives: This function has not been implemented yet",
				OOMPH_CURRENT_FUNCTION,
				OOMPH_EXCEPTION_LOCATION);
		}


		//Generate an unordered map of data required by things outside of the cell model, this could be
		//	active strain, or perhaps ion channel currents, or ionic species concentrations, we want to keep track of
		virtual void get_optional_output(const double &Vm,
									const Vector<double> &CellVariables,
									const double &t,
									const unsigned &cell_type,
									const double &Istim,
									const Vector<double> &Other_Parameters,
									const Vector<double> &Other_Variables,
									Vector<double> &Out) const
		{
			//Broken by default
			throw OomphLibError("get_optional_output: This function has not been implemented yet",
				OOMPH_CURRENT_FUNCTION,
				OOMPH_EXCEPTION_LOCATION);
		}

		//END functions which need to be overridden by a user
		/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


		double get_predicted_vm() const
		{
			return MyVm;
		}

		double get_cell_variable(const unsigned& i)
		{
			return Cell_Variables[i];
		}

		double get_active_strain() const
		{
			#ifdef PARANOID
			// oomph_info << "In fct which should die" << std::endl;
			//If the user has failed to specify at which index the active strain is stored at then we throw an error 
			if(active_strain_index<0){
				throw OomphLibError("You appear to be attempting to access active strain stored in a cell element\nbut you haven't set the index at which it is stored. Please make sure that you override\nget_index_of_active_strain() to return the correct index you have stored it at.",
			                       	OOMPH_CURRENT_FUNCTION,
			                       	OOMPH_EXCEPTION_LOCATION);
			}
			#endif
			return Output_Data[active_strain_index];
		}

		void set_cell_type(const unsigned &cell_type){
			Cell_Type = cell_type;
		}

		void set_other_data(const unsigned &var, const double &value){
			Other_Parameters[var] = value;
		}






		//The names given to the cell variables, we use this because it's more user friendly,
		// it means a user does not need to also provide the number of cell variables, and they
		// can just call the variables by name rather than worrying about index
		const std::vector<std::string>& names_of_cell_variables() const
		{
			return Names_Of_Cell_Variables;
		}

		//The names of the other parameters passed to the function, we provide this for error checking,
		//	if the library is built with PARANOID then we can automatically check to ensure that the
		//	user is correctly creating the other parameters data.
		const std::vector<std::string>& names_of_other_parameters() const
		{
			return Names_Of_Other_Parameters;
		}

		//Same as above but for other variables which are in general time dependent.
		const std::vector<std::string>& names_of_other_variables() const
		{
			return Names_Of_Other_Variables;
		}

		//Same as above but for the data the cell model returns for other things to use
		const std::vector<std::string>& names_of_output_data() const 
		{
			return Names_Of_Output_Data;
		}


		const unsigned get_Num_Cell_Vars() const{
			return Num_Cell_Vars;
		}
		const unsigned get_Num_Other_Params() const{
			return 	Num_Other_Params;
		}
		const unsigned get_Num_Other_Vars() const{
			return 	Num_Other_Vars;
		}
		const unsigned get_Num_Output_Data() const{
			return 	Num_Output_Data;
		}


		//We provide an element and the coordinates within it at which this cell lives.
		//We use this information for suitably interpolating external data for computing the solution
		// to this cell model.
		//This poses a potential problem since solutions to finite element problems are not guaranteed to be
		// continuous and hence the solution within adjacent elements sharing the same node are also not
		// guaranteed to be the same. We get around this problem by assuming we are solving for a continuous
		// variable if it is to be sent to a cell model. This makes sense for things like membrane potential
		// or a concentration.
		void set_my_element_and_coordinate(ConductingCellFunctionsBase* ConductingCellFunctionsBase_Pt,
											Node* Node_pt,
											const unsigned Index_of_Vm,
											const unsigned &ipt,
											const Vector<double> &s,
											const Vector<double> &x,
											const unsigned &l)
		{
			Base_Cell_Sources_Pt = ConductingCellFunctionsBase_Pt;

			Base_Node_Pt = Node_pt;

			Base_Node_Index_of_Vm = Index_of_Vm;

			Ipt = ipt;
			S = s;
			X = x;
			L = l;
		}


		//The function used by boost when solving the cell model
		void operator() ( const Boost_State_Type &x , Boost_State_Type &dxdt , const double t )
		{
			//Things used throughout the computation
			const double boost_Vm = x[Num_Cell_Vars];
			double boost_Iion = 0.0;
			Vector<double> boost_Cell_Variables(Num_Cell_Vars, 0.0);
			vector<double> boost_Variable_Derivatives(Num_Cell_Vars, 0.0);
			for(unsigned i=0; i<Num_Cell_Variables; i++){
				boost_Cell_Variables[i] = x[i];
				boost_Variable_Derivatives[i] = 0.0;
			}
			double boost_Other_Variables(Num_Cell_Vars, 0.0);

			const double stimulus_current = (Base_Cell_Sources_Pt->get_stimulus)(Ipt, S, X, t);

			(Base_Cell_Sources_Pt->get_other_variables)(Ipt, S, X, L, t, boost_Other_Variables);

			get_derivatives(boost_Vm,
							boost_Cell_Variables,
							t,
							Cell_Type,
							stimulus_current,
							Other_Parameters,
							boost_Other_Variables,
							boost_Variable_Derivatives,
							boost_Iion);

			//Fill in the derivatives to be sent back to the boost solver
			dxdt[Num_Cell_Variables] = boost_Iion;
			for(unsigned i=0; i<Num_Cell_Variables; i++){
				dxdt[i] = boost_Variable_Derivatives[i];
			}
		}


		void TakeTimestep(const double &t, const double& dt, const bool &use_node_vm_as_initial_value = false){
			//preallocate memory for the new variable values
			Vector<double> New_Variables(Num_Cell_Vars, 0.0);
			for(unsigned it = 0; it < Num_Cell_Vars; it++){
				New_Variables[it] = 0.0;
			}
			//Allocate memory for New_Vm
			double New_Vm = 0.0;

			//Fill in the current Vm and variable values
			Boost_State_Type x(Num_Cell_Vars+1, 0.0);
			//Fill in membrane potential
			if(use_node_vm_as_initial_value){x[Num_Cell_Vars] = Base_Node_Pt->value(Base_Node_Index_of_Vm);}
			else{x[Num_Cell_Vars] = MyVm;}
			//Fill in cell variables
			for(unsigned i=0; i<Num_Cell_Vars; i++){
				x[i] = Variables[i];
			}

			//Call the adaptive boost solver over the specified range, t to t+dt
			integrate_adaptive( boost::numeric::odeint::make_controlled<controlled_error_stepper_type>(1.0e-10, 1.0e-6),
									this, x, t, t+dt, dt);

			//Unpack the data from the boost solve
			MyVm = x[Num_Cell_Vars];
			for(unsigned i=0; i<Num_Cell_Vars; i++){
				Variables[i] = x[i];
			}
		}


		void assign_initial_conditions(){
			//Assign initial conditions from the cell model
			//Cell variables
			for(unsigned i=0; i<Num_Cell_Vars; i++){
				Cell_Variables[i] = return_initial_state_variable(i, Cell_Type);
			}
			//Membrane potential
			MyVm = return_initial_membrane_potential(Cell_Type);
		}

		void assign_initial_conditions(const Vector<double>& vals, const double& vm){
			//Assign initial conditions from the cell model
			//Cell variables
			for(unsigned i=0; i<Num_Cell_Vars; i++){
				Cell_Variables[i] = vals[i];
			}
			//Membrane potential
			MyVm = vm;
		}

	protected:
		//The vectors of variable names, these need to be assigned at construction of the cell model.
		//	these are used for the headers of output files
		std::vector<std::string> Names_Of_Cell_Variables;
		std::vector<std::string> Names_Of_Other_Parameters;
		std::vector<std::string> Names_Of_Other_Variables;
		std::vector<std::string> Names_Of_Output_Data;

		//The number of variables, these avoid unnecessary overhead by constantly calling Names_Of_Cell_Variables.size() etc
		//	They are set automatically by the following function which must be called by the user at the end of their cell
		//	class
		unsigned Num_Cell_Vars;
		unsigned Num_Other_Params;
		unsigned Num_Other_Vars;
		unsigned Num_Output_Data;

		void FinalizeConstruction()
		{
			Num_Cell_Vars = 	Names_Of_Cell_Variables.size();
			Num_Other_Params = 	Names_Of_Other_Parameters.size();
			Num_Other_Vars = 	Names_Of_Other_Variables.size();
			Num_Output_Data = 	Names_Of_Output_Data.size();

			// std::cout << Num_Cell_Vars << std::endl;
			// std::cout << Num_Other_Params << std::endl;
			// std::cout << Num_Other_Vars << std::endl;
			// std::cout << Num_Output_Data << std::endl;

			//Allocate storage for the cell variables
			Cell_Variables.resize(Num_Cell_Vars, 0.0);
			//Allocate storage for the other parameters
			Other_Parameters.resize(Num_Other_Params, 0.0);
		}

		int active_strain_index;

	private:

		//The value this cell believes the membrane potential to be, since we are using segregated solvers this is a
		//	prediction given by solving the cell equations full decoupled from the diffusion
		double MyVm;

		//The variables we solve for when solving the cell model
		Vector<double> Cell_Variables;

		//Other parameters that define the general behaviour of this cell, e.g. apico-basal ratio
		Vector<double> Other_Parameters;

		//Other variables generated by the cell model which might be needed by external elements
		Vector<double> Output_Data;

		//Cell type
		unsigned Cell_Type;

		//We also store an element we live in and coordinates
		
		//For the other variables and the stimulus source
		ConductingCellFunctionsBase* Base_Cell_Sources_Pt;

		//Base node this cell is attached to
		Node* Base_Node_Pt;

		//Index in the base node at which vm is stored.
		unsigned Base_Node_Index_of_Vm;

		//Location data for filling arguments of source functions
		unsigned Ipt;
		Vector<double> S;
		Vector<double> X;
		unsigned L;

	};


}

#endif