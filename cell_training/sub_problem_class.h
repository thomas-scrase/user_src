//LIC/////////////////////////////////////////////////////////////////// 
//LIC// The sub problem class, used in training cell models.
//LIC// Sub problems are ownewd by a meta problem. A sub problem can
//LIC//  perform any simulation required but must inherit from this class.
//LIC// A sub problem is required to run it's simulation when the function
//LIC//  "run" is called. This function must return a double, generally
//LIC//  describing the discrepency between the simulation just computed
//LIC//  and the experiment it is intended to replicate.
//LIC///////////////////////////////////////////////////////////////////

#ifndef OOMPH_SUB_PROBLEM_HEADER
#define OOMPH_SUB_PROBLEM_HEADER

// Config header generated by autoconfig
#ifdef HAVE_CONFIG_H
	#include <oomph-lib-config.h>
#endif


#include "../generic/problem.h"

#include "trainable_element.h"


namespace oomph{
	class SubProblem	:	public Problem
	{
	public:
		SubProblem(){	}
		~SubProblem(){	}

		//Perform the simulation the problem is designed to do,
		// compare result to experimental_data and return
		// comparrison
		virtual double run(){
			throw OomphLibError("run has not been implemented for sub problem yet\nYour implementation must ensure the problem is reset completely before beign re-run.\nIt is also stressed that find_all_trainable_elements() should be called for this element before\nthe coordinator problem locates all dependent elements",
								OOMPH_CURRENT_FUNCTION,
								OOMPH_EXCEPTION_LOCATION);
		}

		//return a vector of pointers to elements within this problem with the trainable element
		void get_all_trainable_elements(Vector<TrainableElement*> &trainable_elements){
				
			//add all non-global mesh trainable elements to the vector
			for(unsigned i=0; i<Problem_Trainable_Elements.size(); i++){
				trainable_elements.push_back(Problem_Trainable_Elements[i]);
			}

			//get the trainable elements from the global mesh
			Vector<TrainableElement*> trainable_elements_from_global_mesh;
			find_all_trainable_elements_in_global_mesh(trainable_elements_from_global_mesh);
			for(unsigned i=0; i<trainable_elements_from_global_mesh.size(); i++){
				trainable_elements.push_back(trainable_elements_from_global_mesh[i]);
			}
		}

		//an access function to the Directory_String, used for setting
		void set_directory(const std::string &new_directory){Directory_String=new_directory;}

	protected:

		void add_trainable_element(TrainableElement* candidate_element_pt){
			Problem_Trainable_Elements.push_back(candidate_element_pt);
		}
		
		//A string, intended for use as the directory data from each run is to be stored at
		std::string Directory_String;

	private:

		//a helper function intended to be used within find_all_trainable_elements() to
		//	automatically get all trainable elements found inside the global mesh
		void find_all_trainable_elements_in_global_mesh(Vector<TrainableElement*> &trainable_elements_from_global_mesh){
			//get the global mesh
			Mesh* mesh_pt = this->mesh_pt();
			//if there is no global mesh then return
			if(mesh_pt==NULL){return;}
			//get the number of elements in the mesh
			unsigned n_element = mesh_pt->nelement();
			//loop over them
			for(unsigned e=0; e<n_element; e++){
				//attempt to cast the element to a trainable element
				TrainableElement* candidate_element_pt = dynamic_cast<TrainableElement*>(mesh_pt->element_pt(e));
				//if the cast was successfull
				if(candidate_element_pt!=NULL){
					trainable_elements_from_global_mesh.push_back(candidate_element_pt);
				}
			}
		}

		//all trainable elemnts which are not in the global mesh
		Vector<TrainableElement*> Problem_Trainable_Elements;		
	};

}//end namespace

#endif