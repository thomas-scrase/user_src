#ifndef OOMPH_META_PROBLEM_HEADER
#define OOMPH_META_PROBLEM_HEADER

// Config header generated by autoconfig
#ifdef HAVE_CONFIG_H
	#include <oomph-lib-config.h>
#endif

#include "../generic/problem.h"
#include "../meshes/one_d_mesh.h"

#include "../cell_model/cell_model.h"
#include "trainable_cell_class.h"

#include "sub_problem_class.h"

#include "optimisation_elements.h"

namespace oomph{
	//Uses oomph lib residual and jacobian fill in to optimise the cell parameters
	//	Benefits from improved convergence
	//	Drawbacks that problem is easy to make singular
	class JacobianMetaProblem : public Problem
	{
	public:
		JacobianMetaProblem(){
			//Make our one and only optimisation mesh
			OptimisationMeshPt = new OneDMesh<QOptimisationElement>(1,1.0);
		}

		~JacobianMetaProblem(){
			delete OptimisationMeshPt;
			//delete the sub problems
			for(unsigned i=0; i<Number_Of_Sub_Problems; i++){
				delete Sub_Problem_Pts[i];
			}
		}

		void setup_optimisation(const unsigned &n_values);

		//Communicator with the optimisation element
		void communicate_sub_problem_error_to_optimisation_element(Vector<double> &residual);

		//Add a sub problem 
		void add_sub_problem_pt(SubProblem* sub_prob_pt);

		//Assign cell model pt to sub problems
		void pass_cell_model_pt_to_sub_problems();

		//Actions before newton solve
		void actions_before_newton_solve();

		OptimisationEquations* optimisation_equation_pt(){return dynamic_cast<OptimisationEquations*>(OptimisationMeshPt->element_pt(0));}

		//return a const pointer to our private cell model
		CellModelBase* cell_model_pt() const {return Cell_Model_Pt;}

		//return a non-const pointer to our private cell model (i.e. for setting it)
		CellModelBase* cell_model_pt() {return Cell_Model_Pt;}

		//send inform the optimisation elements if and how to calculate the cost due to
		//	variables lying outside of a range
		//Flag, add range of Internal_Data_Pt values to the residual
		void send_add_internal_data_range_to_optimisation_elements();
		//The Mean of the internal data
		void send_internal_data_mean_to_optimisation_elements();
		//The permitted range aroung the mean value
		void send_internal_data_percentage_range_to_optimisation_elements();

	protected:
		//Our one and only optimisation mesh
		OneDMesh<QOptimisationElement>* OptimisationMeshPt;

	private:

		unsigned N_Variables;

		Vector<SubProblem*> Sub_Problem_Pts;

		unsigned Number_Of_Sub_Problems;

		Vector<double> Sub_Problem_Error;

		CellModelBase* Cell_Model_Pt;


		//inform the optimisation elements if and how to calculate the cost due to
		//	variables lying outside of a range
		//Flag, add range of Internal_Data_Pt values to the residual
		std::vector<bool> Add_Internal_Data_Range;
		//The Mean of the internal data
		Vector<double> Internal_Data_Mean;
		//The permitted range aroung the mean value
		Vector<double> Internal_Data_Percentage_Range;
	};







	//Uses the Nelder mead simplex algorithm to optimise cell parameters
	//	Benefits from improved efficiency
	//	Drawbacks: does not use oomph lib problem class so cannot use
	//		automatic convergence checking and error checks etc
	class NelderMeadMetaProblemClass
	{
	public:

		NelderMeadMetaProblemClass(){}

		~NelderMeadMetaProblemClass();

		//Setup the simplex, construct n+1 optimisation equations each with n internal data
		void setup_optimisation(const unsigned &n_values);

		//Add a sub problem 
		void add_sub_problem_pt(SubProblem* sub_prob_pt);

		//Assign cell model pt to sub problems
		void pass_cell_model_pt_to_sub_problems();

		//return a const pointer to our private cell model
		CellModelBase* cell_model_pt() const {return Cell_Model_Pt;}

		//return a non-const pointer to our private cell model (i.e. for setting it)
		CellModelBase* cell_model_pt() {return Cell_Model_Pt;}

		//send inform the optimisation elements if and how to calculate the cost due to
		//	variables lying outside of a range
		//Flag, add range of Internal_Data_Pt values to the residual
		void send_add_internal_data_range_to_optimisation_elements();
		//The Mean of the internal data
		void send_internal_data_mean_to_optimisation_elements();
		//The permitted range aroung the mean value
		void send_internal_data_percentage_range_to_optimisation_elements();

	protected:


	private:

		//run the nelder-mead simplex algorithm until convergence
		void run_algorithm();

		//perform one iteration of the nelder mead simplex algorithm
		//void perform_nelder_mead_simplex_iteration(double& total_error);

		void evaluate_quality_of_simplex(Vector<double>& node_qualities);

		void evaluate_quality_of_node(OptimisationEquations &node, double &quality);

		//determines if program should terminate or not, also records error of current step
		virtual bool terminate(Vector<double> &node_qualities, Vector<double> &error_time_series);

		virtual double error_from_node_qualities(Vector<double> &node_qualities);

		void sort_nodes(const Vector<double> &node_qualities, Vector<unsigned> &sorted_node_indexes);

		void fill_in_x0(OptimisationEquations &node, Vector<unsigned> &sorted_node_indexes);
		void fill_in_xr(OptimisationEquations &node, OptimisationEquations &x0, OptimisationEquations &xnp1);
		void fill_in_xe(OptimisationEquations &node, OptimisationEquations &x0, OptimisationEquations &xr);
		void fill_in_xc(OptimisationEquations &node, OptimisationEquations &x0, OptimisationEquations &xnp1);

		void shrink_node(OptimisationEquations &node, OptimisationEquations &x0);
		void replace_node(OptimisationEquations &node, OptimisationEquations &replacement_node);


		//Optimisation equations used as a container for each node of the simplex
		//	used so that only one extra cell model base is needed
		unsigned N_Variables;

		Vector<OptimisationEquations*> Simplex_nodes;

		Vector<SubProblem*> Sub_Problem_Pts;

		unsigned Number_Of_Sub_Problems;

		Vector<double> Sub_Problem_Error;

		CellModelBase* Cell_Model_Pt;


		//Parameters for operation of the simplex algorithm
		double alpha = 1.0;
		double gamma = 2.0;
		double rho = 0.5;
		double sigma = 0.5;


		//inform the optimisation elements if and how to calculate the cost due to
		//	variables lying outside of a range
		//Flag, add range of Internal_Data_Pt values to the residual
		std::vector<bool> Add_Internal_Data_Range;
		//The Mean of the internal data
		Vector<double> Internal_Data_Mean;
		//The permitted range aroung the mean value
		Vector<double> Internal_Data_Percentage_Range;
	};

}//end namespace


#endif