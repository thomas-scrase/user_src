#ifndef OOMPH_META_PROBLEM_HEADER
#define OOMPH_META_PROBLEM_HEADER

// Config header generated by autoconfig
#ifdef HAVE_CONFIG_H
	#include <oomph-lib-config.h>
#endif

#ifdef OOMPH_HAS_MPI
//mpi headers
#include "mpi.h"
#endif

//includes for making directories
#include <iostream>
#include <stdio.h>
// #include <io.h>

#include "../generic/problem.h"
#include "../meshes/one_d_mesh.h"

#include "trainable_element.h"

#include "sub_problem_class.h"

//MetaProblemBase is in here
#include "optimisation_elements.h"

//for sorting vector by index
#include <numeric>
#include <algorithm>

namespace oomph{

	//JacobianMetaProblem is broken, will probably be removed shortly

	//Uses oomph lib residual and jacobian fill in to optimise the cell parameters
	//	Benefits from improved convergence
	//	Drawbacks that problem is easy to make singular
	// class JacobianMetaProblem : public Problem
	// {
	// public:
	// 	JacobianMetaProblem(){
	// 		//Make our one and only optimisation mesh
	// 		OptimisationMeshPt = new OneDMesh<QOptimisationElement>(1,1.0);
	// 		//create the meta problem directory
	// 		current_iter=0;
	// 		Number_Of_Sub_Problems = 0;
	// 	}

	// 	~JacobianMetaProblem(){
	// 		delete OptimisationMeshPt;
	// 		//delete the sub problems
	// 		for(unsigned i=0; i<Number_Of_Sub_Problems; i++){
	// 			delete Sub_Problem_Pts[i];
	// 		}
	// 	}

	// 	void setup_optimisation(const unsigned &n_values);

	// 	//Communicator with the optimisation element
	// 	void communicate_sub_problem_error_to_optimisation_element(Vector<double> &residual);

	// 	//Add a sub problem 
	// 	void add_sub_problem_pt(SubProblem* sub_prob_pt);

	// 	//Assign cell model pt to sub problems
	// 	void pass_cell_model_pt_to_sub_problems();

	// 	//Actions before newton solve
	// 	void actions_before_newton_solve();

	// 	//After a solve we want to record the current variables and performance etc so we do that
	// 	void actions_after_newton_solve();

	// 	OptimisationEquations* optimisation_equation_pt(){return dynamic_cast<OptimisationEquations*>(OptimisationMeshPt->element_pt(0));}


	// protected:

	// private:

	// 	//add dependent element
	// 	void add_trainable_element_as_dependent(TrainableElement* dependent_element);

	// 	//add all trainable elements from a particular problem as dependent elements
	// 	void add_all_trainable_elements_as_dependents(Problem* problem_pt);		

	// 	//send a particular optimisation element to all dependent trainable elements
	// 	void push_optimisation_element_to_dependent_elements(OptimisationEquations &node);


	// 	//Our one and only optimisation mesh
	// 	OneDMesh<QOptimisationElement>* OptimisationMeshPt;

	// 	unsigned current_iter;

	// 	unsigned N_Variables;

	// 	Vector<SubProblem*> Sub_Problem_Pts;

	// 	unsigned Number_Of_Sub_Problems;

	// 	Vector<double> Sub_Problem_Error;

	// 	Vector<TrainableElement*> Dependent_Elements;
	// };







	//Uses the Nelder mead simplex algorithm to optimise cell parameters
	//	Benefits from improved efficiency
	//	Drawbacks: does not use oomph lib problem class so cannot use
	//		automatic convergence checking and error checks etc
	class NelderMeadMetaProblemClass : public Problem,
									public MetaProblemBase
	{
	public:

		NelderMeadMetaProblemClass(){
			Number_Of_Sub_Problems = 0;
			Acceptable_Edge_Length = Default_Acceptable_Edge_Length;
		}

		~NelderMeadMetaProblemClass();

		//Setup the simplex, construct n+1 optimisation equations each with n internal data
		void setup_optimisation(const unsigned &n_values);

		virtual void set_initial_simplex(const Vector<double>& min_values, const Vector<double>& max_values);

		//run the nelder-mead simplex algorithm until convergence
		void run_algorithm(std::ostream &outfile);

		//run the algorithm with probabilistic restarts
		void run_algorithm_with_restarts(std::ostream &outfile);

		//Add a sub problem 
		void add_sub_problem_pt(SubProblem* sub_prob_pt);

		//report on the nodes
		void output(const unsigned &iteration, Vector<double> &Node_Qualities, std::ostream &outfile);

		double n_variables() const {return N_Variables;}

		void get_sub_problem_contribution_to_node(OptimisationEquations &node, Vector<double> &contribution);

		//get the cost incurred by the values of the variables in the optimisation element passed
		//used as VariableValuesContribution for the optimisation elements
		virtual void get_cost_of_variables(OptimisationEquations &optimisation_equations, Vector<double> &costs);

		//set the acceptable length the largest edge of the simplex can have
		void set_acceptable_edge_length(const double &new_acceptable_edge_length){Acceptable_Edge_Length = new_acceptable_edge_length;}


	protected:



	private:

		double termination_tolerance(){return Acceptable_Edge_Length;}

		OptimisationEquations* simplex_node(const unsigned &n){return Simplex_nodes[n];}

		//add dependent element
		void add_trainable_element_as_dependent(TrainableElement* dependent_element);

		//add all trainable elements from all sub problems
		void add_all_trainable_elements_from_sub_problems_as_dependents();	

		//send a particular optimisation element to all dependent trainable elements
		void push_optimisation_element_to_dependent_elements(OptimisationEquations &node);

		void evaluate_quality_of_simplex(Vector<double>& node_qualities);

		void evaluate_quality_of_node(OptimisationEquations &node, double &quality);

		//determines if program should terminate or not, also records error of current step
		virtual bool terminate(Vector<double> &node_qualities);

		virtual double error_from_node_qualities(Vector<double> &node_qualities);

		double simplex_maximum_edge_length();

		void sort_nodes(const Vector<double> &node_qualities, Vector<unsigned> &sorted_node_indexes);

		void fill_in_x0(OptimisationEquations &node, Vector<unsigned> &sorted_node_indexes);
		void fill_in_xr(OptimisationEquations &node, OptimisationEquations &x0, OptimisationEquations &xnp1);
		void fill_in_xe(OptimisationEquations &node, OptimisationEquations &x0, OptimisationEquations &xr);
		void fill_in_xc(OptimisationEquations &node, OptimisationEquations &x0, OptimisationEquations &xnp1);

		void shrink_node(OptimisationEquations &node, OptimisationEquations &x0);
		void replace_node(OptimisationEquations &node, OptimisationEquations &replacement_node);

		//Optimisation equations used as a container for each node of the simplex
		//	used so that only one extra cell model base is needed
		unsigned N_Variables;

		Vector<OptimisationEquations*> Simplex_nodes;

		Vector<SubProblem*> Sub_Problem_Pts;

		unsigned Number_Of_Sub_Problems;

		Vector<double> Sub_Problem_Error;

		Vector<TrainableElement*> Dependent_Elements;

		//Parameters for operation of the simplex algorithm
		double alpha = 1.0;
		double gamma = 2.0;
		double rho = 0.5;
		double sigma = 0.5;

		//The convergence tolerance
		double Acceptable_Edge_Length;
		//And it's default value
		static double Default_Acceptable_Edge_Length;
	};

}//end namespace


#endif