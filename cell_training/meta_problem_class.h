#ifndef OOMPH_META_PROBLEM_HEADER
#define OOMPH_META_PROBLEM_HEADER

// Config header generated by autoconfig
#ifdef HAVE_CONFIG_H
	#include <oomph-lib-config.h>
#endif

//includes for making directories
#include <iostream>
#include <stdio.h>
// #include <io.h>


#include "trainable_element.h"

#include "trainable_problem_class.h"

//for sorting vector by index
#include <numeric>
#include <algorithm>

namespace oomph{
//Uses the Nelder mead simplex algorithm to optimise cell parameters
//	Benefits from improved efficiency
//	Drawbacks: does not use oomph lib problem class so cannot use
//		automatic convergence checking and error checks etc
class NelderMeadOptimisation
{
public:

	NelderMeadOptimisation(){
		Acceptable_Edge_Length = Default_Acceptable_Edge_Length;
	}

	~NelderMeadOptimisation();

	//Setup the simplex, construct n+1 optimisation equations each with n internal data
	void setup_optimisation(const unsigned &n_values);

	void set_simplex_value(const unsigned& node, const unsigned& var, const double& value);

	//run the nelder-mead simplex algorithm until convergence
	void run_algorithm(std::ostream &outfile);

	//Add a trainable problem 
	void add_trainable_problem(TrainableProblem& sub_prob_pt);

	//report on the nodes
	void output(const unsigned &iteration, Vector<double> &Node_Qualities, std::ostream &outfile);

	double n_variables() const {return N_Variables;}

	//set the acceptable length the largest edge of the simplex can have
	void set_acceptable_edge_length(const double &new_acceptable_edge_length){Acceptable_Edge_Length = new_acceptable_edge_length;}


protected:



private:

	double termination_tolerance(){return Acceptable_Edge_Length;}

	//add dependent element
	void add_trainable_element_as_dependent(TrainableElement* dependent_element);

	//add all trainable elements from all trainable problems
	void add_all_trainable_elements_from_trainable_problems_as_dependents();	

	//send a particular optimisation element to all dependent trainable elements
	void push_optimisation_element_to_dependent_elements(Vector<double> &node);

	void evaluate_quality_of_simplex();

	void evaluate_quality_of_node(Vector<double> &node, double &quality);

	double simplex_maximum_edge_length();

	void sort_nodes(Vector<unsigned> &sorted_node_indexes);

	void fill_in_x0(Vector<double> &node, Vector<unsigned> &sorted_node_indexes);
	void fill_in_xr(Vector<double> &node, Vector<double> &x0, Vector<double> &xnp1);
	void fill_in_xe(Vector<double> &node, Vector<double> &x0, Vector<double> &xr);
	void fill_in_xc(Vector<double> &node, Vector<double> &x0, Vector<double> &xnp1);

	void shrink_node(Vector<double> &node, Vector<double> &x0);
	void replace_node(Vector<double> &node, Vector<double> &replacement_node);

	void output(const Vector<double> &x, std::ostream &outfile){
		for(unsigned i=0; i<N_Variables; i++){
			outfile << x[i] << " ";
		}
	}

	//Optimisation equations used as a container for each node of the simplex
	//	used so that only one extra cell model base is needed
	unsigned N_Variables;

	Vector<Vector<double>> Simplex;

	Vector<double> Node_Qualities;

	Vector<TrainableProblem*> Trainable_Problem_Pts;

	Vector<TrainableElement*> Dependent_Elements;

	//Parameters for operation of the simplex algorithm
	double alpha = 1.0;
	double gamma = 2.0;
	double rho = 0.5;
	double sigma = 0.5;

	//The convergence tolerance
	double Acceptable_Edge_Length;
	//And it's default value
	static double Default_Acceptable_Edge_Length;
};

}//end namespace


#endif