#ifndef OOMPH_CELL_PROBE_UTILITIES_HEADER
#define OOMPH_CELL_PROBE_UTILITIES_HEADER

// Config header generated by autoconfig
#ifdef HAVE_CONFIG_H
	#include <oomph-lib-config.h>
#endif

#include "../cell_interface/cell_interface_elements.h"
#include "../cell_interface/segregated_cell_interface_elements.h"


namespace oomph{

class APDMeasurer
{
protected:

	//Open the file we write apd information to
	//Use this as an excuse to set up some variables too since we'll only be opening a file to record to once
	void OpenOutFile(std::string OutFileName)
	{
		OutFile.open(OutFileName);

		Num_Upstrokes = 0;
	}

	void MeasureAPD(const double& t, const double& v, const double& dvdt)
	{
		//Determine if we are in an upstroke, probably just use a threshold check
		// if( WE HAVE REPOLARIZED && THIS IS AN UPSTROKE )
		// {

		// }

		//Determine upstroke velocity(hint, it's just dvdt)


		//Are we in a plateau phase? Haibo has a check for this

		//Measure APD30, 50, 90

		//Have returned to the polarized state




		//Do we output? For example. Output APD30, 50, 90 once we reach the fully repolarized phase, or hit the next upstroke.
		//We don't want to output every time we record because that would slow down the simulation


		//Output the calculations
		OutFile << t << " " << v << " " << dvdt << std::endl;
	}

	//The file we output data to
	std::ofstream OutFile;

	//The number of times the cell has experienced an upstroke
	unsigned Num_Upstrokes;
};


template<class CELL_ELEMENT>
class CellProbe : public virtual APDMeasurer
{
public:

	CellProbe(CELL_ELEMENT* el_pt, std::string OutFileName, const unsigned& l = 0)
	{
		El_pt = el_pt;
		node = l;

		this->OpenOutFile(OutFileName);
	}

	//Perform recordings if we are an oomph lib element, grab the data straight from the element
	void Record()
	{
		const double t = El_pt->time_stepper_pt()->time();
		const double V = El_pt->get_nodal_membrane_potential(node);
		const double dVdt = El_pt->get_dnodal_membrane_potential_dt(node);

		this->MeasureAPD(t, V, dVdt);
	}

private:

	//The cell element
	CELL_ELEMENT* El_pt;

	//The node within the element we are measuring: used when El_pt is an oomph lib cell interface type element
	unsigned node;
};





template<unsigned NUM_VARS>
class FastCellProbe : public virtual APDMeasurer
{
public:

	FastCellProbe(FastSingleCell<NUM_VARS>* el_pt, std::string OutFileName)
	{
		El_pt = el_pt;

		this->OpenOutFile(OutFileName);
	}

	//Perform recordings if we don't have access to an oomph lib problem class
	void Record(const double&t)
	{
		double v;
		El_pt->get_vm(v);
		const double V = v;

		double dvdt;
		El_pt->get_dvmdt(dvdt);
		const double dVdt = dvdt;

		this->MeasureAPD(t, V, dVdt);
	}

private:

	//Open the file we write apd information to
	void OpenOutFile(std::string OutFileName)
	{
		OutFile.open(OutFileName);
	}

	//The cell element
	FastSingleCell<NUM_VARS>* El_pt;

};


}

#endif