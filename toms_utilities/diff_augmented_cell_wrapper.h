#ifndef OOMPH_DIFF_AUGMENTED_CELL
#define OOMPH_DIFF_AUGMENTED_CELL

// Config header generated by autoconfig
#ifdef HAVE_CONFIG_H
  #include <oomph-lib-config.h>
#endif

//OOMPH-LIB headers
#include "../generic/nodes.h"
#include "../generic/oomph_utilities.h"
#include "../generic/Qelements.h"
#include "../generic/Telements.h"
#include "../generic/error_estimator.h"
#include "../generic/oomph_utilities.h"

//Cell interface elements (includes cell models)
#include "../cell_interface/cell_interface_elements.h"


namespace oomph
{
	template<class CELL_ELEMENT>
	class DiffAugmentedCell	:	public virtual CELL_ELEMENT
	{
	public:
		DiffAugmentedCell()	:	CELL_ELEMENT()
		{
			//Make the internal data, nnode comes from CELL_ELEMENT(), data does not contribute to finite differencing
			// unsigned dummy_internal_data_pt = this->add_internal_data(new Data(1), false);
			// this->internal_data_pt(dummy_internal_data_pt)->pin(0);
			//Make data point for vector
			unsigned datasize = CELL_ELEMENT::nnode()*CELL_ELEMENT::dim()*CELL_ELEMENT::dim();
			Preferential_vectors_internal_index = this->add_internal_data(new Data(datasize), false);
			//Default to zero and pin them
			for(unsigned i=0;i<datasize;i++)
			{
				this->internal_data_pt(Preferential_vectors_internal_index)->set_value(i, 0.0);
				this->internal_data_pt(Preferential_vectors_internal_index)->pin(i);
			}
			//Make data point for diffusion coefficients
			Diffusion_coefficient_internal_index = this->add_internal_data(new Data(CELL_ELEMENT::nnode()*CELL_ELEMENT::dim()), false);
			//Default to zero and pin them
			for(unsigned i=0;i<CELL_ELEMENT::nnode()*CELL_ELEMENT::dim();i++)
			{
				this->internal_data_pt(Diffusion_coefficient_internal_index)->set_value(i, 0.0);
				this->internal_data_pt(Diffusion_coefficient_internal_index)->pin(i);
			}
		}

		// ~DiffAugmentedCell(){ CELL_ELEMENT::~CELL_ELEMENT(); }

		//Setter functions for vectors
		void set_preferential_vector_at_node(const unsigned &n, const unsigned &vect_ind, const Vector<double> &vector){
			for(unsigned d=0; d<CELL_ELEMENT::dim(); d++){
				// std::cout << "d: " << d << std::endl;
				this->internal_data_pt(Preferential_vectors_internal_index)->set_value(n*CELL_ELEMENT::dim()*CELL_ELEMENT::dim() + vect_ind*CELL_ELEMENT::dim() + d, vector[d]);
			}
		}

		//Getter function for vectors
		inline void get_preferential_vectors_at_node(const unsigned &n, DenseMatrix<double> &pref_vects) const {
			pref_vects.resize(CELL_ELEMENT::dim(),CELL_ELEMENT::dim());
			for(unsigned v=0; v<CELL_ELEMENT::dim(); v++){
				for(unsigned d=0; d<CELL_ELEMENT::dim(); d++){
					pref_vects(d,v) = this->internal_data_pt(Preferential_vectors_internal_index)->value(n*CELL_ELEMENT::dim()*CELL_ELEMENT::dim() + v*CELL_ELEMENT::dim() + d);
				}
			}
		}
		inline void get_interpolated_preferential_vectors(const Vector<double> &s, DenseMatrix<double> &interpolated_preferential_vectors) const {
			//Get the interpolation weights
			unsigned n_node = CELL_ELEMENT::nnode();
			Shape psi(n_node);
			CELL_ELEMENT::shape(s, psi);
			//The vectors at the current node
			DenseMatrix<double> nodal_pref_vects;
			nodal_pref_vects.resize(CELL_ELEMENT::dim(), CELL_ELEMENT::dim());
			//The interpolated vectors to be returned
			interpolated_preferential_vectors.resize(CELL_ELEMENT::dim(), CELL_ELEMENT::dim());

			for(unsigned l=0; l < n_node; l++){
				get_preferential_vectors_at_node(l, nodal_pref_vects);

				for(unsigned v=0; v<CELL_ELEMENT::dim(); v++){
					for(unsigned d=0; d<CELL_ELEMENT::dim(); d++){
						interpolated_preferential_vectors(d,v) += nodal_pref_vects(d,v)*psi[l];
					}
				}
			}
		}

		//Setter function for diffusion coefficients
		void set_diffusion_coefficients_at_node(const unsigned &node, const Vector<double> &diff_coeffs){
			for(unsigned d=0; d<CELL_ELEMENT::dim(); d++){
				this->internal_data_pt(Diffusion_coefficient_internal_index)->set_value(node*CELL_ELEMENT::dim() + d, diff_coeffs[d]);
			}
		}
		//Getter function for diffusion coefficients
		inline void get_diffusion_coefficients_at_node(const unsigned &n, Vector<double> &diff_coeffs) const {
			diff_coeffs.resize(CELL_ELEMENT::dim());
			for(unsigned d=0; d<CELL_ELEMENT::dim(); d++){
				diff_coeffs[d] = this->internal_data_pt(Diffusion_coefficient_internal_index)->value(n*CELL_ELEMENT::dim() + d);
			}
		}
		inline void get_interpolated_diffusion_coefficients(const Vector<double> &s, Vector<double> &interpolated_diff_coeffs) const {
			//Get the interpolation weights
			unsigned n_node = CELL_ELEMENT::nnode();
			Shape psi(n_node);
			CELL_ELEMENT::shape(s, psi);
			//The vectors at the current node
			Vector<double> nodal_diff_coeffs(CELL_ELEMENT::dim());
			//The interpolated vectors to be returned
			interpolated_diff_coeffs.resize(CELL_ELEMENT::dim());

			for(unsigned l=0; l < n_node; l++){
				get_diffusion_coefficients_at_node(l, nodal_diff_coeffs);
				for(unsigned d=0; d<CELL_ELEMENT::dim(); d++){
					interpolated_diff_coeffs[d] += nodal_diff_coeffs[d]*psi[l];
				}
			}
		}

		//Getter function for diffusion matrix
		inline void get_interpolated_diffusion_matrix(const Vector<double> &s, DenseMatrix<double> &diff_matrix){
			DenseMatrix<double> interpolated_preferential_vectors;
			Vector<double> interpolated_diff_coeffs;
			get_interpolated_preferential_vectors(s, interpolated_preferential_vectors);
			get_interpolated_diffusion_coefficients(s, interpolated_diff_coeffs);

			diff_matrix.resize(CELL_ELEMENT::dim(),CELL_ELEMENT::dim());

			for(unsigned i=0; i<CELL_ELEMENT::dim(); i++){
				for(unsigned j=0; j<CELL_ELEMENT::dim(); j++){
					for(unsigned v=0; v<CELL_ELEMENT::dim(); v++){
						diff_matrix(i,j) += interpolated_preferential_vectors(i,v)*
															interpolated_preferential_vectors(j,v)*
															interpolated_diff_coeffs[v];
					}
				}
			}
		}


	protected:

		unsigned Preferential_vectors_internal_index;
		unsigned Diffusion_coefficient_internal_index;
	};

}

#endif