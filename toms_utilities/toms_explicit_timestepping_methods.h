#ifndef OOMPH_TOMS_EXPLICIT_TIMESTEPPING_METHODS_HEADER
#define OOMPH_TOMS_EXPLICIT_TIMESTEPPING_METHODS_HEADER

// Config header generated by autoconfig
#ifdef HAVE_CONFIG_H
  #include <oomph-lib-config.h>
#endif

#include <unordered_map>
#include <functional>

//OOMPH-LIB headers
#include "../generic/nodes.h"
#include "../generic/oomph_utilities.h"
#include "../generic/Qelements.h"
#include "../generic/Telements.h"
#include "../generic/error_estimator.h"

#include "../cell_model_updated/cell_model_base_updated.h"

namespace oomph{

	//This is the base class for the cell classes, it contains functions required by the get derivatives function
	//we HAVE to do this. I know it's a bit clunky having to call functions through this container but the functions
	// we are calling are not static, this means we can't easily (or maybe ever) pass them as pointers. I spent a good
	// amount of time trying to find workarounds but I think this is the lesser of all evils

	class ConductingCellFunctionsBase
	{
	public:

		ConductingCellFunctionsBase() : StimFctPt(0)
		{}
		
		//Define the function template used for forcing terms and stuff
		typedef double (*CellInterfaceScalarFctPt)
		(const unsigned& ipt, const Vector<double>& s, const Vector<double>& x, const double& t);

		/////////////////////////////////////////////////////////////////////////////////
		//Get other variables
		//	these could be, for example:
		//	 strain in the tissue,
		//	 oxygen concentration,
		//	 variables which could be assigned node-wise, or could be the result of some computation and exist in a continuum
		//We leave this virtual since it's very implementation dependent, it could simply use function pointers to get the
		//	data we need as is seen in other source functions, or it could call on external elements to interpolate data
		//	from their own computation, or it could be any other exotic structure you like.
		/////////////////////////////////////////////////////////////////////////////////
		inline virtual void get_other_variables(const unsigned& ipt,
									            const Vector<double> &s,
									            const Vector<double>& x,
												const unsigned &l,
												const double &t,
												std::unordered_map<std::string, double> &Variables)
		{

		}


		CellInterfaceScalarFctPt StimFctPt;


		inline double get_stimulus(const unsigned& ipt,
						            const Vector<double> &s,
						            const Vector<double>& x,
									const double &t)
		{
			if(StimFctPt!=nullptr){
				return (*StimFctPt)(ipt,s,x,t);
			}
			else{
				return 0.0;
			}
		}


		CellInterfaceScalarFctPt &Stimulus_Function_Pt()
		{
			return StimFctPt;
		}


	};


	class CellSourcesPackagedWithLocationData
	{
	public:
		CellSourcesPackagedWithLocationData(ConductingCellFunctionsBase* ConductingCellFunctionsBase_Pt,
											CellModelBaseUpdated* CellModelBaseUpdated_Pt,
											const unsigned& ipt,
								            const Vector<double> &s,
								            const Vector<double>& x,
											const unsigned &l)
		{
			Base_Cell_Sources_Pt = ConductingCellFunctionsBase_Pt;
			Cell_Model_Base_Pt = CellModelBaseUpdated_Pt;

			Ipt = ipt;
			S = s;
			X = x;
			L = l;
		}
		~CellSourcesPackagedWithLocationData(){}

		double get_stimulus_current(const double& t)
		{
			return (Base_Cell_Sources_Pt->get_stimulus)(Ipt, S, X, t);
		}

		void get_time_dependent_variables(const double &t,
										std::unordered_map<std::string, double> &Variables)
		{
			(Base_Cell_Sources_Pt->get_other_variables)(Ipt, S, X, L, t, Variables);
		}


		void get_derivatives(const double &Vm,
							std::unordered_map<std::string, double> CellVariables,
							const double &t,
							const double &dt,
							const unsigned &cell_type,
							std::unordered_map<std::string, double> Other_Parameters,
							std::unordered_map<std::string, double> Other_Variables,
							std::unordered_map<std::string, double> &Variable_Derivatives,
							double &Iion)
		{
			(Cell_Model_Base_Pt->Calculate_Derivatives)(Vm, CellVariables, t, dt, cell_type, Other_Parameters, Other_Variables,\
															Variable_Derivatives, Iion);
		}


	private:
		//For the other variables and the stimulus source
		ConductingCellFunctionsBase* Base_Cell_Sources_Pt;
		//For the derivative function
		CellModelBaseUpdated* Cell_Model_Base_Pt;

		unsigned Ipt;
		Vector<double> S;
		Vector<double> X;
		unsigned L;
	};







	//These are some helpful operators and functions. The first two are operators which multiply a vector
	//	by a scalar. The second two are methods for adding together the entries in two unordered maps which
	//	share the same keys. The second of these also multiplies the entries of the second map before the addition


	//Define distribution of a scalar over and oomph lib vector
	//Verctor * scalar
	template<class _T>
	Vector<_T> operator * (Vector<_T> V, double scalar)
	{
		std::transform (V.begin (), V.end (), V.begin (),
                 std::bind1st (std::multiplies <_T> () , scalar)) ;
		return V;
	}

	template<class _T>
	Vector<_T> operator * (double scalar, Vector<_T> V)
	{
		std::transform (V.begin (), V.end (), V.begin (),
                 std::bind1st (std::multiplies <_T> () , scalar)) ;
		return V;
	}



	//Add the entries of an unordered map to another at the provided key names, return the resulting map
	std::unordered_map<std::string, double> add_unordered_maps(std::unordered_map<std::string, double> M1,
													std::unordered_map<std::string, double> M2,
													const std::vector<std::string> Keys)
	{
		// std::unordered_map<std::string, double> m;
		
		for(unsigned it = 0; it < Keys.size(); it++) {
		    M1[Keys[it]] = (M1.at(Keys[it]) + M2.at(Keys[it]));
		}

		return M1;
	}

	//The same but the values from the second unordered map are multiplied by a scalar before being added
	std::unordered_map<std::string, double> add_unordered_maps(std::unordered_map<std::string, double> M1,
													std::unordered_map<std::string, double> M2,
													const double &c,
													const std::vector<std::string> Keys)
	{
		for(unsigned it = 0; it <Keys.size(); it++) {
		    M1[Keys[it]] = (M1.at(Keys[it]) + c*M2.at(Keys[it]));
		}

		return M1;
	}



	//Some gross typedefs

	typedef std::unordered_map<std::string, double> (OtherVariablesFct)(const double &);

	typedef std::unordered_map<std::string, double> (*OtherVariablesFctPt)(const double &);


	typedef double (*StimFctPt)(const double& );


	//Function typedef of the derivative function
	typedef void (*DerivativeFctPt)(const double &Vm,
									std::unordered_map<std::string, double> Variables,
									const double &t,
									const double &dt,
									const unsigned &cell_type,
									std::unordered_map<std::string, double> Other_Parameters,
									std::unordered_map<std::string, double> Other_Variables,
									std::unordered_map<std::string, double> &Variable_Derivatives,
									double &Iion);


	typedef void (*TomsExplicitTimestepMethodsFctPt)(const double &Vm,
												std::unordered_map<std::string, double> &Variables,
												const std::vector<std::string> names_of_cell_variables,
												const double &t,
												const double &dt,
												const unsigned &cell_type,
												std::unordered_map<std::string, double> &Other_Parameters,
												CellSourcesPackagedWithLocationData &FunctionsContainer,
												std::unordered_map<std::string, double> &New_Variables,
												double &New_Vm);



	//The actual definitions of the explicit timestepping methods




	void ExplicitEuler(const double &Vm,
			std::unordered_map<std::string, double> &Variables,
			const std::vector<std::string> names_of_cell_variables,
			const double &t,
			const double &dt,
			const unsigned &cell_type,
			std::unordered_map<std::string, double> &Other_Parameters,
			CellSourcesPackagedWithLocationData &FunctionsContainer,
			std::unordered_map<std::string, double> &New_Variables,
			double &New_Vm)
	{
		std::unordered_map<std::string, double> Time_Dependent_Variables_Container;


		//Calculate K1
		std::unordered_map<std::string, double> K1;

		double K1_Iion;
		FunctionsContainer.get_time_dependent_variables(t,Time_Dependent_Variables_Container);
		FunctionsContainer.get_derivatives(Vm,
											Variables,
											t,
											dt,
											cell_type,
											Other_Parameters,
											Time_Dependent_Variables_Container,

											K1, K1_Iion);

		//Calculate the next timestep values of everything
		for(auto it = names_of_cell_variables.begin(); it != names_of_cell_variables.end(); ++it){
			New_Variables[*it] = Variables.at(*it) + dt*K1[*it];
		}
		New_Vm = Vm - dt*(K1_Iion + FunctionsContainer.get_stimulus_current(t));
	}




	void ImplicitEuler(const double &Vm,
			std::unordered_map<std::string, double> &Variables,
			const std::vector<std::string> names_of_cell_variables,
			const double &t,
			const double &dt,
			const unsigned &cell_type,
			std::unordered_map<std::string, double> &Other_Parameters,
			CellSourcesPackagedWithLocationData &FunctionsContainer,
			std::unordered_map<std::string, double> &New_Variables,
			double &New_Vm)
	{
		std::unordered_map<std::string, double> Time_Dependent_Variables_Container;


		New_Variables = Variables;
		New_Vm = Vm;

		std::unordered_map<std::string, double> K;

		double K_Iion;

		for(unsigned i=0; i<3; i++){
			//Get the derivatives for the current guess
			FunctionsContainer.get_derivatives(New_Vm,
											New_Variables,
											t,
											dt,
											cell_type,
											Other_Parameters,
											Time_Dependent_Variables_Container,

											K, K_Iion);
			
			//use those calculated derivatives to get the next guess
			for(auto it = names_of_cell_variables.begin(); it != names_of_cell_variables.end(); ++it){
				New_Variables[*it] = Variables.at(*it) + dt*K[*it];
			}
			New_Vm = Vm - dt*(K_Iion + FunctionsContainer.get_stimulus_current(t));
		}
	}




	// Runge kutta 4
	void RK4(const double &Vm,
			std::unordered_map<std::string, double> &Variables,
			const std::vector<std::string> names_of_cell_variables,
			const double &t,
			const double &dt,
			const unsigned &cell_type,
			std::unordered_map<std::string, double> &Other_Parameters,
			CellSourcesPackagedWithLocationData &FunctionsContainer,
			std::unordered_map<std::string, double> &New_Variables,
			double &New_Vm)
	{

		std::unordered_map<std::string, double> Time_Dependent_Variables_Container;


		//Calculate K1
		std::unordered_map<std::string, double> K1;

		double K1_Iion;
		FunctionsContainer.get_time_dependent_variables(t,Time_Dependent_Variables_Container);
		FunctionsContainer.get_derivatives(Vm,
											Variables,
											t,
											dt,
											cell_type,
											Other_Parameters,
											Time_Dependent_Variables_Container,

											K1, K1_Iion);
		
		//Calculate K2
		std::unordered_map<std::string, double> K2;
		double K2_Iion;
		FunctionsContainer.get_time_dependent_variables(t+(dt/2.0),Time_Dependent_Variables_Container);
		FunctionsContainer.get_derivatives(Vm - (dt/2.0)*(K1_Iion + FunctionsContainer.get_stimulus_current(t+dt/2.0)),
											add_unordered_maps(Variables, K1, (dt/2.0), names_of_cell_variables),
											t+(dt/2.0),
											dt,
											cell_type,
											Other_Parameters,
											Time_Dependent_Variables_Container,
											
											K2, K2_Iion);

		//Calculate K3
		std::unordered_map<std::string, double> K3;
		double K3_Iion;
		FunctionsContainer.get_time_dependent_variables(t+(dt/2.0),Time_Dependent_Variables_Container);
		FunctionsContainer.get_derivatives(Vm - (dt/2.0)*(K2_Iion + FunctionsContainer.get_stimulus_current(t+dt/2.0)),
											add_unordered_maps(Variables, K2, (dt/2.0), names_of_cell_variables),
											t+(dt/2.0),
											dt,
											cell_type,
											Other_Parameters,
											Time_Dependent_Variables_Container,

											K3, K3_Iion);

		//Calculate K4
		std::unordered_map<std::string, double> K4;
		double K4_Iion;
		FunctionsContainer.get_time_dependent_variables(t+dt,Time_Dependent_Variables_Container);
		FunctionsContainer.get_derivatives(Vm - dt*(K3_Iion + FunctionsContainer.get_stimulus_current(t+dt)),
											add_unordered_maps(Variables, K3, dt, names_of_cell_variables),
											t+dt,
											dt,
											cell_type,
											Other_Parameters,
											Time_Dependent_Variables_Container,

											K4, K4_Iion);


		//Calculate the next timestep values of everything
		for(auto it = names_of_cell_variables.begin(); it != names_of_cell_variables.end(); ++it){
			New_Variables[*it] = Variables.at(*it) + (dt/6.0)*(K1.at(*it) + 2.0*K2.at(*it) + 2.0*K3.at(*it) + K4.at(*it));

			// std::cout << "New Var " << New_Variables.at(*it) << std::endl;
		}
		New_Vm = Vm - (dt/6.0)*(K1_Iion + FunctionsContainer.get_stimulus_current(t) + 2.0*(K2_Iion + FunctionsContainer.get_stimulus_current(t+dt/2.0)) + 2.0*(K3_Iion+ FunctionsContainer.get_stimulus_current(t+dt/2.0)) + (K4_Iion+ FunctionsContainer.get_stimulus_current(t+dt)));

		// std::cout << "New Vm " << New_Vm << std::endl;

		// exit(0);
	}




}


#endif