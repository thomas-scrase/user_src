//LIC// ====================================================================
//LIC// This file contains the vector and diffusion storage enrichment elements
//LIC//   Used to add extra storage to cells specifically, provides
//LIC//		DIM*(DIM+1) storage values
//LIC//
//LIC// ====================================================================


#ifndef OOMPH_VECTOR_WITH_DIFFUSION_STORAGE_ENRICHMENT_ELEMENT
#define OOMPH_VECTOR_WITH_DIFFUSION_STORAGE_ENRICHMENT_ELEMENT	

// Config header generated by autoconfig
#ifdef HAVE_CONFIG_H
  #include <oomph-lib-config.h>
#endif

//OOMPH-LIB headers
#include "../generic/nodes.h"
#include "../generic/oomph_utilities.h"
#include "../generic/Qelements.h"
#include "../generic/Telements.h"
#include "../generic/error_estimator.h"
#include "../generic/oomph_utilities.h"

#include "storage_enrichment_elements.h"

namespace oomph
{
	//Equations, this is just a wrapper providing more detailed information on the local storage location of
	//	fibre and diffusion data and functions to provide interpolated fibre, diffusion coefficients and diffusion matrix
	//	to ease multidomain functions
	template<unsigned NUM>
	class VectorWithDiffusionStorageEnrichmentEquations	:	public virtual StorageEnrichmentEquations<NUM>
	{
	public:
		VectorWithDiffusionStorageEnrichmentEquations()	:
		StorageEnrichmentEquations<NUM>()
		{
			//Work out what the dimension of the problem is from the value of NUM,
			//	since there are DIM*DIM fibre components and DIM diffusion coefficients, it follows
			//	that there should be DIM*(DIM+1) data values, if NUM is not a sensible value
			//	then return an error because something horrible has happened.
			switch(NUM){
				case 2:		dimfromnum = 1;
				case 6:		dimfromnum = 2;
				case 12:	dimfromnum = 3;
				default:	{
					std::string error_message =
					"The value of NUM = ";
					error_message += std::to_string(NUM);
					error_message += " is not permissible, it only makes sense to = 2(DIM=1), 6(DIM=2), or 12(DIM=3)";
					throw OomphLibError(error_message,
											OOMPH_CURRENT_FUNCTION,
											OOMPH_EXCEPTION_LOCATION);
				}
			}
		}

		//identify the indexes of the fibre and diffusion data
		virtual inline unsigned min_fibre_index_storage_enrichment() const {return this->min_index_storage_enrichment();}
		virtual inline unsigned min_diffusion_index_storage_enrichment() const {return min_fibre_index_storage_enrichment() + dimfromnum*dimfromnum;}


		//Define how the interpolated fibre, diffusion coefficients, and diffusion matrix
		// are calculated at local coordinate s
		//Fibre orientations OUTPUT(i,0) - f, OUTPUT(i,1) - s, OUTPUT(i,2) - n
		inline DenseMatrix<double> get_interpolated_fibre_orientation_augmented_cell(const Vector<double> &s){

			unsigned n_node = this->nnode();
			Shape psi(n_node);
			this->shape(s, psi);

			DenseMatrix<double> fibre_orientations(dimfromnum,0.0);

			for(unsigned v = 0; v < dimfromnum; v++){
				for(unsigned d = 0; d < dimfromnum; d++){
					for(unsigned l = 0; l < n_node; l++){
						fibre_orientations(d,v) += this->nodal_value(l, min_fibre_index_storage_enrichment() + v*dimfromnum + d)*psi[l];
					}
				}
			}
			return fibre_orientations;
		}

		//Diffusion coefficients OUTPUT[0] - f, OUTPUT[1] - s, OUTPUT[2] - n
		inline Vector<double> get_interpolated_diffusion_coefficient_augmented_cell(const Vector<double> &s){

			unsigned n_node = this->nnode();
			Shape psi(n_node);
			this->shape(s, psi);

			Vector<double> diffusion_coefficients(dimfromnum,0.0);

			for(unsigned v = 0; v < dimfromnum; v++){
				for(unsigned l = 0; l < n_node; l++){
					diffusion_coefficients[v] += this->nodal_value(l, min_diffusion_index_storage_enrichment() + v)*psi[l];
				}
			}
			return diffusion_coefficients;
		}


		inline DenseMatrix<double> get_interpolated_diffusion_matrix_augmented_cell(const Vector<double> &s){
			
			unsigned n_node = this->nnode();
			Shape psi(n_node);
			this->shape(s, psi);

			DenseMatrix<double> diffusion_matrix(dimfromnum, 0.0);

			Vector<double> vect(dimfromnum);
			double dcoeff;

			//Loop over the vectors
			for(unsigned v = 0; v < dimfromnum; v++){
				//Zero the vector
				for(unsigned d = 0; d < dimfromnum; d++){vect[d] = 0.0;}
				//And the diffusion coefficient
				dcoeff = 0.0;

				//Loop over the nodes
				for(unsigned l = 0; l < n_node; l++){
					//Calculate the diff coeff for this vector
					dcoeff += this->nodal_value(l, min_diffusion_index_storage_enrichment() + v)*psi[l];
					//Loop over the components of the vector
					for(unsigned d = 0; d < dimfromnum; d++){
						vect[d] += this->nodal_value(l, min_fibre_index_storage_enrichment() + v*dimfromnum + d)*psi[l];
					}
				}
				//Add the contribution of the vector and diff coefficient to the matrix
				for(unsigned i = 0; i < dimfromnum; i++){
					for(unsigned j = 0; j < dimfromnum; j++){
						diffusion_matrix(i,j) += vect[i]*vect[j]*dcoeff;
					}
				}
			}

			return diffusion_matrix;
		}

	private:
		//This is used to work out the relative "local" locations of the fibre and diffusion data
		unsigned dimfromnum;
	};






	//======================================================================
	/// \short QVectorWithDiffusionStorageEnrichmentElement elements are 
	/// linear/quadrilateral/brick-shaped Advection Diffusion elements with 
	/// isoparametric interpolation for the function.
	//======================================================================
	template <unsigned DIM, unsigned NNODE_1D>
	class QVectorWithDiffusionStorageEnrichmentElement : 
	public virtual QElement<DIM,NNODE_1D>,
	public virtual VectorWithDiffusionStorageEnrichmentEquations<DIM*(DIM+1)>
	{

	private:

	/// \short Static array of ints to hold number of variables at 
	/// nodes: Initial_Nvalue[n]
	static const unsigned Initial_Nvalue;

	public:


	///\short  Constructor: Call constructors for QElement and 
	/// Advection Diffusion equations
	QVectorWithDiffusionStorageEnrichmentElement() : 
	QElement<DIM,NNODE_1D>(), 
	StorageEnrichmentEquations<DIM*(DIM+1)>()
	{ }

	/// Broken copy constructor
	QVectorWithDiffusionStorageEnrichmentElement(
	const QVectorWithDiffusionStorageEnrichmentElement<DIM, NNODE_1D>&  dummy) 
	{BrokenCopy::broken_copy("QVectorWithDiffusionStorageEnrichmentElement");} 

	/// Broken assignment operator
	void operator=(const QVectorWithDiffusionStorageEnrichmentElement<DIM, NNODE_1D>&) 
	{BrokenCopy::broken_assign("QVectorWithDiffusionStorageEnrichmentElement");}

	/// \short  Required  # of `values' (pinned or dofs) 
	/// at node n
	inline unsigned required_nvalue(const unsigned &n) const 
	{return Initial_Nvalue;}

	/// \short Output function:  
	///  x,y,u   or    x,y,z,u
	void output(std::ostream &outfile)
	{StorageEnrichmentEquations<DIM*(DIM+1)>::output(outfile);}

	/// \short Output function:  
	///  x,y,u   or    x,y,z,u at n_plot^DIM plot points
	void output(std::ostream &outfile, const unsigned &n_plot)
	{StorageEnrichmentEquations<DIM*(DIM+1)>::output(outfile,n_plot);}


	/// \short C-style output function:  
	///  x,y,u   or    x,y,z,u
	void output(FILE* file_pt)
	{StorageEnrichmentEquations<DIM*(DIM+1)>::output(file_pt);}

	///  \short C-style output function:  
	///   x,y,u   or    x,y,z,u at n_plot^DIM plot points
	void output(FILE* file_pt, const unsigned &n_plot)
	{StorageEnrichmentEquations<DIM*(DIM+1)>::output(file_pt,n_plot);}

	/// \short Output function for an exact solution:
	///  x,y,u_exact   or    x,y,z,u_exact at n_plot^DIM plot points
	void output_fct(std::ostream &outfile, const unsigned &n_plot,
	FiniteElement::SteadyExactSolutionFctPt 
	exact_soln_pt)
	{StorageEnrichmentEquations<DIM*(DIM+1)>::output_fct(outfile,n_plot,exact_soln_pt);}


	/// \short Output function for a time-dependent exact solution.
	///  x,y,u_exact   or    x,y,z,u_exact at n_plot^DIM plot points
	/// (Calls the steady version)
	void output_fct(std::ostream &outfile, const unsigned &n_plot,
	const double& time,
	FiniteElement::UnsteadyExactSolutionFctPt 
	exact_soln_pt)
	{StorageEnrichmentEquations<DIM*(DIM+1)>::output_fct(outfile,n_plot,time,exact_soln_pt);}


	protected:

	/// Shape, test functions & derivs. w.r.t. to global coords. Return Jacobian.
	inline double dshape_and_dtest_eulerian_storage_enrichment(
	const Vector<double> &s, 
	Shape &psi, 
	DShape &dpsidx, 
	Shape &test, 
	DShape &dtestdx) const;

	/// \short Shape, test functions & derivs. w.r.t. to global coords. at
	/// integration point ipt. Return Jacobian.
	inline double dshape_and_dtest_eulerian_at_knot_storage_enrichment(
	const unsigned& ipt,
	Shape &psi, 
	DShape &dpsidx, 
	Shape &test,
	DShape &dtestdx) 
	const;

	};

	//Inline functions:


	//======================================================================
	/// \short Define the shape functions and test functions and derivatives
	/// w.r.t. global coordinates and return Jacobian of mapping.
	///
	/// Galerkin: Test functions = shape functions
	//======================================================================
	template<unsigned DIM, unsigned NNODE_1D>
	double QVectorWithDiffusionStorageEnrichmentElement<DIM, NNODE_1D>::
	dshape_and_dtest_eulerian_storage_enrichment(const Vector<double> &s,
	Shape &psi, 
	DShape &dpsidx,
	Shape &test, 
	DShape &dtestdx) const
	{
	//Call the geometrical shape functions and derivatives  
	double J = this->dshape_eulerian(s,psi,dpsidx);

	//Loop over the test functions and derivatives and set them equal to the
	//shape functions
	for(unsigned i=0;i<NNODE_1D;i++)
	{
	test[i] = psi[i]; 
	for(unsigned j=0;j<DIM;j++)
	{
	dtestdx(i,j) = dpsidx(i,j);
	}
	}

	//Return the jacobian
	return J;
	}



	//======================================================================
	/// Define the shape functions and test functions and derivatives
	/// w.r.t. global coordinates and return Jacobian of mapping.
	///
	/// Galerkin: Test functions = shape functions
	//======================================================================
	template<unsigned DIM, unsigned NNODE_1D>
	double QVectorWithDiffusionStorageEnrichmentElement<DIM, NNODE_1D>::
	dshape_and_dtest_eulerian_at_knot_storage_enrichment(
	const unsigned &ipt,
	Shape &psi, 
	DShape &dpsidx,
	Shape &test, 
	DShape &dtestdx) const
	{
	//Call the geometrical shape functions and derivatives  
	double J = this->dshape_eulerian_at_knot(ipt,psi,dpsidx);

	//Set the test functions equal to the shape functions (pointer copy)
	test = psi;
	dtestdx = dpsidx;

	//Return the jacobian
	return J;
	}


	////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////



	//=======================================================================
	/// \short Face geometry for the QVectorWithDiffusionStorageEnrichmentElement elements: 
	/// The spatial dimension of the face elements is one lower than that 
	/// of the bulk element but they have the same number of points along 
	/// their 1D edges.
	//=======================================================================
	template<unsigned DIM, unsigned NNODE_1D>
	class FaceGeometry<QVectorWithDiffusionStorageEnrichmentElement<DIM, NNODE_1D> >: 
	public virtual QElement<DIM-1,NNODE_1D>
	{

	public:

	/// \short Constructor: Call the constructor for the
	/// appropriate lower-dimensional QElement
	FaceGeometry() : QElement<DIM-1,NNODE_1D>() {}

	};



	////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////


	//=======================================================================
	/// Face geometry for the 1D QMonodomain elements: Point elements
	//=======================================================================
	template<unsigned NNODE_1D>
	class FaceGeometry<QVectorWithDiffusionStorageEnrichmentElement<1, NNODE_1D> >: 
	public virtual PointElement
	{

	public:

	/// \short Constructor: Call the constructor for the
	/// appropriate lower-dimensional QElement
	FaceGeometry() : PointElement() {}

	};





	/////////////////////////////////////////////////////////////////////////
	/////////////////////////////////////////////////////////////////////////
	// TVectorWithDiffusionStorageEnrichmentElement
	////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////



	//======================================================================
	/// \short TVectorWithDiffusionStorageEnrichmentElement elements are isoparametric triangular 
	/// DIM-dimensional General Advection Diffusion Equations with  NNODE_1D nodal points along each
	/// element edge. Inherits from TElement and AnisotropicSolidVectorExpansionEquations
	//======================================================================
	template <unsigned DIM, unsigned NNODE_1D>
	class TVectorWithDiffusionStorageEnrichmentElement : 
	public virtual TElement<DIM,NNODE_1D>,
	public virtual VectorWithDiffusionStorageEnrichmentEquations<DIM*(DIM+1)>
	{

	private:

	/// \short Static array of ints to hold number of variables at 
	/// nodes: Initial_Nvalue[n]
	static const unsigned Initial_Nvalue;

	public:


	///\short  Constructor: Call constructors for TElement and 
	/// Advection Diffusion equations
	TVectorWithDiffusionStorageEnrichmentElement() : TElement<DIM,NNODE_1D>(), 
	VectorWithDiffusionStorageEnrichmentEquations<DIM*(DIM+1)>()
	{ }

	/// Broken copy constructor
	TVectorWithDiffusionStorageEnrichmentElement(
	const TVectorWithDiffusionStorageEnrichmentElement<DIM, NNODE_1D>&  dummy) 
	{ 
	BrokenCopy::broken_copy("TVectorWithDiffusionStorageEnrichmentElement");
	} 

	/// Broken assignment operator
	void operator=(const TVectorWithDiffusionStorageEnrichmentElement<DIM, NNODE_1D>&) 
	{
	BrokenCopy::broken_assign("TVectorWithDiffusionStorageEnrichmentElement");
	}

	/// \short  Required  # of `values' (pinned or dofs) 
	/// at node n
	inline unsigned required_nvalue(const unsigned &n) const 
	{return Initial_Nvalue;}

	/// \short Output function:  
	///  x,y,u   or    x,y,z,u
	void output(std::ostream &outfile)
	{VectorWithDiffusionStorageEnrichmentEquations<DIM*(DIM+1)>::output(outfile);}

	/// \short Output function:  
	///  x,y,u   or    x,y,z,u at n_plot^DIM plot points
	void output(std::ostream &outfile, const unsigned &n_plot)
	{VectorWithDiffusionStorageEnrichmentEquations<DIM*(DIM+1)>::output(outfile,n_plot);}


	/// \short C-style output function:  
	///  x,y,u   or    x,y,z,u
	void output(FILE* file_pt)
	{
	VectorWithDiffusionStorageEnrichmentEquations<DIM*(DIM+1)>::output(file_pt);
	}

	///  \short C-style output function:  
	///   x,y,u   or    x,y,z,u at n_plot^DIM plot points
	void output(FILE* file_pt, const unsigned &n_plot)
	{
	VectorWithDiffusionStorageEnrichmentEquations<DIM*(DIM+1)>::output(file_pt,n_plot);
	}

	/// \short Output function for an exact solution:
	///  x,y,u_exact   or    x,y,z,u_exact at n_plot^DIM plot points
	void output_fct(std::ostream &outfile, const unsigned &n_plot,
	FiniteElement::SteadyExactSolutionFctPt 
	exact_soln_pt)
	{VectorWithDiffusionStorageEnrichmentEquations<DIM*(DIM+1)>::output_fct(outfile,n_plot,exact_soln_pt);}


	/// \short Output function for a time-dependent exact solution.
	///  x,y,u_exact   or    x,y,z,u_exact at n_plot^DIM plot points
	/// (Calls the steady version)
	void output_fct(std::ostream &outfile, const unsigned &n_plot,
	const double& time,
	FiniteElement::UnsteadyExactSolutionFctPt 
	exact_soln_pt)
	{
	VectorWithDiffusionStorageEnrichmentEquations<DIM*(DIM+1)>::
	output_fct(outfile,n_plot,time,exact_soln_pt);
	}


	protected:

	/// Shape, test functions & derivs. w.r.t. to global coords. Return Jacobian.
	inline double dshape_and_dtest_eulerian_storage_enrichment(
	const Vector<double> &s, 
	Shape &psi, 
	DShape &dpsidx, 
	Shape &test, 
	DShape &dtestdx) const;

	/// \short Shape, test functions & derivs. w.r.t. to global coords. at
	/// integration point ipt. Return Jacobian.
	inline double dshape_and_dtest_eulerian_at_knot_storage_enrichment(
	const unsigned& ipt,
	Shape &psi, 
	DShape &dpsidx, 
	Shape &test,
	DShape &dtestdx) 
	const;

	};

	//Inline functions:


	//======================================================================
	/// \short Define the shape functions and test functions and derivatives
	/// w.r.t. global coordinates and return Jacobian of mapping.
	///
	/// Galerkin: Test functions = shape functions
	//======================================================================
	template<unsigned DIM, unsigned NNODE_1D>
	double TVectorWithDiffusionStorageEnrichmentElement<DIM, NNODE_1D>::
	dshape_and_dtest_eulerian_storage_enrichment(const Vector<double> &s,
	Shape &psi, 
	DShape &dpsidx,
	Shape &test, 
	DShape &dtestdx) const
	{
	//Call the geometrical shape functions and derivatives  
	double J = this->dshape_eulerian(s,psi,dpsidx);

	//Loop over the test functions and derivatives and set them equal to the
	//shape functions
	for(unsigned i=0;i<NNODE_1D;i++)
	{
	test[i] = psi[i]; 
	for(unsigned j=0;j<DIM;j++)
	{
	dtestdx(i,j) = dpsidx(i,j);
	}
	}

	//Return the jacobian
	return J;
	}



	//======================================================================
	/// Define the shape functions and test functions and derivatives
	/// w.r.t. global coordinates and return Jacobian of mapping.
	///
	/// Galerkin: Test functions = shape functions
	//======================================================================
	template<unsigned DIM, unsigned NNODE_1D>
	double TVectorWithDiffusionStorageEnrichmentElement<DIM, NNODE_1D>::
	dshape_and_dtest_eulerian_at_knot_storage_enrichment(
	const unsigned &ipt,
	Shape &psi, 
	DShape &dpsidx,
	Shape &test, 
	DShape &dtestdx) const
	{
	//Call the geometrical shape functions and derivatives  
	double J = this->dshape_eulerian_at_knot(ipt,psi,dpsidx);

	//Set the test functions equal to the shape functions (pointer copy)
	test = psi;
	dtestdx = dpsidx;

	//Return the jacobian
	return J;
	}


	////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////



	//=======================================================================
	/// \short Face geometry for the TVectorWithDiffusionStorageEnrichmentElement elements: 
	/// The spatial dimension of the face elements is one lower than that 
	/// of the bulk element but they have the same number of points along 
	/// their 1D edges.
	//=======================================================================
	template<unsigned DIM, unsigned NNODE_1D>
	class FaceGeometry<TVectorWithDiffusionStorageEnrichmentElement<DIM, NNODE_1D> >: 
	public virtual TElement<DIM-1,NNODE_1D>
	{

	public:

	/// \short Constructor: Call the constructor for the
	/// appropriate lower-dimensional TElement
	FaceGeometry() : TElement<DIM-1,NNODE_1D>() {}

	};



	////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////


	//=======================================================================
	/// Face geometry for the 1D TVectorWithDiffusionStorageEnrichmentElement: Point elements
	//=======================================================================
	template<unsigned NNODE_1D>
	class FaceGeometry<TVectorWithDiffusionStorageEnrichmentElement<1, NNODE_1D> >: 
	public virtual PointElement
	{

	public:

	/// \short Constructor: Call the constructor for the
	/// appropriate lower-dimensional TElement
	FaceGeometry() : PointElement() {}

	};


}

#endif