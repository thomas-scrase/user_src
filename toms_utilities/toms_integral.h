//Header file for numerical integration routines based on quadrature
//  modified from the original oomph-lib file, includes additional
//  integration points which align with nodes. Allows accessing location
//  of nodes in external elements, useful for dynamic projection between
//  imperfectly aligned meshes.


//!!!!! GaussLobattoLegendreWithNodes and GaussLegendreWithNodes operate a little differently to
//       GaussWithNodes so I'm not sure if they will work, they calculate integral points and
//       weights on the fly

//Include guards to prevent multiple inclusions of the header
#ifndef OOMPH_TOMS_INTEGRAL_HEADER
#define OOMPH_TOMS_INTEGRAL_HEADER

 
// Config header generated by autoconfig
#ifdef HAVE_CONFIG_H
  #include <oomph-lib-config.h>
#endif

//oomph-lib headers
#include "../generic/oomph_utilities.h"
#include "../generic/orthpoly.h"

#include "../generic/integral.h"

namespace oomph
{

//=============================================================================
/// Broken pseudo-integration scheme for points elements: Iit's not clear
/// in general what this integration scheme is supposed to. It probably
/// ought to evaluate integrals to zero but we're not sure in what
/// context this may be used. Replace by your own integration scheme
/// that does what you want! 
//=============================================================================
class PointIntegralWithNodes : public Integral
{

public:

 /// Default constructor (empty)
 PointIntegralWithNodes(){};

 /// Broken copy constructor
 PointIntegralWithNodes(const PointIntegralWithNodes& dummy) 
  { 
   BrokenCopy::broken_copy("PointIntegralWithNodes");
  } 
 
 /// Broken assignment operator
 void operator=(const PointIntegralWithNodes&) 
  {
   BrokenCopy::broken_assign("PointIntegralWithNodes");
  }

 /// Number of integration points of the scheme
 unsigned nweight() const {return 1;}

 /// \short Return coordinate s[j] (j=0) of integration point i -- 
 /// deliberately broken!
 double knot(const unsigned &i, const unsigned &j) const 
  {
   throw OomphLibError(
    "Local coordinate vector is of size zero, so this should never be called.",
    OOMPH_CURRENT_FUNCTION, OOMPH_EXCEPTION_LOCATION);

   // Dummy return
   return 0.0;
  }

 /// Return weight of integration point i
 double weight(const unsigned &i) const {return 1.0;}

}; 

//=========================================================
/// Class for multidimensional Gaussian integration rules
///
/// Empty -- just establishes the template parameters.
///
/// General logic: The template parameters correspond to those
/// of the QElement family so that the integration scheme
/// GaussWithNodes<DIM,NNODE_1D> provides the default ("full") integration
/// scheme for QElement<DIM,NNODE_1D>. "Full" integration
/// means that for linear PDEs that are discretised on a uniform 
/// mesh, all integrals arising in the Galerkin weak form of the PDE
/// are evaluated exactly. In such problems the highest-order 
/// polynomials arise from the products of the undifferentiated 
/// shape and test functions so a 4 node quad needs 
/// an integration scheme that can integrate fourth-order 
/// polynomials exactly etc.
//=========================================================
template <unsigned DIM, unsigned NPTS_1D>
class GaussWithNodes 
{
};



//=========================================================
/// 1D Gaussian integration class.
/// Two integration points. This integration scheme can 
/// integrate up to third-order polynomials exactly and
/// is therefore a suitable "full" integration scheme
/// for linear (two-node) elements in which the
/// highest-order polynomial is quadratic.
//=========================================================
template<>
class GaussWithNodes<1,2> : public Integral
{
  private:

 /// Number of integration points in the scheme
 static const unsigned Npts=4; // 2+2
 /// Array to hold weights and knot points (defined in cc file)
 static const double Knot[4][1], Weight[4];

public:


 /// Default constructor (empty)
 GaussWithNodes(){};

 /// Broken copy constructor
 GaussWithNodes(const GaussWithNodes& dummy) 
  { 
   BrokenCopy::broken_copy("GaussWithNodes");
  } 
 
 /// Broken assignment operator
 void operator=(const GaussWithNodes&) 
  {
   BrokenCopy::broken_assign("GaussWithNodes");
  }

 /// Number of integration points of the scheme
 unsigned nweight() const {return Npts;}

 /// Return coordinate s[j] (j=0) of integration point i
 double knot(const unsigned &i, const unsigned &j) const 
  {return Knot[i][j];}

 /// Return weight of integration point i
 double weight(const unsigned &i) const {return Weight[i];}

}; 

//=========================================================
/// 1D Gaussian integration class.
/// Three integration points. This integration scheme can 
/// integrate up to fifth-order polynomials exactly and
/// is therefore a suitable "full" integration scheme
/// for quadratic (three-node) elements in which the
/// highest-order polynomial is fourth order.
//=========================================================
template<>
class GaussWithNodes<1,3> : public Integral
{
  private:
 
 /// Number of integration points in the scheme
 static const unsigned Npts=6; // 3+3
 /// Array to hold weights and knot points (defined in cc file)
 static const double Knot[6][1], Weight[6];

  public:


 /// Default constructor (empty)
 GaussWithNodes(){};

 /// Broken copy constructor
 GaussWithNodes(const GaussWithNodes& dummy) 
  { 
   BrokenCopy::broken_copy("GaussWithNodes");
  } 
 
 /// Broken assignment operator
 void operator=(const GaussWithNodes&) 
  {
   BrokenCopy::broken_assign("GaussWithNodes");
  }

 /// Number of integration points of the scheme
 unsigned nweight() const {return Npts;}

 /// Return coordinate s[j] (j=0) of integration point i
 double knot(const unsigned &i, const unsigned &j) const 
  {return Knot[i][j];}

 /// Return weight of integration point i
 double weight(const unsigned &i) const {return Weight[i];}


}; 

//=========================================================
/// 1D Gaussian integration class 
/// Four integration points. This integration scheme can 
/// integrate up to seventh-order polynomials exactly and
/// is therefore a suitable "full" integration scheme
/// for cubic (four-node) elements in which the
/// highest-order polynomial is sixth order.
//=========================================================
template<>
class GaussWithNodes<1,4> : public Integral
{

private:

 /// Number of integration points in the scheme
 static const unsigned Npts=8; // 4+4
 /// Array to hold weight and knot points (defined in cc file)
 static const double Knot[8][1], Weight[8];

public:

 /// Default constructor (empty)
 GaussWithNodes(){};

 /// Broken copy constructor
 GaussWithNodes(const GaussWithNodes& dummy) 
  { 
   BrokenCopy::broken_copy("GaussWithNodes");
  } 
 
 /// Broken assignment operator
 void operator=(const GaussWithNodes&) 
  {
   BrokenCopy::broken_assign("GaussWithNodes");
  }

 /// Number of integration points of the scheme
 unsigned nweight() const {return Npts;}

 /// Return coordinate x[j] (j=0) of integration point i
 double knot(const unsigned &i, const unsigned &j) const 
  {return Knot[i][j];}

 /// Return weight of integration point i
 double weight(const unsigned &i) const {return Weight[i];}


}; 

//=========================================================
/// 2D Gaussian integration class.
/// 2x2 integration points. This integration scheme can 
/// integrate up to third-order polynomials exactly and
/// is therefore a suitable "full" integration scheme
/// for linear (four-node) elements in which the
/// highest-order polynomial is quadratic.
//=========================================================
template<>
class GaussWithNodes<2,2> : public Integral
{

private:

 /// Number of integration points in the scheme
 static const unsigned Npts=8;//=4+4;
 /// Array to hold the weight and know points (defined in cc file)
 static const double Knot[8][2], Weight[8];

public:


 /// Default constructor (empty)
 GaussWithNodes(){};

 /// Broken copy constructor
 GaussWithNodes(const GaussWithNodes& dummy) 
  { 
   BrokenCopy::broken_copy("GaussWithNodes");
  } 
 
 /// Broken assignment operator
 void operator=(const GaussWithNodes&) 
  {
   BrokenCopy::broken_assign("GaussWithNodes");
  }

 /// Number of integration points of the scheme
 unsigned nweight() const {return Npts;}

 /// Return coordinate x[j] of integration point i
 double knot(const unsigned &i, const unsigned &j) const
  {return Knot[i][j];}

 /// Return weight of integration point i
 double weight(const unsigned &i) const {return Weight[i];}
};

//=========================================================
/// 2D Gaussian integration class.
/// 3x3 integration points. This integration scheme can 
/// integrate up to fifth-order polynomials exactly and
/// is therefore a suitable "full" integration scheme
/// for quadratic (nine-node) elements in which the
/// highest-order polynomial is fourth order.
//=========================================================
template<>
class GaussWithNodes<2,3> : public Integral
{
  private:

 /// Number of integration points in the scheme
 static const unsigned Npts=18;//9+9;
 /// Array to hold the weights and knots (defined in cc file)
 static const double Knot[18][2], Weight[18];
 
  public:


 /// Default constructor (empty)
 GaussWithNodes(){};

 /// Broken copy constructor
 GaussWithNodes(const GaussWithNodes& dummy) 
  { 
   BrokenCopy::broken_copy("GaussWithNodes");
  } 
 
 /// Broken assignment operator
 void operator=(const GaussWithNodes&) 
  {
   BrokenCopy::broken_assign("GaussWithNodes");
  }

 /// Number of integration points of the scheme
 unsigned nweight() const {return Npts;}

 /// Return coordinate s[j] of integration point i
 double knot(const unsigned &i, const unsigned &j) const
  {return Knot[i][j];}

 /// Return weight of integration point i
 double weight(const unsigned &i) const {return Weight[i];}

};

//=========================================================
/// 2D Gaussian integration class. 
/// 4x4 integration points. This integration scheme can 
/// integrate up to seventh-order polynomials exactly and
/// is therefore a suitable "full" integration scheme
/// for cubic (sixteen-node) elements in which the
/// highest-order polynomial is sixth order.
//=========================================================
template<>
class GaussWithNodes<2,4> : public Integral
{
  private:

 /// Number of integration points in the scheme
 static const unsigned Npts=32;//16+16
 /// Array to hold the weights and knots (defined in cc file)
 static const double Knot[32][2], Weight[32];


  public:


 /// Default constructor (empty)
 GaussWithNodes(){};

 /// Broken copy constructor
 GaussWithNodes(const GaussWithNodes& dummy) 
  { 
   BrokenCopy::broken_copy("GaussWithNodes");
  } 
 
 /// Broken assignment operator
 void operator=(const GaussWithNodes&) 
  {
   BrokenCopy::broken_assign("GaussWithNodes");
  }

 /// Number of integration points of the scheme
 unsigned nweight() const {return Npts;}

 /// Return coordinate s[j] of integration point i
 double knot(const unsigned &i, const unsigned &j) const
  {return Knot[i][j];}

 /// Return weight of integration point i
 double weight(const unsigned &i) const {return Weight[i];}

};

//=========================================================
/// 3D Gaussian integration class
/// 2x2x2 integration points. This integration scheme can 
/// integrate up to third-order polynomials exactly and
/// is therefore a suitable "full" integration scheme
/// for linear (eight-node) elements in which the
/// highest-order polynomial is quadratic.
//=========================================================
template<>
class GaussWithNodes<3,2> : public Integral
{
  private:

 /// Number of integration points in the scheme
 static const unsigned Npts=16;//=8+8;
 /// Array to hold the weights and knots (defined in cc file)
 static const double Knot[16][3], Weight[16];

  public:


 /// Default constructor (empty)
 GaussWithNodes(){};

 /// Broken copy constructor
 GaussWithNodes(const GaussWithNodes& dummy) 
  { 
   BrokenCopy::broken_copy("GaussWithNodes");
  } 
 
 /// Broken assignment operator
 void operator=(const GaussWithNodes&) 
  {
   BrokenCopy::broken_assign("GaussWithNodes");
  }

 /// Number of integration points of the scheme
 unsigned nweight() const {return Npts;}

 /// Return coordinate s[j] of integration point i
 double knot(const unsigned &i, const unsigned &j) const
  {return Knot[i][j];}

 /// Return weight of integration point i
 double weight(const unsigned &i) const {return Weight[i];}

};

//=========================================================
/// 3D Gaussian integration class 
/// 3x3x3 integration points. This integration scheme can 
/// integrate up to fifth-order polynomials exactly and
/// is therefore a suitable "full" integration scheme
/// for quadratic (27-node) elements in which the
/// highest-order polynomial is fourth order.
//=========================================================
template<>
class GaussWithNodes<3,3> : public Integral
{
  private:

 /// Number of integration points in the scheme
 static const unsigned Npts=54;//=27+27;
 /// Array to hold the weights and knots (defined in cc file)
 static const double Knot[54][3], Weight[54];

  public:


 /// Default constructor (empty)
 GaussWithNodes(){};

 /// Broken copy constructor
 GaussWithNodes(const GaussWithNodes& dummy) 
  { 
   BrokenCopy::broken_copy("GaussWithNodes");
  } 
 
 /// Broken assignment operator
 void operator=(const GaussWithNodes&) 
  {
   BrokenCopy::broken_assign("GaussWithNodes");
  }

 /// Number of integration points of the scheme
 unsigned nweight() const {return Npts;}

 /// Return coordinate x[j] of integration point i
 double knot(const unsigned &i, const unsigned &j) const
  {return Knot[i][j];}

 /// Return weight of integration point i
 double weight(const unsigned &i) const {return Weight[i];}

};

//=========================================================
/// 3D Gaussian integration class.
/// 4x4x4 integration points. This integration scheme can 
/// integrate up to seventh-order polynomials exactly and
/// is therefore a suitable "full" integration scheme
/// for cubic (64-node) elements in which the
/// highest-order polynomial is sixth order.
//=========================================================
template<>
class GaussWithNodes<3,4> : public Integral
{
  private:

 /// Number of integration points in the scheme
 static const unsigned Npts=128;//=64+64
 /// Array to hold the weights and knots (defined in cc file)
 static const double Knot[128][3], Weight[128];

  public:

 /// Default constructor (empty)
 GaussWithNodes(){};

 /// Broken copy constructor
 GaussWithNodes(const GaussWithNodes& dummy) 
  { 
   BrokenCopy::broken_copy("GaussWithNodes");
  } 
 
 /// Broken assignment operator
 void operator=(const GaussWithNodes&) 
  {
   BrokenCopy::broken_assign("GaussWithNodes");
  }

 /// Number of integration points of the scheme
 unsigned nweight() const {return Npts;}

 /// Return coordinate x[j] of integration point i
 double knot(const unsigned &i, const unsigned &j) const
  {return Knot[i][j];}

 /// Return weight of integration point i
 double weight(const unsigned &i) const {return Weight[i];}

};

//=========================================================
///\short Class for multidimensional Gaussian integration rules, 
/// over intervals other than -1 to 1, all intervals are 
/// rescaled in this case
//=========================================================
template <unsigned DIM, unsigned NPTS_1D>
class Gauss_RescaledWithNodes : public GaussWithNodes<DIM,NPTS_1D>
{
  private:

 /// Store for the lower and upper limits of integration and the range
 double Lower, Upper, Range;

  public:

 /// Default constructor (empty)
 Gauss_RescaledWithNodes(){};

 /// Broken copy constructor
 Gauss_RescaledWithNodes(const Gauss_RescaledWithNodes& dummy) 
  { 
   BrokenCopy::broken_copy("Gauss_RescaledWithNodes");
  } 
 
 /// Broken assignment operator
 void operator=(const Gauss_RescaledWithNodes&) 
  {
   BrokenCopy::broken_assign("Gauss_RescaledWithNodes");
  }
 
 /// The constructor in this case takes the lower and upper arguments
 Gauss_RescaledWithNodes(double lower, double upper) : Lower(lower), Upper(upper)
  {
   //Set the range of integration
   Range = upper - lower;
  }

 /// Return the rescaled knot values s[j] at integration point i
 double knot(const unsigned &i, const unsigned &j) const
  {return (0.5*(Gauss<DIM,NPTS_1D>::knot(i,j)*Range + Lower + Upper));}

 /// Return the rescaled weight at integration point i
 double weight(const unsigned &i) const
  {return Gauss<DIM,NPTS_1D>::weight(i)*pow(0.5*Range,static_cast<int>(DIM));}

};

//=========================================================
/// Class for Gaussian integration rules for triangles/tets.
///
/// Empty -- just establishes the template parameters
///
/// General logic: The template parameters correspond to those
/// of the TElement family so that the integration scheme
/// TGaussWithNodes<DIM,NNODE_1D> provides the default ("full") integration
/// scheme for TElement<DIM,NNODE_1D>. "Full" integration
/// means that for linear PDEs that are discretised on a uniform 
/// mesh, all integrals arising in the Galerkin weak form of the PDE
/// are evaluated exactly. In such problems the highest-order 
/// polynomials arise from the products of the undifferentiated 
/// shape and test functions so a three node triangle needs 
/// an integration scheme that can integrate quadratic
/// polynomials exactly etc.
//=========================================================
template<unsigned DIM, unsigned NPTS_1D>
class TGaussWithNodes
{
};


//=========================================================
/// 1D Gaussian integration class for linear "triangular" elements.
/// Two integration points. This integration scheme can 
/// integrate up to second-order polynomials exactly and
/// is therefore a suitable "full" integration scheme
/// for linear (two-node) elements in which the
/// highest-order polynomial is quadratic.
//=========================================================
template<>
class TGaussWithNodes<1,2> : public Integral
{
  private:

 /// Number of integration points in the scheme
 static const unsigned Npts=2;

 /// Array to hold the weights and knots (defined in cc file)
 static const double Knot[2][1], Weight[2];

  public:


 /// Default constructor (empty)
 TGaussWithNodes(){};

 /// Broken copy constructor
 TGaussWithNodes(const TGaussWithNodes& dummy) 
  { 
   BrokenCopy::broken_copy("TGaussWithNodes");
  } 
 
 /// Broken assignment operator
 void operator=(const TGaussWithNodes&) 
  {
   BrokenCopy::broken_assign("TGaussWithNodes");
  }
 
 /// Number of integration points of the scheme
 unsigned nweight() const {return Npts;}

 /// Return coordinate x[j] of integration point i
 double knot(const unsigned &i, const unsigned &j) const
  {return Knot[i][j];}

 /// Return weight of integration point i
 double weight(const unsigned &i) const {return Weight[i];}

};

//=========================================================
/// 1D Gaussian integration class for quadratic "triangular" elements.
/// Three integration points. This integration scheme can 
/// integrate up to fifth-order polynomials exactly and
/// is therefore a suitable "full" integration scheme
/// for quadratic (three-node) elements in which the
/// highest-order polynomial is fourth order.
//=========================================================
template<>
class TGaussWithNodes<1,3> : public Integral
{
  private:

 /// Number of integration points in the scheme
 static const unsigned Npts=3;
 /// Array to hold the weights and knots (defined in cc file)
 static const double Knot[3][1], Weight[3];

  public:

 /// Default constructor (empty)
 TGaussWithNodes(){};

 /// Broken copy constructor
 TGaussWithNodes(const TGaussWithNodes& dummy) 
  { 
   BrokenCopy::broken_copy("TGaussWithNodes");
  } 
 
 /// Broken assignment operator
 void operator=(const TGaussWithNodes&) 
  {
   BrokenCopy::broken_assign("TGaussWithNodes");
  }

 /// Number of integration points of the scheme
 unsigned nweight() const {return Npts;}

 /// Return coordinate x[j] of integration point i
 double knot(const unsigned &i, const unsigned &j) const
  {return Knot[i][j];}

 /// Return weight of integration point i
 double weight(const unsigned &i) const {return Weight[i];}

};


//=========================================================
/// 1D Gaussian integration class for cubic "triangular" elements.
/// Four integration points. This integration scheme can 
/// integrate up to seventh-order polynomials exactly and
/// is therefore a suitable "full" integration scheme
/// for cubic (ten-node) elements in which the
/// highest-order polynomial is sixth order.
//=========================================================
template<>
class TGaussWithNodes<1,4> : public Integral
{
  private:

 /// Number of integration points in the scheme
 static const unsigned Npts=4;
 /// Array to hold the weights and knots (defined in cc file)
 static const double Knot[4][1], Weight[4];

  public:

 /// Default constructor (empty)
 TGaussWithNodes(){};

 /// Broken copy constructor
 TGaussWithNodes(const TGaussWithNodes& dummy) 
  { 
   BrokenCopy::broken_copy("TGaussWithNodes");
  } 
 
 /// Broken assignment operator
 void operator=(const TGaussWithNodes&) 
  {
   BrokenCopy::broken_assign("TGaussWithNodes");
  }

 /// Number of integration points of the scheme
 unsigned nweight() const {return Npts;}

 /// Return coordinate x[j] of integration point i
 double knot(const unsigned &i, const unsigned &j) const
  {return Knot[i][j];}

 /// Return weight of integration point i
 double weight(const unsigned &i) const {return Weight[i];}

};

//=========================================================
template<>
class TGaussWithNodes<1,5> : public Integral
{
  private:

 /// Number of integration points in the scheme
 static const unsigned Npts=5;
 /// Array to hold the weights and knots (defined in cc file)
 static const double Knot[5][1], Weight[5];

  public:

 /// Default constructor (empty)
 TGaussWithNodes(){};

 /// Broken copy constructor
 TGaussWithNodes(const TGaussWithNodes& dummy) 
  { 
   BrokenCopy::broken_copy("TGaussWithNodes");
  } 
 
 /// Broken assignment operator
 void operator=(const TGaussWithNodes&) 
  {
   BrokenCopy::broken_assign("TGaussWithNodes");
  }

 /// Number of integration points of the scheme
 unsigned nweight() const {return Npts;}

 /// Return coordinate x[j] of integration point i
 double knot(const unsigned &i, const unsigned &j) const
  {return Knot[i][j];}

 /// Return weight of integration point i
 double weight(const unsigned &i) const {return Weight[i];}

};


//=========================================================
/// 2D Gaussian integration class for linear triangles.
/// Three integration points. This integration scheme can 
/// integrate up to second-order polynomials exactly and
/// is therefore a suitable "full" integration scheme
/// for linear (three-node) elements in which the
/// highest-order polynomial is quadratic.
//=========================================================
template<>
class TGaussWithNodes<2,2> : public Integral
{
  private:

 /// Number of integration points in the scheme
 static const unsigned Npts=3;

 /// Array to hold the weights and knots (defined in cc file)
 static const double Knot[3][2], Weight[3];

  public:


 /// Default constructor (empty)
 TGaussWithNodes(){};

 /// Broken copy constructor
 TGaussWithNodes(const TGaussWithNodes& dummy) 
  { 
   BrokenCopy::broken_copy("TGaussWithNodes");
  } 
 
 /// Broken assignment operator
 void operator=(const TGaussWithNodes&) 
  {
   BrokenCopy::broken_assign("TGaussWithNodes");
  }
 
 /// Number of integration points of the scheme
 unsigned nweight() const {return Npts;}

 /// Return coordinate x[j] of integration point i
 double knot(const unsigned &i, const unsigned &j) const
  {return Knot[i][j];}

 /// Return weight of integration point i
 double weight(const unsigned &i) const {return Weight[i];}

};

//=========================================================
/// 2D Gaussian integration class for quadratic triangles.
/// Seven integration points. This integration scheme can 
/// integrate up to fifth-order polynomials exactly and
/// is therefore a suitable "full" integration scheme
/// for quadratic (six-node) elements in which the
/// highest-order polynomial is fourth order.
//=========================================================
template<>
class TGaussWithNodes<2,3> : public Integral
{
  private:

 /// Number of integration points in the scheme
 static const unsigned Npts=7;
 /// Array to hold the weights and knots (defined in cc file)
 static const double Knot[7][2], Weight[7];

  public:

 /// Default constructor (empty)
 TGaussWithNodes(){};

 /// Broken copy constructor
 TGaussWithNodes(const TGaussWithNodes& dummy) 
  { 
   BrokenCopy::broken_copy("TGaussWithNodes");
  } 
 
 /// Broken assignment operator
 void operator=(const TGaussWithNodes&) 
  {
   BrokenCopy::broken_assign("TGaussWithNodes");
  }

 /// Number of integration points of the scheme
 unsigned nweight() const {return Npts;}

 /// Return coordinate x[j] of integration point i
 double knot(const unsigned &i, const unsigned &j) const
  {return Knot[i][j];}

 /// Return weight of integration point i
 double weight(const unsigned &i) const {return Weight[i];}

};


//=========================================================
/// 2D Gaussian integration class for cubic triangles.
/// Thirteen integration points. This integration scheme can 
/// integrate up to seventh-order polynomials exactly and
/// is therefore a suitable "full" integration scheme
/// for cubic (ten-node) elements in which the
/// highest-order polynomial is sixth order.
//=========================================================
template<>
class TGaussWithNodes<2,4> : public Integral
{
  private:

 /// Number of integration points in the scheme
 static const unsigned Npts=13;
 /// Array to hold the weights and knots (defined in cc file)
 static const double Knot[13][2], Weight[13];

  public:

 /// Default constructor (empty)
 TGaussWithNodes(){};

 /// Broken copy constructor
 TGaussWithNodes(const TGaussWithNodes& dummy) 
  { 
   BrokenCopy::broken_copy("TGaussWithNodes");
  } 
 
 /// Broken assignment operator
 void operator=(const TGaussWithNodes&) 
  {
   BrokenCopy::broken_assign("TGaussWithNodes");
  }

 /// Number of integration points of the scheme
 unsigned nweight() const {return Npts;}

 /// Return coordinate x[j] of integration point i
 double knot(const unsigned &i, const unsigned &j) const
  {return Knot[i][j];}

 /// Return weight of integration point i
 double weight(const unsigned &i) const {return Weight[i];}

};

//------------------------------------------------------------
//"Full integration" weights for 2D triangles
// accurate up to order 11
// http://people.sc.fsu.edu/~jburkardt/datasets/quadrature_rules_tri/
// quadrature_rules_tri.html
//------------------------------------------------------------
 template<>
 class TGaussWithNodes<2,13> : public Integral
 {
 private:
  
  /// Number of integration points in the scheme
  static const unsigned Npts=37;
  /// Array to hold the weights and knots (defined in cc file)
  static const double Knot[37][2], Weight[37];
  
 public:
  
  /// Default constructor (empty)
  TGaussWithNodes(){};
   
  /// Broken copy constructor
  TGaussWithNodes(const TGaussWithNodes& dummy) 
   { 
    BrokenCopy::broken_copy("TGaussWithNodes");
   } 
  
  /// Broken assignment operator
  void operator=(const TGaussWithNodes&) 
   {
    BrokenCopy::broken_assign("TGaussWithNodes");
   }
  
  /// Number of integration points of the scheme
  unsigned nweight() const {return Npts;}
  
  /// Return coordinate x[j] of integration point i
  double knot(const unsigned &i, const unsigned &j) const
   {return Knot[i][j];}
  
  /// Return weight of integration point i
  double weight(const unsigned &i) const {return Weight[i];}
 };

//------------------------------------------------------------
//"Full integration" weights for 2D triangles
// accurate up to order 15
// http://people.sc.fsu.edu/~jburkardt/datasets/quadrature_rules_tri/quadrature_rules_tri.html
//------------------------------------------------------------

template<>
class TGaussWithNodes<2,5> : public Integral
{
  private:

 /// Number of integration points in the scheme
 static const unsigned Npts=64;
 /// Array to hold the weights and knots (defined in cc file)
 static const double Knot[64][2], Weight[64];

  public:

 /// Default constructor (empty)
 TGaussWithNodes(){};

 /// Broken copy constructor
 TGaussWithNodes(const TGaussWithNodes& dummy) 
  { 
   BrokenCopy::broken_copy("TGaussWithNodes");
  } 
 
 /// Broken assignment operator
 void operator=(const TGaussWithNodes&) 
  {
   BrokenCopy::broken_assign("TGaussWithNodes");
  }

 /// Number of integration points of the scheme
 unsigned nweight() const {return Npts;}

 /// Return coordinate x[j] of integration point i
 double knot(const unsigned &i, const unsigned &j) const
  {return Knot[i][j];}

 /// Return weight of integration point i
 double weight(const unsigned &i) const {return Weight[i];}

};

//=========================================================
/// 3D Gaussian integration class for tets.
/// Four integration points. This integration scheme can 
/// integrate up to second-order polynomials exactly and
/// is therefore a suitable "full" integration scheme
/// for linear (four-node) elements in which the
/// highest-order polynomial is quadratic.
//=========================================================
template<>
class TGaussWithNodes<3,2> : public Integral
{
  private:

 /// Number of integration points in the scheme
 static const unsigned Npts=4;
 /// Array to hold the weights and knots (defined in cc file)
 static const double Knot[4][3], Weight[4];

  public:


 /// Default constructor (empty)
 TGaussWithNodes(){};

 /// Broken copy constructor
 TGaussWithNodes(const TGaussWithNodes& dummy) 
  { 
   BrokenCopy::broken_copy("TGaussWithNodes");
  } 
 
 /// Broken assignment operator
 void operator=(const TGaussWithNodes&) 
  {
   BrokenCopy::broken_assign("TGaussWithNodes");
  }

 /// Number of integration points of the scheme
 unsigned nweight() const {return Npts;}

 /// Return coordinate x[j] of integration point i
 double knot(const unsigned &i, const unsigned &j) const
  {return Knot[i][j];}

 /// Return weight of integration point i
 double weight(const unsigned &i) const {return Weight[i];}

};



//=========================================================
/// 3D Gaussian integration class for tets.
/// Eleven integration points. This integration scheme can 
/// integrate up to fourth-order polynomials exactly and
/// is therefore a suitable "full" integration scheme
/// for quadratic (ten-node) elements in which the
/// highest-order polynomial is fourth order.
/// The numbers are from Keast CMAME 55 pp339-348 (1986)
//=========================================================
template<>
class TGaussWithNodes<3,3> : public Integral
{
  private:

 /// Number of integration points in the scheme
 static const unsigned Npts=11;
 /// Array to hold the weights and knots (defined in cc file)
 static const double Knot[11][3], Weight[11];

  public:


 /// Default constructor (empty)
 TGaussWithNodes(){};

 /// Broken copy constructor
 TGaussWithNodes(const TGaussWithNodes& dummy) 
  { 
   BrokenCopy::broken_copy("TGaussWithNodes");
  } 
 
 /// Broken assignment operator
 void operator=(const TGaussWithNodes&) 
  {
   BrokenCopy::broken_assign("TGaussWithNodes");
  }

 /// Number of integration points of the scheme
 unsigned nweight() const {return Npts;}

 /// Return coordinate x[j] of integration point i
 double knot(const unsigned &i, const unsigned &j) const
  {return Knot[i][j];}

 /// Return weight of integration point i
 double weight(const unsigned &i) const {return Weight[i];}

};


//=========================================================
/// 3D Gaussian integration class for tets.
/// 45 integration points. This integration scheme can 
/// integrate up to eighth-order polynomials exactly and
/// is therefore a suitable "full" integration scheme
/// for quartic elements in which the
/// highest-order polynomial is fourth order.
/// The numbers are from Keast CMAME 55 pp339-348 (1986)
//=========================================================
template<>
class TGaussWithNodes<3,5> : public Integral
{
  private:

 /// Number of integration points in the scheme
 static const unsigned Npts=45;
 /// Array to hold the weights and knots (defined in cc file)
 static const double Knot[45][3], Weight[45];

  public:


 /// Default constructor (empty)
 TGaussWithNodes(){};

 /// Broken copy constructor
 TGaussWithNodes(const TGaussWithNodes& dummy) 
  { 
   BrokenCopy::broken_copy("TGaussWithNodes");
  } 
 
 /// Broken assignment operator
 void operator=(const TGaussWithNodes&) 
  {
   BrokenCopy::broken_assign("TGaussWithNodes");
  }

 /// Number of integration points of the scheme
 unsigned nweight() const {return Npts;}

 /// Return coordinate x[j] of integration point i
 double knot(const unsigned &i, const unsigned &j) const
  {return Knot[i][j];}

 /// Return weight of integration point i
 double weight(const unsigned &i) const {return Weight[i];}

};



//===================================================================
/// Class for multidimensional Gauss Lobatto Legendre integration 
/// rules
/// empty - just establishes template parameters
//===================================================================
template <unsigned DIM, unsigned NPTS_1D>
class GaussLobattoLegendreWithNodes 
{
};

//===================================================================
/// 1D Gauss Lobatto Legendre integration class
//===================================================================
template<unsigned NPTS_1D>
class GaussLobattoLegendreWithNodes<1,NPTS_1D> : public Integral
{
private:

 /// Number of integration points in scheme
 static const unsigned Npts=NPTS_1D;
 /// Array to hold weight and knot points
 //These are not constant, because they are calculated on the fly
 double Knot[NPTS_1D][1], Weight[NPTS_1D];
 
public:

  /// Deafault constructor. Calculates and stores GLL nodes
  GaussLobattoLegendreWithNodes();

  /// Number of integration points of the scheme   
  unsigned nweight() const {return Npts;}

  /// Return coordinate s[j] (j=0) of integration point i
  double knot(const unsigned &i, const unsigned &j) const
   {return Knot[i][j];}

  /// Return weight of integration point i
  double weight(const unsigned &i) const {return Weight[i];}

};


//=============================================================
/// Calculate positions and weights for the 1D Gauss Lobatto
/// Legendre integration class
//=============================================================
template<unsigned NPTS_1D>
GaussLobattoLegendreWithNodes<1,NPTS_1D>::GaussLobattoLegendreWithNodes()
{
 //Temporary storage for the integration points
 Vector<double> s(NPTS_1D),w(NPTS_1D);
 //call the function that calculates the points
 Orthpoly::gll_nodes(NPTS_1D,s,w);
 //Populate the arrays
 for(unsigned i=0;i<NPTS_1D;i++)
  {
   Knot[i][0]=s[i];
   Weight[i]=w[i];
  }
}


//===================================================================
/// 2D Gauss Lobatto Legendre integration class
//===================================================================
template<unsigned NPTS_1D>
class GaussLobattoLegendreWithNodes<2,NPTS_1D> : public Integral
{
private:

  /// Number of integration points in scheme
  static const unsigned long int Npts=NPTS_1D*NPTS_1D;

  /// Array to hold weight and knot points
  double Knot[NPTS_1D*NPTS_1D][2], 
    Weight[NPTS_1D*NPTS_1D]; // COULDN'T MAKE THESE
  // const BECAUSE THEY ARE CALCULATED (at least currently)

public:

  /// Deafault constructor. Calculates and stores GLL nodes
  GaussLobattoLegendreWithNodes();

  /// Number of integration points of the scheme   
  unsigned nweight() const {return Npts;}

  /// Return coordinate s[j] (j=0) of integration point i
  double knot(const unsigned  &i, const unsigned &j) const
  {return Knot[i][j];}

  /// Return weight of integration point i
  double weight(const unsigned &i) const {return Weight[i];}

};

//=============================================================
/// Calculate positions and weights for the 2D Gauss Lobatto
/// Legendre integration class
//=============================================================

template<unsigned NPTS_1D>
GaussLobattoLegendreWithNodes<2,NPTS_1D>::GaussLobattoLegendreWithNodes()
{
 //Tempoarary storage for the 1D knots and weights
  Vector<double> s(NPTS_1D),w(NPTS_1D);
  //Call the function to populate the array
  Orthpoly::gll_nodes(NPTS_1D,s,w);
  int i_fast=0, i_slow=0;
  for(unsigned i=0;i<NPTS_1D*NPTS_1D;i++){
   if (i_fast == NPTS_1D){i_fast=0;i_slow++;}
   Knot[i][0]=s[i_fast];
   Knot[i][1]=s[i_slow];
   Weight[i]=w[i_fast]*w[i_slow];
   i_fast++;
  }
}




//===================================================================
/// 3D Gauss Lobatto Legendre integration class
//===================================================================
template<unsigned NPTS_1D>
class GaussLobattoLegendreWithNodes<3,NPTS_1D> : public Integral
{
private:

  /// Number of integration points in scheme
  static const unsigned long int Npts=NPTS_1D*NPTS_1D*NPTS_1D;

  /// Array to hold weight and knot points
  double Knot[NPTS_1D*NPTS_1D*NPTS_1D][3], 
   Weight[NPTS_1D*NPTS_1D*NPTS_1D]; // COULDN'T MAKE THESE
  // const BECAUSE THEY ARE CALCULATED (at least currently)

public:

  /// Deafault constructor. Calculates and stores GLL nodes
  GaussLobattoLegendreWithNodes();
  
  /// Number of integration points of the scheme   
  unsigned nweight() const {return Npts;}

  /// Return coordinate s[j] (j=0) of integration point i
  double knot(const unsigned  &i, const unsigned &j) const
  {return Knot[i][j];}

  /// Return weight of integration point i
  double weight(const unsigned &i) const {return Weight[i];}

};

//=============================================================
/// Calculate positions and weights for the 3D Gauss Lobatto
/// Legendre integration class
//=============================================================

template<unsigned NPTS_1D>
GaussLobattoLegendreWithNodes<3,NPTS_1D>::GaussLobattoLegendreWithNodes()
{
 //Tempoarary storage for the 1D knots and weights
  Vector<double> s(NPTS_1D),w(NPTS_1D);
  //Call the function to populate the array
  Orthpoly::gll_nodes(NPTS_1D,s,w);
  for(unsigned k=0;k<NPTS_1D;k++)
   {
    for(unsigned j=0;j<NPTS_1D;j++)
     {
      for(unsigned i=0;i<NPTS_1D;i++)
       {
        unsigned index = NPTS_1D*NPTS_1D*k + NPTS_1D*j + i;
        Knot[index][0]=s[i];
        Knot[index][1]=s[j];
        Knot[index][2]=s[k]; 
        Weight[index]=w[i]*w[j]*w[k];
       }
     }
   }
}

////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////



//===================================================================
/// Class for multidimensional Gauss  Legendre integration 
/// rules
/// empty - just establishes template parameters
//===================================================================
template <unsigned DIM, unsigned NPTS_1D>
class GaussLegendreWithNodes 
{
};

//===================================================================
/// 1D Gauss  Legendre integration class
//===================================================================
template<unsigned NPTS_1D>
class GaussLegendreWithNodes<1,NPTS_1D> : public Integral
{
private:

 /// Number of integration points in scheme
 static const unsigned Npts=NPTS_1D;
 /// Array to hold weight and knot points
 //These are not constant, because they are calculated on the fly
 double Knot[NPTS_1D][1], Weight[NPTS_1D];
 
public:

  /// Deafault constructor. Calculates and stores GLL nodes
  GaussLegendreWithNodes();

  /// Number of integration points of the scheme   
  unsigned nweight() const {return Npts;}

  /// Return coordinate s[j] (j=0) of integration point i
  double knot(const unsigned &i, const unsigned &j) const
   {return Knot[i][j];}

  /// Return weight of integration point i
  double weight(const unsigned &i) const {return Weight[i];}

};


//=============================================================
/// Calculate positions and weights for the 1D Gauss 
/// Legendre integration class
//=============================================================
template<unsigned NPTS_1D>
GaussLegendreWithNodes<1,NPTS_1D>::GaussLegendreWithNodes()
{
 //Temporary storage for the integration points
 Vector<double> s(NPTS_1D),w(NPTS_1D);
 //call the function that calculates the points
 Orthpoly::gl_nodes(NPTS_1D,s,w);
 //Populate the arrays
 for(unsigned i=0;i<NPTS_1D;i++)
  {
   Knot[i][0]=s[i];
   Weight[i]=w[i];
  }
}


//===================================================================
/// 2D Gauss  Legendre integration class
//===================================================================
template<unsigned NPTS_1D>
class GaussLegendreWithNodes<2,NPTS_1D> : public Integral
{
private:

  /// Number of integration points in scheme
  static const unsigned long int Npts=NPTS_1D*NPTS_1D;

  /// Array to hold weight and knot points
  double Knot[NPTS_1D*NPTS_1D][2], 
    Weight[NPTS_1D*NPTS_1D]; // COULDN'T MAKE THESE
  // const BECAUSE THEY ARE CALCULATED (at least currently)

public:

  /// Deafault constructor. Calculates and stores GLL nodes
  GaussLegendreWithNodes();

  /// Number of integration points of the scheme   
  unsigned nweight() const {return Npts;}

  /// Return coordinate s[j] (j=0) of integration point i
  double knot(const unsigned  &i, const unsigned &j) const
  {return Knot[i][j];}

  /// Return weight of integration point i
  double weight(const unsigned &i) const {return Weight[i];}

};

//=============================================================
/// Calculate positions and weights for the 2D Gauss 
/// Legendre integration class
//=============================================================

template<unsigned NPTS_1D>
GaussLegendreWithNodes<2,NPTS_1D>::GaussLegendreWithNodes()
{
 //Tempoarary storage for the 1D knots and weights
  Vector<double> s(NPTS_1D),w(NPTS_1D);
  //Call the function to populate the array
  Orthpoly::gl_nodes(NPTS_1D,s,w);
  int i_fast=0, i_slow=0;
  for(unsigned i=0;i<NPTS_1D*NPTS_1D;i++){
   if (i_fast == NPTS_1D){i_fast=0;i_slow++;}
   Knot[i][0]=s[i_fast];
   Knot[i][1]=s[i_slow];
   Weight[i]=w[i_fast]*w[i_slow];
   i_fast++;
  }
}




//===================================================================
/// 3D Gauss  Legendre integration class
//===================================================================
template<unsigned NPTS_1D>
class GaussLegendreWithNodes<3,NPTS_1D> : public Integral
{
private:

  /// Number of integration points in scheme
  static const unsigned long int Npts=NPTS_1D*NPTS_1D*NPTS_1D;

  /// Array to hold weight and knot points
  double Knot[NPTS_1D*NPTS_1D*NPTS_1D][3], 
   Weight[NPTS_1D*NPTS_1D*NPTS_1D]; // COULDN'T MAKE THESE
  // const BECAUSE THEY ARE CALCULATED (at least currently)

public:

  /// Deafault constructor. Calculates and stores GLL nodes
  GaussLegendreWithNodes();
  
  /// Number of integration points of the scheme   
  unsigned nweight() const {return Npts;}

  /// Return coordinate s[j] (j=0) of integration point i
  double knot(const unsigned  &i, const unsigned &j) const
  {return Knot[i][j];}

  /// Return weight of integration point i
  double weight(const unsigned &i) const {return Weight[i];}

};

//=============================================================
/// Calculate positions and weights for the 3D Gauss 
/// Legendre integration class
//=============================================================

template<unsigned NPTS_1D>
GaussLegendreWithNodes<3,NPTS_1D>::GaussLegendreWithNodes()
{
 //Tempoarary storage for the 1D knots and weights
  Vector<double> s(NPTS_1D),w(NPTS_1D);
  //Call the function to populate the array
  Orthpoly::gl_nodes(NPTS_1D,s,w);
  for(unsigned k=0;k<NPTS_1D;k++)
   {
    for(unsigned j=0;j<NPTS_1D;j++)
     {
      for(unsigned i=0;i<NPTS_1D;i++)
       {
        unsigned index = NPTS_1D*NPTS_1D*k + NPTS_1D*j + i;
        Knot[index][0]=s[i];
        Knot[index][1]=s[j];
        Knot[index][2]=s[k]; 
        Weight[index]=w[i]*w[j]*w[k];
       }
     }
   }
}




}

#endif
