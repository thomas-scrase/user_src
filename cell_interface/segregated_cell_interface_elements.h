#ifndef OOMPH_SEGREGATED_CELL_INTERFACE
#define OOMPH_SEGREGATED_CELL_INTERFACE

// Config header generated by autoconfig
#ifdef HAVE_CONFIG_H
	#include <oomph-lib-config.h>
#endif

#include "cell_interface_elements.h"

namespace oomph
{

//Changes made to CellInterfaceEquations
// All variables are automatically pinned. Timestepping is done by the cell model
//	and is performed independently of the oomph-lib newton solve
// Additional data is stored at each node - membrane current, active strain
// Stores CellState containers rather than creating them every time a step is taken.
//	This is allowed since it is assumed that the time-stepper for each cell is performed
//	by only a single element - using the Oomph_Cell_Interface_Helpers::Setup_Non_Overlapping_Nodes
//	machinery.
// There is no safeguard here which ensures that cells are only segregated solve
//	once. To ensure this make sure that your problem has suitable Communicator_pt->my_rank()
//	checks which ensures only a thread with a particular number can call a particular element.
//	This is (and must be) left up to the individual writing the driver code
template<unsigned DIM, unsigned NUM_VARS>
class SegregatedCellInterfaceEquations : public virtual CellInterfaceEquations<DIM, NUM_VARS>
{
public:
	SegregatedCellInterfaceEquations() : CellInterfaceEquations<DIM, NUM_VARS>()
	{
		//Resize the persistent cell states. We assume that we need them all
		// even though it is unlikely that this element will perform computation
		// for all the nodes.
		Persistent_Cell_States.resize(this->nnode());

		// std::cout << "Reporting on indexes: " << std::endl;
		// for(unsigned i=CellInterfaceEquations<DIM, NUM_VARS>::min_index_CellInterfaceEquations();
		// 			i<CellInterfaceEquations<DIM, NUM_VARS>::max_index_CellInterfaceEquations();
		// 			i++)
		// {
		// 	std::cout << i << " ";
		// }
		// std::cout << std::endl;
		// std::cout << membrane_current_index_SegregatedCellInterfaceEquations() << " ";
		// std::cout << active_strain_SegregatedCellInterfaceEquations() << std::endl;
		// exit(0);
	}

	SegregatedCellInterfaceEquations(const SegregatedCellInterfaceEquations& dummy)
		{BrokenCopy::broken_copy("SegregatedCellInterfaceEquations");}

	void operator=(const SegregatedCellInterfaceEquations&)
		{BrokenCopy::broken_assign("SegregatedCellInterfaceEquations");}

	//Indexes of membrane current and active strain - stored as nodal data
	//	to allow elements which do not compute/store the cell at that node
	//	to access this data for suitable interpolating
	virtual inline unsigned membrane_current_index_SegregatedCellInterfaceEquations() const
		{return CellInterfaceEquations<DIM, NUM_VARS>::max_index_CellInterfaceEquations();}
	virtual inline unsigned active_strain_SegregatedCellInterfaceEquations() const
		{return (membrane_current_index_SegregatedCellInterfaceEquations() + 1);}

	//dependent on cell type to allow for distinction between cell models
	//	in a combined cell model class. - We need two extra data for the
	//	membrane current and active strain
	inline unsigned required_nvalue(const unsigned &n) const override {
		return NUM_VARS+2;
	}

	//Pin all of the segregated variables. There is no need for them to be unpinned
	//	since they are updated manually
	void pin_all_segregated_vars(){
		//Pin all the nodal variables
		for(unsigned l=0; l<this->nnode(); l++){
			for(unsigned i=0; i<NUM_VARS+2; i++){
				this->node_pt(l)->pin(this->min_index_CellInterfaceEquations()+i);
			}
		}
	}
	//UnPin all of the segregated variables. There is no need for them to be unpinned
	//	since they are updated manually
	void unpin_all_segregated_vars(){
		//Pin all the nodal variables
		for(unsigned l=0; l<this->nnode(); l++){
			for(unsigned i=0; i<NUM_VARS+2; i++){
				this->node_pt(l)->unpin(this->min_index_CellInterfaceEquations()+i);
			}
		}
	}

	//The membrane current is stored at the node rather than needing to be computed
	//	each time it is required
	double get_nodal_membrane_current(const unsigned &l) const override
	{
		return this->node_pt(l)->value(membrane_current_index_SegregatedCellInterfaceEquations());
	}

	//The active strain is stored at the node rather than needing to be computed
	//	each time it is required
	double get_nodal_active_stress(const unsigned &l) const override
	{
		return this->node_pt(l)->value(active_strain_SegregatedCellInterfaceEquations());
	}

	//====================================================================
	//====================================================================
	//Residual and Jacobian functions
	//====================================================================
	//====================================================================
	//We don't need these two functions - they'll be called anyway
	//	by the oomph-lib machinery so we'll just blank them out
	void fill_in_contribution_to_residuals(Vector<double> &residuals)
	{
	   	//This function intentionally does nothing - we assume that all
	   	//	variables are pinned
	}
	void fill_in_contribution_to_jacobian(Vector<double> &residuals,
	                                   DenseMatrix<double> &jacobian)
	{
		//This function intentionally does nothing - we assume that all
		//	variables are pinned
	}


	//Intended for use with strang-splitting. To this aim a bool is provided
	//	pre_shift. pre_shift indicates that the time history values should be
	//	shifted before the explicit step is taken. It also means that the previously
	//	current values, those which were shifted to be the last values, are used as
	//	the initial conditions of the expliit solve. If pre_shift is set to false
	//	this indicates that the currently accepted value - the value achieved through
	//	the first segregated solve - is used as the initial value.
	//	These are both achived through assigning the values of new_state before any
	//	shifting is performed.
	void perform_segregated_solve(const bool& pre_shift = true, const double& override_dt = -1.0){
		//Preallocate some memory for the new variable values
		Vector<double> new_state(NUM_VARS);
		//loop over the cells
		for(unsigned l=0; l<this->nnode(); l++){
			//if the cell is not to be computed then don't compute it
			if(this->is_node_computed(l)){
				// oomph_info << this->node_pt(l) << std::endl;
				int nprev_steps=this->node_pt(l)->time_stepper_pt()->nprev_values();
				for(unsigned i=0; i<NUM_VARS; i++){
					new_state[i] = this->node_pt(l)->value(this->min_index_CellInterfaceEquations() + i);
				}
				if(pre_shift){
					//Shift the Data associated with the nodes with the Node's own timestepper
					for (int t=nprev_steps;t>0;t--){ 
						//Loop over the segregated variables
						for(unsigned i=0; i<NUM_VARS; i++){
							//Shift them
							this->node_pt(l)->
							set_value(t,
							this->min_index_CellInterfaceEquations() + i,
							this->node_pt(l)->value(t-1,this->min_index_CellInterfaceEquations() + i));
						}
						//Shift the membrane current
						this->node_pt(l)->
							set_value(t,
							this->membrane_current_index_SegregatedCellInterfaceEquations(),
							this->node_pt(l)->value(t-1,this->membrane_current_index_SegregatedCellInterfaceEquations()));
						//...and the active strain
						this->node_pt(l)->
							set_value(t,
							this->active_strain_SegregatedCellInterfaceEquations(),
							this->node_pt(l)->value(t-1,this->active_strain_SegregatedCellInterfaceEquations()));
					}
				}
				//fill in the cell state container
				this->fill_state_container_at_node(l, Persistent_Cell_States[l]);
				//If override_dt has been set we assume that it is at least zero, then we override the 
				//	dt set in the cell state
				if(override_dt>=0.0){Persistent_Cell_States[l].set_dt(override_dt);}
				//Perform the explicit solve
				this->cell_model_pt()->explicit_timestep(Persistent_Cell_States[l],new_state);
				//Allocate the new values of the variables
				for(unsigned i=0; i<NUM_VARS; i++){
					//Set the previous value to be the current one
					this->node_pt(l)->set_value(this->min_index_CellInterfaceEquations() + i, new_state[i]);
				}
				//Set the values of membrane current and active strain
				this->node_pt(l)->set_value(this->membrane_current_index_SegregatedCellInterfaceEquations(),Persistent_Cell_States[l].get_membrane_current());
				this->node_pt(l)->set_value(this->active_strain_SegregatedCellInterfaceEquations(),Persistent_Cell_States[l].get_active_strain());
			}
			// else{std::cout << "skipped node" << std::endl;}
		}
	}

protected:
	//We don't need this function - it'll be called anyway
	//	by the oomph-lib machinery so we'll just blank it out
	void fill_in_generic_residual_contribution_cell_interface(
		Vector<double> &residuals, DenseMatrix<double> &jacobian, 
		DenseMatrix<double> &mass_matrix, unsigned flag)
	{
		//This function intentionally does nothing - we assume that all
		//	variables are pinned
	}


private:
	Vector<CellState> Persistent_Cell_States;
};




//====================================================================
//====================================================================
//Q Element
//====================================================================
//====================================================================

template<unsigned DIM, unsigned NUM_VARS, unsigned NNODE_1D>
	class QSegregatedCellInterfaceElement	:
		public virtual QElement<DIM, NNODE_1D>,
		public virtual SegregatedCellInterfaceEquations<DIM, NUM_VARS>
	{
	private:

	public:
		//====================================================================
		//Constructors
		//====================================================================
		QSegregatedCellInterfaceElement()	:	QElement<DIM, NNODE_1D>(),
												SegregatedCellInterfaceEquations<DIM, NUM_VARS>()
		{
			//set the integration scheme to one with integral points aligned with the nodes
			// this->set_integration_scheme(new QNodesOnlyHijackedIntegralScheme<DIM, 2>);
			this->set_integration_scheme(new GaussWithNodes<DIM, 2>);
			//set the number of integral points which are not aligned with nodes
			this->ipt_not_at_nodes = this->integral_pt()->nweight() - this->nnode();
			//Pin all the nodal variables
			// for(unsigned l=0; l<this->nnode(); l++){
			// 	for(unsigned i=0; i<NUM_VARS+2; i++){
			// 		this->node_pt(l)->pin(this->min_index_CellInterfaceEquations()+i);
			// 	}
			// }
		}

		QSegregatedCellInterfaceElement(const QSegregatedCellInterfaceElement<DIM, NUM_VARS, NNODE_1D>& dummy)
			{BrokenCopy::broken_copy("QSegregatedCellInterfaceElement");}

		void operator=(const QSegregatedCellInterfaceElement<DIM, NUM_VARS, NNODE_1D>&)
			{BrokenCopy::broken_assign("QSegregatedCellInterfaceElement");}

		//====================================================================
		//Output functions
		//====================================================================
		/// Output with default number of plot points
		void output(std::ostream &outfile){
			SegregatedCellInterfaceEquations<DIM, NUM_VARS>::output(outfile);
		}
		/// \short Output FE representation of soln: x,y,V_fct,[vars] or x,y,z,V_fct,[vars] at 
		/// nplot^DIM plot points
		void output(std::ostream &outfile, const unsigned &nplot){
			SegregatedCellInterfaceEquations<DIM, NUM_VARS>::output(outfile, nplot);
		}
		/// C_style output with default number of plot points
		void output(FILE* file_pt){
			SegregatedCellInterfaceEquations<DIM, NUM_VARS>::output(file_pt);
		}
		 /// \short C-style output FE representation of soln: x,y,V_fct,[vars] or x,y,z,V_fct,[vars] at 
		 /// n_plot^DIM plot points
		 void output(FILE* file_pt, const unsigned &n_plot){
		 	SegregatedCellInterfaceEquations<DIM, NUM_VARS>::output(file_pt, n_plot);
		}
	};

	template<unsigned DIM, unsigned NUM_VARS, unsigned NNODE_1D>
	class FaceGeometry<QSegregatedCellInterfaceElement<DIM, NUM_VARS, NNODE_1D> >:
		public virtual QElement<DIM-1, NNODE_1D>
	{
	public:
		FaceGeometry()	:	QElement<DIM-1, NNODE_1D>()	{}
	};	

	template<unsigned NUM_VARS, unsigned NNODE_1D>
	class FaceGeometry<QSegregatedCellInterfaceElement<1, NUM_VARS, NNODE_1D> >:
		public virtual PointElement
	{
	public:
		FaceGeometry()	:	PointElement()	{}
	};


	//====================================================================
	//====================================================================
	//T Element
	//====================================================================
	//====================================================================

	template<unsigned DIM, unsigned NUM_VARS, unsigned NNODE_1D>
	class TSegregatedCellInterfaceElement	:
		public virtual TElement<DIM, NNODE_1D>,
		public virtual SegregatedCellInterfaceEquations<DIM, NUM_VARS>
	{
	private:

	public:
		//====================================================================
		//Constructors
		//====================================================================
		TSegregatedCellInterfaceElement()	:	TElement<DIM, NNODE_1D>(),
									SegregatedCellInterfaceEquations<DIM, NUM_VARS>()
		{
			//set the integration scheme to one with integral points aligned with the nodes
			// this->set_integration_scheme(new QNodesOnlyHijackedIntegralScheme<DIM, 2>);
			this->set_integration_scheme(new TGaussWithNodes<DIM, 2>);
			//set the number of integral points which are not aligned with nodes
			this->ipt_not_at_nodes = this->integral_pt()->nweight() - this->nnode();
		}

		TSegregatedCellInterfaceElement(const TSegregatedCellInterfaceElement<DIM, NUM_VARS, NNODE_1D>& dummy)
			{BrokenCopy::broken_copy("TSegregatedCellInterfaceElement");}

		void operator=(const TSegregatedCellInterfaceElement<DIM, NUM_VARS, NNODE_1D>&)
			{BrokenCopy::broken_assign("TSegregatedCellInterfaceElement");}

		//====================================================================
		//Output functions
		//====================================================================
		/// Output with default number of plot points
		void output(std::ostream &outfile){
			SegregatedCellInterfaceEquations<DIM, NUM_VARS>::output(outfile);
		}
		/// \short Output FE representation of soln: x,y,V_fct,[vars] or x,y,z,V_fct,[vars] at 
		/// nplot^DIM plot points
		void output(std::ostream &outfile, const unsigned &nplot){
			SegregatedCellInterfaceEquations<DIM, NUM_VARS>::output(outfile, nplot);
		}
		/// C_style output with default number of plot points
		void output(FILE* file_pt){
			SegregatedCellInterfaceEquations<DIM, NUM_VARS>::output(file_pt);
		}
		 /// \short C-style output FE representation of soln: x,y,V_fct,[vars] or x,y,z,V_fct,[vars] at 
		 /// n_plot^DIM plot points
		 void output(FILE* file_pt, const unsigned &n_plot){
		 	SegregatedCellInterfaceEquations<DIM, NUM_VARS>::output(file_pt, n_plot);
		}
	};

	template<unsigned DIM, unsigned NUM_VARS, unsigned NNODE_1D>
	class FaceGeometry<TSegregatedCellInterfaceElement<DIM, NUM_VARS, NNODE_1D> >:
		public virtual TElement<DIM-1, NNODE_1D>
	{
	public:
		FaceGeometry()	:	TElement<DIM-1, NNODE_1D>()	{}
	};	

	template<unsigned NUM_VARS, unsigned NNODE_1D>
	class FaceGeometry<TSegregatedCellInterfaceElement<1, NUM_VARS, NNODE_1D> >:
		public virtual PointElement
	{
	public:
		FaceGeometry()	:	PointElement()	{}
	};


}//End namespace

#endif